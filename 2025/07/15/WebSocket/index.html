<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>LexLady</title><script>var config = {"root":"/project/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link rel="stylesheet" href="/project/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/project/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/project/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/project/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/project/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/project/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1></h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-07-15T05:15:12.685Z" id="date"> 2025-07-15</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-09-02T15:57:33.372Z" id="updated"> 2025-09-02</time></div></span></div></div><hr><div id="post-content"><h1 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h1><p><code>WebSocket()</code></p>
<p>返回一个WebSocket对象。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>url</code>: 连接的URL，必须是以ws:&#x2F;&#x2F;，wss:&#x2F;&#x2F;或http:&#x2F;&#x2F;，https:&#x2F;&#x2F;开头的字符串。且不能包含查询字符串或片段标识符。</p>
<p><code>protocols</code>: 可选参数，指定子协议的字符串或字符串数组。</p>
<h1 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h1><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交互变得更加简单，允许服务器主动向客户端推送数据。在浏览器和服务器完成一次握手后，两者就直接可以创建一个持久化的连接，并进行双向通信。</p>
<h1 id="Gorilla-WebSocket"><a href="#Gorilla-WebSocket" class="headerlink" title="Gorilla WebSocket"></a>Gorilla WebSocket</h1><p>Gorilla WebSocket 是 Go 语言中一个流行的 WebSocket 库，提供了对 WebSocket 协议的完整支持。它支持多种功能，包括：</p>
<ul>
<li>处理 WebSocket 握手</li>
<li>读写消息</li>
<li>支持多种消息类型（文本、二进制、ping&#x2F;pong）</li>
<li>连接管理</li>
<li>支持子协议和扩展</li>
<li>错误处理</li>
</ul>
<p>现在我们来看看如何使用 Gorilla WebSocket 库来实现一个简单的 WebSocket 服务器和客户端。</p>
<h1 id="安装Gorilla-WebSocket"><a href="#安装Gorilla-WebSocket" class="headerlink" title="安装Gorilla WebSocket"></a>安装Gorilla WebSocket</h1><p>只需要使用go get命令安装Gorilla WebSocket库即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/gorilla/websocket<br></code></pre></td></tr></table></figure>

<h1 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h1><p>任何使用WebSocket的场景通常都需要一个服务器端和一个客户端。</p>
<p>服务器程序绑定到某个端口，并侦听任何传入的WebSocket连接请求。与连接有关的详细信息由websocket协议定义，并通过原始HTTP请求进行协商。</p>
<p>客户端程序尝试使用websocket URL与服务器建立连接。</p>
<h1 id="WebSocket服务器示例"><a href="#WebSocket服务器示例" class="headerlink" title="WebSocket服务器示例"></a>WebSocket服务器示例</h1><p>该服务器将在常规的HTTP服务器上实现，并添加一个socketHandler来处理WebSocket连接请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br> <br>    <span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br>)<br> <br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;&#125; <span class="hljs-comment">// use default options</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">socketHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// Upgrade our raw HTTP connection to a websocket based one</span><br>    conn, err := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;Error during connection upgradation:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br> <br>    <span class="hljs-comment">// The event loop</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        messageType, message, err := conn.ReadMessage()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error during message reading:&quot;</span>, err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;Received: %s&quot;</span>, message)<br>        err = conn.WriteMessage(messageType, message)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error during message writing:&quot;</span>, err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">home</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Index Page&quot;</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/socket&quot;</span>, socketHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, home)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Gorilla的工作是转换原始HTTP连接进入一个有状态的websocket连接。</p>
<p>这就是为什么使用<code>struct</code>调用<code>Upgrader</code>来帮助我们的原因。</p>
<p>我们通过使用全局升级程序变量<code>upgrader.Upgrade()</code>来帮助我们将任何传入的HTTP连接转换为websocket协议。这将返回给我们<code>*websocket.Connection</code>，现在可以使用它来处理websocket连接。</p>
<p>服务器使用<code>conn.ReadMessage()</code>读取消息，然后使用<code>conn.WriteMessage()</code>写入消息</p>
<p>该服务器只是将所有传入的Websocket消息回显到客户端，这说明了如何将Websocket用于全双工通信。</p>
<h1 id="WebSocket客户端示例"><a href="#WebSocket客户端示例" class="headerlink" title="WebSocket客户端示例"></a>WebSocket客户端示例</h1><p>这个简单的客户端将每隔1s不断发出消息。如果整个系统按预期工作，则服务器将接受间隔为1s的数据包，并回复相同的消息。</p>
<p>因此客户端还将具有接收传入的websocket数据包的功能。在我们的程序中，我们将有一个单独的goroutine处理程序<code>receiveHandler</code>，用于侦听这些数据包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;os/signal&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br> <br>    <span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br>)<br> <br><span class="hljs-keyword">var</span> done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">var</span> interrupt <span class="hljs-keyword">chan</span> os.Signal<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveHandler</span><span class="hljs-params">(connection *websocket.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br>    <span class="hljs-keyword">for</span> &#123;<br>        _, msg, err := connection.ReadMessage()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error in receive:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, msg)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// Channel to indicate that the receiverHandler is done</span><br>    interrupt = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal) <span class="hljs-comment">// Channel to listen for interrupt signal to terminate gracefully</span><br> <br>    signal.Notify(interrupt, os.Interrupt) <span class="hljs-comment">// Notify the interrupt channel for SIGINT</span><br> <br>    socketUrl := <span class="hljs-string">&quot;ws://localhost:8080&quot;</span> + <span class="hljs-string">&quot;/socket&quot;</span><br>    conn, _, err := websocket.DefaultDialer.Dial(socketUrl, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Error connecting to Websocket Server:&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    <span class="hljs-keyword">go</span> receiveHandler(conn)<br> <br>    <span class="hljs-comment">// Our main loop for the client</span><br>    <span class="hljs-comment">// We send our relevant packets here</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(<span class="hljs-number">1</span>) * time.Millisecond * <span class="hljs-number">1000</span>):<br>            <span class="hljs-comment">// Send an echo packet every second</span><br>            err := conn.WriteMessage(websocket.TextMessage, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from GolangDocs!&quot;</span>))<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Println(<span class="hljs-string">&quot;Error during writing to websocket:&quot;</span>, err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br> <br>        <span class="hljs-keyword">case</span> &lt;-interrupt:<br>            <span class="hljs-comment">// We received a SIGINT (Ctrl + C). Terminate gracefully...</span><br>            log.Println(<span class="hljs-string">&quot;Received SIGINT interrupt signal. Closing all pending connections&quot;</span>)<br> <br>            <span class="hljs-comment">// Close our websocket connection</span><br>            err := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Println(<span class="hljs-string">&quot;Error during closing websocket:&quot;</span>, err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br> <br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                log.Println(<span class="hljs-string">&quot;Receiver Channel Closed! Exiting....&quot;</span>)<br>            <span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(<span class="hljs-number">1</span>) * time.Second):<br>                log.Println(<span class="hljs-string">&quot;Timeout in closing receiving channel. Exiting....&quot;</span>)<br>            &#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果您观察代码，您会发现创建了两个通道<code>done</code>，<code>interrupt</code>用于<code>receiveHandler()</code>和<code>main()</code>之间的通信。</p>
<p>我们使用无限循环 + select来监听通道事件。<code>conn.WriteMessage()</code>每秒钟写一条消息。如果激活了中断信号，则所有未决的连接都将关闭，并且正常退出！</p>
<p>嵌套select是为了确保两件事：</p>
<ul>
<li>如果<code>receiveHandler</code>通道退出，则通道<code>done</code>将关闭。这是第一个<code>case &lt;-done</code>条件</li>
<li>如果<code>done</code>通道未关闭，则在1秒钟后会有超时，因此程序将在1秒钟超时后退出</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/project/2025/07/27/internal-network-penetration/">← Next internal-network-penetration</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/project/2025/03/03/HelloGit/">HelloGit Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/project/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Constructor"><span class="toc-number">1.</span> <span class="toc-text">Constructor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFWebSocket"><span class="toc-number">2.</span> <span class="toc-text">什么是WebSocket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gorilla-WebSocket"><span class="toc-number">3.</span> <span class="toc-text">Gorilla WebSocket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Gorilla-WebSocket"><span class="toc-number">4.</span> <span class="toc-text">安装Gorilla WebSocket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">示例场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSocket%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">WebSocket服务器示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">WebSocket客户端示例</span></a></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/project/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>