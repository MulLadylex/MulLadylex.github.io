<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>rust | LexLady</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>rust</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-09-08T12:32:10.000Z" id="date"> 2025-09-08</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-11-12T10:12:46.766Z" id="updated"> 2025-11-12</time></div></span></div></div><hr><div id="post-content"><p>rust 占位符 {}<br><code>!</code>符号，是一个宏规则。<br>{0}放置数字可以将可变参数当做数据来指定获取<br><code>&#123;&#123;转义&#123;`  `&#125;&#125;转义&#125;</code> 其他转义字符反斜杠开头</p>
<p>Rust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。<br>默认情况下，Rust 中的变量是不可变的，除非使用<code>mut</code>关键字声明为可变变量。</p>
<p>Rust 语言不允许精度有损失的自动数据类型转换。</p>
<blockquote>
<p>如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。</p>
</blockquote>
<p>const a: i32 &#x3D; 123;<br>let a &#x3D; 456;<br>变量的值可以”重新绑定”，但在”重新绑定”以前不能私自被改变，这样可以确保在每一次”绑定”之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：</p>
<p>let a: u64 &#x3D; 123;</p>
<p>这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。</p>
<p>Rust 是静态类型语言，在变量声明时可以显式指定类型，但通常可以依赖类型推断。<br>基本类型: i32 (32位有符号整数), u32 (32位无符号整数), f64 (64位浮点数), bool (布尔类型), char (字符)</p>
<p>函数<br>Rust 函数通过 fn 关键字定义，函数的返回类型通过箭头符号 -&gt; 指定。<br>如果函数没有返回值，类型默认为 ()（即空元组）。</p>
<p>控制流：<br>if </p>
<p>loop 循环<br>Rust中的无限循环，用break跳出</p>
<p>while循环</p>
<p>for 循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">number</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有权（Ownership）<br>Rust中独特的内存管理机制，核心概念包括所有权(ownership)、借用(borrowing)、引用(reference)</p>
<p>所有权规则：<br>每个值都拥有一个所有者。每个值在任意时刻只能有一个所有者。当所有者超出作用域时，值会被删除</p>
<p>let s1 &#x3D; String::from(“hello”);<br>let s2 &#x3D; s1; &#x2F;&#x2F; s1 的所有权被转移给了 s2<br>&#x2F;&#x2F; println!(“{}”, s1); &#x2F;&#x2F; 此处编译会报错，因为 s1 已不再拥有该值</p>
<p>借用和引用 借用允许引用数据而不获取所有权，通过&amp;符合实现<br>fn main() {<br>    let s &#x3D; String::from(“hello”);<br>    let len &#x3D; calculate_length(&amp;s);  &#x2F;&#x2F; 借用<br>    println!(“The length of ‘{}’ is {}.”, s, len);<br>}</p>
<p>fn calculate_length(s: &amp;String) -&gt; usize {<br>    s.len()<br>}</p>
<p>结构体（Structs）<br>结构体用于创建自定义类型，字段可以包含多种数据类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername&quot;</span>),<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    sign_in_count: <span class="hljs-number">1</span>,<br>    active: <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>枚举（Enums）</p>
<p>模式匹配（match）<br>match类似于 switch 语句</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter =&gt; <span class="hljs-number">25</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>错误处理<br>主要两种错误处理方式： Result&lt;T, E&gt; 和 Option<T>.</T></p>
<p>Result:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(a / b)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Option:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_element</span>(index: <span class="hljs-type">usize</span>, vec: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> index &lt; vec.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(vec[index])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有权与借用的生命周期<br>Rust使用声明周期来保证引用的有效性。生命周期标注用’a来表示，但通常由编译器自动推导</p>
<p>重影（shadowing）<br>重影就是所谓的“重新绑定”，指变量的名称可以被重新使用的机制</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段程序的运行结果： the value of x is 12</p>
<p>重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生<strong>值的变化</strong>。</p>
<p>Rust 没有 ** 或 ^ 这样的乘方运算符（注意：^ 是按位异或），如果要做乘方，需要使用内置的 pow 或 powf 方法：<br>整数类型使用 .pow(exp: u32)<br>浮点类型使用 .powf(exp: f64)</p>
<p>其他常见运算符<br>运算符	说明	示例<br>..	范围（不含右端）	0..5 产生 0 到 4<br>..&#x3D;	范围（含右端）	0..&#x3D;5 产生 0 到 5<br>as	类型转换	5 as f32<br>?	错误传播（在 Result 中）	some()?;<br>*	解引用	*ptr<br>&amp;	取引用	&amp;x<br>ref	绑定为引用	let ref y &#x3D; x;</p>
<p>数据类型<br>整数型（Integer）<br>整数型简称整型，按照比特位长度和有无符号分为以下种类：</p>
<p>位长度	有符号	无符号<br>8-bit	i8	u8<br>16-bit	i16	u16<br>32-bit	i32	u32<br>64-bit	i64	u64<br>128-bit	i128	u128<br>arch	isize	usize</p>
<p>整数的表述方法有以下几种：</p>
<p>进制	例<br>十进制	98_222<br>十六进制	0xff<br>八进制	0o77<br>二进制	0b1111_0000<br>字节(只能表示 u8 型)	b’A’<br>很显然，有的整数中间存在一个下划线，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少。</p>
<p>字符型<br>字符型用 char 表示。</p>
<p>Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。</p>
<p>Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，”字符”这个概念并不存在于 Unicode 中，因此您对”字符”是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。</p>
<p>注意：由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。</p>
<p>复合类型<br>元组是用一对 ( ) 包括的一组数据，可以包含不同种类的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// tup.0 等于 500</span><br><span class="hljs-comment">// tup.1 等于 6.4</span><br><span class="hljs-comment">// tup.2 等于 1</span><br><span class="hljs-keyword">let</span> (x, y, z) = tup;<br><span class="hljs-comment">// y 等于 6.4</span><br></code></pre></td></tr></table></figure>
<p>数组用一对 [ ] 包括的同类型数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// a 是一个长度为 5 的整型数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = [<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>];<br><span class="hljs-comment">// b 是一个长度为 3 的字符串数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// c 是一个长度为 5 的 i32 数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 等同于 let d = [3, 3, 3, 3, 3];</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 数组访问</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>; <span class="hljs-comment">// 错误：数组 a 不可变</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>

<p>Rust 函数的基本形式：</p>
<p>fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;<br>其中 Rust 函数名称的命名风格是小写字母以下划线分割：</p>
<p>函数体的语句和表达式<br>Rust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成。<br>语句是执行某些操作且没有返回值的步骤。<br>表达式有计算步骤且有返回值。<br>很显然，这段程序中包含了一个表达式块：</p>
<p>{<br>    let x &#x3D; 3;<br>    x + 1<br>};<br>而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做函数体表达式。</p>
<p>注意：x + 1 之后没有分号，否则它将变成一条语句！<br>这种表达式块是一个合法的函数体。而且在 Rust 中，函数定义可以嵌套：<br>实例<br>fn main() {<br>    fn five() -&gt; i32 {<br>        5<br>    }<br>    println!(“five() 的值为: {}”, five());<br>}</p>
<p>函数返回值<br>在上一个嵌套的例子中已经显示了 Rust 函数声明返回值类型的方式：在参数声明之后用 -&gt; 来声明函数返回值的类型（不是 : ）。<br>在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。<br>但是 Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是”纯过程”，不允许产生返回值，return 后面不能有返回值表达式。这样做的目的是为了让公开的函数能够形成可见的公报。</p>
<p>注意：函数体表达式并不能等同于函数体，它不能使用 return 关键字。</p>
<p>条件语句</p>
<p>在 Rust 中我们可以使用 if-else 结构实现类似于三元条件运算表达式 (A ? B : C) 的效果：</p>
<p>Rust 迭代器<br>Rust 中的迭代器（Iterator）是一个强大且灵活的工具，用于对集合（如数组、向量、链表等）进行逐步访问和操作。</p>
<p>Rust 的迭代器是惰性求值的，这意味着迭代器本身不会立即执行操作，而是在你需要时才会产生值。</p>
<p>迭代器允许你以一种声明式的方式来遍历序列，如数组、切片、链表等集合类型的元素。</p>
<p>迭代器背后的核心思想是将数据处理过程与数据本身分离，使代码更清晰、更易读、更易维护。</p>
<p>在 Rust 中，迭代器通过实现 Iterator trait 来定义。</p>
<p>最基本的 trait 方法是 next，用于逐一返回迭代器中的下一个元素，直到返回 None 表示结束。</p>
<p>实例<br>pub trait Iterator {<br>    type Item;</p>
<pre><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

// 其他默认实现的方法如 map, filter 等。
</code></pre>
<p>}<br>迭代器遵循以下原则：</p>
<p>惰性求值 (Laziness)：Rust 中的迭代器是惰性的，意味着迭代器本身不会立即进行任何计算或操作，直到你显式地请求数据。这使得迭代器在性能上表现良好，可以避免不必要的计算。</p>
<p>所有权和借用检查 (Ownership and Borrowing Checks)：Rust 迭代器严格遵守所有权和借用规则，避免数据竞争和内存错误。迭代器的生命周期与底层数据相关联，确保数据的安全访问。</p>
<p>链式调用 (Chaining)：Rust 迭代器支持链式调用，即可以将多个迭代器方法链接在一起进行组合操作，这使得代码简洁且具有高度可读性。例如，通过使用 .map()、.filter()、.collect() 等方法，可以创建复杂的数据处理流水线。</p>
<p>高效内存管理 (Efficient Memory Management)：迭代器避免了不必要的内存分配，因为大多数操作都是惰性求值的，并且在使用时直接进行遍历操作。这对于处理大数据集合尤其重要。</p>
<p>抽象和通用性 (Abstraction and Generality)：Rust 的迭代器通过 Iterator trait 实现抽象和通用性。任何实现了 Iterator trait 的类型都可以在不同的上下文中作为迭代器使用。此设计提高了代码的重用性和模块化。</p>
<p>Rust迭代器<br>创建迭代器<br>最常见的方式是通过集合的 .iter()、.iter_mut() 或 .into_iter() 方法来创建迭代器：</p>
<p>.iter()：返回集合的不可变引用迭代器。<br>.iter_mut()：返回集合的可变引用迭代器。<br>.into_iter()：将集合转移所有权并生成值迭代器。<br>使用 iter() 方法创建借用迭代器：</p>
<p>let vec &#x3D; vec![1, 2, 3, 4, 5];<br>let iter &#x3D; vec.iter();<br>使用 iter_mut() 方法创建可变借用迭代器：</p>
<p>let mut vec &#x3D; vec![1, 2, 3, 4, 5];<br>let iter_mut &#x3D; vec.iter_mut();<br>使用 into_iter() 方法创建获取所有权的迭代器：</p>
<p>let vec &#x3D; vec![1, 2, 3, 4, 5];<br>let into_iter &#x3D; vec.into_iter();</p>
<p>迭代器方法<br>Rust 的迭代器提供了丰富的方法来处理集合中的元素，其中一些常见的方法包括：</p>
<p>map()：对每个元素应用给定的转换函数。<br>filter()：根据给定的条件过滤集合中的元素。<br>fold()：对集合中的元素进行累积处理。<br>skip()：跳过指定数量的元素。<br>take()：获取指定数量的元素。<br>enumerate()：为每个元素提供索引。<br>……</p>
<p>消耗型适配器<br>使用迭代器直到它被完全消耗。</p>
<p>迭代器有许多可以消耗迭代器的方法，它们会通过执行迭代来返回最终结果（比如总和、集合等），这些方法会消耗迭代器本身。</p>
<p>collect()：将迭代器转换为集合（如向量、哈希集）。<br>sum()：计算迭代器中所有元素的和。<br>product()：计算迭代器中所有元素的乘积。<br>count()：返回迭代器中元素的个数。</p>
<p>适配器<br>迭代器适配器允许你通过方法链来改变或过滤迭代器的内容，而不会立刻消耗它。</p>
<p>map()：对每个元素应用某个函数，并返回一个新的迭代器。<br>filter()：过滤出满足条件的元素。<br>take(n)：只返回前 n 个元素的迭代器。<br>skip(n)：跳过前 n 个元素，返回剩下的元素迭代器。</p>
<p>Rust 迭代器方法<br>以下是一些 Rust 中常用的迭代器方法，以及它们的简要说明和示例：</p>
<p>方法名	描述	示例<br>next()	返回迭代器中的下一个元素。	let mut iter &#x3D; (1..5).into_iter(); while let Some(val) &#x3D; iter.next() { println!(“{}”, val); }<br>size_hint()	返回迭代器中剩余元素数量的下界和上界。	let iter &#x3D; (1..10).into_iter(); println!(“{:?}”, iter.size_hint());<br>count()	计算迭代器中的元素数量。	let count &#x3D; (1..10).into_iter().count();<br>nth()	返回迭代器中第 n 个元素。	let third &#x3D; (0..10).into_iter().nth(2);<br>last()	返回迭代器中的最后一个元素。	let last &#x3D; (1..5).into_iter().last();<br>all()	如果迭代器中的所有元素都满足某个条件，返回 true。	let all_positive &#x3D; (1..&#x3D;5).into_iter().all(|x| x &gt; 0);<br>any()	如果迭代器中的至少一个元素满足某个条件，返回 true。	let any_negative &#x3D; (1..5).into_iter().any(|x| x &lt; 0);<br>find()	返回迭代器中第一个满足某个条件的元素。	let first_even &#x3D; (1..10).into_iter().find(|x| x % 2 &#x3D;&#x3D; 0);<br>find_map()	对迭代器中的元素应用一个函数，返回第一个返回 Some 的结果。	let first_letter &#x3D; “hello”.chars().find_map(|c| if c.is_alphabetic() { Some(c) } else { None });<br>map()	对迭代器中的每个元素应用一个函数。	let squares: Vec<i32> &#x3D; (1..5).into_iter().map(|x| x * x).collect();<br>filter()	保留迭代器中满足某个条件的元素。	let evens: Vec<i32> &#x3D; (1..10).into_iter().filter(|x| x % 2 &#x3D;&#x3D; 0).collect();<br>filter_map()	对迭代器中的元素应用一个函数，如果函数返回 Some，则保留结果。	let chars: Vec<char> &#x3D; “hello”.chars().filter_map(|c| if c.is_alphabetic() { Some(c.to_ascii_uppercase()) } else { None }).collect();<br>map_while()	对迭代器中的元素应用一个函数，直到函数返回 None。	let first_three &#x3D; (1..).into_iter().map_while(|x| if x &lt;&#x3D; 3 { Some(x) } else { None });<br>take_while()	从迭代器中取出满足某个条件的元素，直到不满足为止。	let first_five &#x3D; (1..10).into_iter().take_while(|x| x &lt;&#x3D; 5).collect::&lt;Vec&lt;_&gt;&gt;()<br>skip_while()	跳过迭代器中满足某个条件的元素，直到不满足为止。	let odds: Vec<i32> &#x3D; (1..10).into_iter().skip_while(|x| x % 2 &#x3D;&#x3D; 0).collect();<br>for_each()	对迭代器中的每个元素执行某种操作。	let mut counter &#x3D; 0; (1..5).into_iter().for_each(|x| counter +&#x3D; x);<br>fold()	对迭代器中的元素进行折叠，使用一个累加器。	let sum: i32 &#x3D; (1..5).into_iter().fold(0, |acc, x| acc + x);<br>try_fold()	对迭代器中的元素进行折叠，可能在遇到错误时提前返回。	let result: Result &#x3D; (1..5).into_iter().try_fold(0, |acc, x| if x &#x3D;&#x3D; 3 { Err(“Found the number 3”) } else { Ok(acc + x) });<br>scan()	对迭代器中的元素进行状态化的折叠。	let sum: Vec<i32> &#x3D; (1..5).into_iter().scan(0, |acc, x| { *acc +&#x3D; x; Some(*acc) }).collect();<br>take()	从迭代器中取出最多 n 个元素。	let first_five &#x3D; (1..10).into_iter().take(5).collect::&lt;Vec&lt;_&gt;&gt;()<br>skip()	跳过迭代器中的前 n 个元素。	let after_five &#x3D; (1..10).into_iter().skip(5).collect::&lt;Vec&lt;_&gt;&gt;()<br>zip()	将两个迭代器中的元素打包成元组。	let zipped &#x3D; (1..3).zip(&amp;[‘a’, ‘b’, ‘c’]).collect::&lt;Vec&lt;_&gt;&gt;()<br>cycle()	重复迭代器中的元素，直到无穷。	let repeated &#x3D; (1..3).into_iter().cycle().take(7).collect::&lt;Vec&lt;_&gt;&gt;()<br>chain()	连接多个迭代器。	let combined &#x3D; (1..3).chain(4..6).collect::&lt;Vec&lt;_&gt;&gt;()<br>rev()	反转迭代器中的元素顺序。	let reversed &#x3D; (1..4).into_iter().rev().collect::&lt;Vec&lt;_&gt;&gt;()<br>enumerate()	为迭代器中的每个元素添加索引。	let enumerated &#x3D; (1..4).into_iter().enumerate().collect::&lt;Vec&lt;_&gt;&gt;()<br>peeking_take_while()	取出满足条件的元素，同时保留迭代器的状态，可以继续取出后续元素。	let (first, rest) &#x3D; (1..10).into_iter().peeking_take_while(|&amp;x| x &lt; 5);<br>step_by()	按照指定的步长返回迭代器中的元素。	let even_numbers &#x3D; (0..10).into_iter().step_by(2).collect::&lt;Vec&lt;_&gt;&gt;()<br>fuse()	创建一个额外的迭代器，它在迭代器耗尽后仍然可以调用 next() 方法。	let mut iter &#x3D; (1..5).into_iter().fuse(); while iter.next().is_some() {}<br>inspect()	在取出每个元素时执行一个闭包，但不改变元素。	let mut counter &#x3D; 0; (1..5).into_iter().inspect(|x| println!(“Inspecting: {}”, x)).for_each(|x| println!(“Processing: {}”, x));<br>same_items()	比较两个迭代器是否产生相同的元素序列。	let equal &#x3D; (1..5).into_iter().same_items((1..5).into_iter());</i32></i32></char></i32></i32></p>
<p>Rust 中的闭包是一种匿名函数，它们可以捕获并存储其环境中的变量。</p>
<p>闭包允许在其定义的作用域之外访问变量，并且可以在需要时将其移动或借用给闭包。</p>
<p>闭包在 Rust 中被广泛应用于函数式编程、并发编程和事件驱动编程等领域。</p>
<p>闭包在 Rust 中非常有用，因为它们提供了一种简洁的方式来编写和使用函数。</p>
<p>闭包在 Rust 中非常灵活，可以存储在变量中、作为参数传递，甚至作为返回值。</p>
<p>闭包通常用于需要短小的自定义逻辑的场景，例如迭代器、回调函数等。</p>
<p>闭包与函数的区别<br>特性	闭包	函数<br>匿名性	是匿名的，可存储为变量	有固定名称<br>环境捕获	可以捕获外部变量	不能捕获外部变量<br>定义方式	&#96;	参数<br>类型推导	参数和返回值类型可以推导	必须显式指定<br>存储与传递	可以作为变量、参数、返回值	同样支持<br>以下是 Rust 闭包的一些关键特性和用法：</p>
<p>闭包的声明<br>闭包的语法声明：</p>
<p>let closure_name &#x3D; |参数列表| 表达式或语句块;<br>参数可以有类型注解，也可以省略，Rust 编译器会根据上下文推断它们。</p>
<p>let add_one &#x3D; |x: i32| x + 1;<br>闭包的参数和返回值： 闭包可以有零个或多个参数，并且可以返回一个值。</p>
<p>let calculate &#x3D; |a, b, c| a * b + c;<br>闭包的调用：闭包可以像函数一样被调用。</p>
<p>let result &#x3D; calculate(1, 2, 3);<br>匿名函数<br>闭包在 Rust 中类似于匿名函数，可以在代码中以 {} 语法块的形式定义，使用 || 符号来表示参数列表，实例如下：</p>
<p>let add &#x3D; |a, b| a + b;<br>println!(“{}”, add(2, 3)); &#x2F;&#x2F; 输出: 5<br>在这个示例中，add 是一个闭包，接受两个参数 a 和 b，返回它们的和。</p>
<p>捕获外部变量<br>闭包可以捕获周围环境中的变量，这意味着它可以访问定义闭包时所在作用域中的变量。<br>闭包可以通过三种方式捕获外部变量：</p>
<p>按引用捕获（默认行为，类似 &amp;T）<br>按值捕获（类似 T）<br>可变借用捕获（类似 &amp;mut T）<br>闭包默认按引用捕获外部变量。<br>使用 move 关键字可以强制按值捕获，将外部变量的所有权转移到闭包内。<br>如果闭包需要修改外部变量，需显式声明为 mut 闭包。</p>
<p>移动与借用<br>闭包可以通过 move 关键字获取外部变量的所有权，或者通过借用的方式获取外部变量的引用。例如：</p>
<p>借用变量：默认情况下，闭包会借用它捕获的环境中的变量，这意味着闭包可以使用这些变量，但不能改变它们的所有权。这种情况下，闭包和外部作用域都可以使用这些变量。<br>获取所有权：通过在闭包前添加 move 关键字，闭包会获取它捕获的环境变量的所有权。这意味着这些变量的所有权会从外部作用域转移到闭包内部，外部作用域将无法再使用这些变量。</p>
<p>闭包的特性</p>
<ol>
<li><p>闭包可以作为函数参数<br>闭包经常作为参数传递给函数，<br>这里的 Fn 是闭包的一个特性（trait），用于表示闭包可以被调用。</p>
</li>
<li><p>闭包可以作为返回值<br>闭包还可以作为函数的返回值。由于闭包是匿名的，我们需要使用 impl Trait 或 Box 来描述其类型。</p>
</li>
</ol>
<p>使用 impl Fn 返回闭包<br>实例<br>fn make_adder(x: i32) -&gt; impl Fn(i32) -&gt; i32 {<br>    move |y| x + y<br>}</p>
<p>fn main() {<br>    let add_five &#x3D; make_adder(5);<br>    println!(“5 + 3 &#x3D; {}”, add_five(3)); &#x2F;&#x2F; 输出: 5 + 3 &#x3D; 8<br>}<br>使用 Box<dyn fn> 返回闭包<br>实例<br>fn make_adder(x: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {<br>    Box::new(move |y| x + y)<br>}</dyn></p>
<p>fn main() {<br>    let add_ten &#x3D; make_adder(10);<br>    println!(“10 + 2 &#x3D; {}”, add_ten(2)); &#x2F;&#x2F; 输出: 10 + 2 &#x3D; 12<br>}</p>
<ol start="3">
<li>闭包特性（Traits）<br>闭包根据其捕获方式自动实现了以下三个特性：</li>
</ol>
<p>Fn: 不需要修改捕获的变量，闭包可以多次调用。<br>FnMut: 需要修改捕获的变量，闭包可以多次调用。<br>FnOnce: 只需要捕获所有权，闭包只能调用一次。</p>
<p>所有权规则<br>所有权有以下三条规则：</p>
<p>Rust 中的每个值都有一个变量，称为其所有者。<br>一次只能有一个所有者。<br>当所有者不在程序运行范围时，该值将被删除。<br>这三条规则是所有权概念的基础。<br>变量范围<br>我们用下面这段程序描述变量范围的概念：</p>
<p>{<br>    &#x2F;&#x2F; 在声明以前，变量 s 无效<br>    let s &#x3D; “runoob”;<br>    &#x2F;&#x2F; 这里是变量 s 的可用范围<br>}<br>&#x2F;&#x2F; 变量范围已经结束，变量 s 无效<br>变量范围是变量的一个属性，其代表变量的可行域，默认从声明变量开始有效直到变量所在域结束。</p>
<p>内存和分配<br>如果我们定义了一个变量并给它赋予一个值，这个变量的值存在于内存中。这种情况很普遍。但如果我们需要储存的数据长度不确定（比如用户输入的一串字符串），我们就无法在定义时明确数据长度，也就无法在编译阶段令程序分配固定长度的内存空间供数据储存使用。（有人说分配尽可能大的空间可以解决问题，但这个方法很不文明）。这就需要提供一种在程序运行时程序自己申请使用内存的机制——堆。本章所讲的所有”内存资源”都指的是堆所占用的内存空间。</p>
<p>有分配就有释放，程序不能一直占用某个内存资源。因此决定资源是否浪费的关键因素就是资源有没有及时的释放。</p>
<p>我们把字符串样例程序用 C 语言等价编写：</p>
<p>{<br>    char *s &#x3D; strdup(“runoob”);<br>    free(s); &#x2F;&#x2F; 释放 s 资源<br>}<br>很显然，Rust 中没有调用 free 函数来释放字符串 s 的资源（我知道这样在 C 语言中是不正确的写法，因为 “runoob” 不在堆中，这里假设它在）。Rust 之所以没有明示释放的步骤是因为在变量范围结束的时候，Rust 编译器自动添加了调用释放资源函数的步骤。</p>
<p>这种机制看似很简单了：它不过是帮助程序员在适当的地方添加了一个释放资源的函数调用而已。但这种简单的机制可以有效地解决一个史上最令程序员头疼的编程问题。</p>
<p>变量与数据交互的方式<br>变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：</p>
<p>移动<br>多个变量可以在 Rust 中以不同的方式与相同的数据交互：</p>
<p>let x &#x3D; 5;<br>let y &#x3D; x;<br>这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量 y。现在栈中将有两个值 5。此情况中的数据是”基本数据”类型的数据，不需要存储到堆中，仅在栈中的数据的”移动”方式是直接复制，这不会花费更长的时间或更多的存储空间。”基本数据”类型有这些：</p>
<p>所有整数类型，例如 i32 、 u32 、 i64 等。<br>布尔类型 bool，值为 true 或 false 。<br>所有浮点类型，f32 和 f64。<br>字符类型 char。<br>仅包含以上类型数据的元组（Tuples）。<br>但如果发生交互的数据在堆中就是另外一种情况：</p>
<p>let s1 &#x3D; String::from(“hello”);<br>let s2 &#x3D; s1;<br>第一步产生一个 String 对象，值为 “hello”。其中 “hello” 可以认为是类似于长度不确定的数据，需要在堆中存储。<br>第二步的情况略有不同 两个 String 对象在栈中，每个 String 对象都有一个指针指向堆中的 “hello” 字符串。在给 s2 赋值时，只有栈中的数据被复制了，堆中的字符串依然还是原来的字符串。前面我们说过，当变量超出范围时，Rust 自动调用释放资源函数并清理该变量的堆内存。但是 s1 和 s2 都被释放的话堆区中的 “hello” 被释放两次，这是不被系统允许的。为了确保安全，在给 s2 赋值时 s1 已经无效了。于是 在把 s1 的值赋给 s2 以后 s1 将不可以再被使用。</p>
<p>克隆<br>Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。但如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。</p>
<p>涉及函数的所有权机制<br>函数参数的所有权机制运行原理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);<br>    <span class="hljs-comment">// s 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// x 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);<br>    <span class="hljs-comment">// x 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 但 x 是基本类型，依然有效</span><br>    <span class="hljs-comment">// 在这里依然可以使用 x 却不能使用 s</span><br><br>&#125; <span class="hljs-comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span><br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <br>    <span class="hljs-comment">// 一个 String 参数 some_string 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_string 在这里释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <br>    <span class="hljs-comment">// 一个 i32 参数 some_integer 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span><br></code></pre></td></tr></table></figure>
<p>如果将变量当作参数传入函数，那么它和移动的效果是一样的。</p>
<p>函数返回值的所有权机制</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();<br>    <span class="hljs-comment">// gives_ownership 移动它的返回值到 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s2 被声明有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);<br>    <span class="hljs-comment">// s2 被当作参数移动, s3 获得返回值所有权</span><br>&#125; <span class="hljs-comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// some_string 被声明有效</span><br><br>    <span class="hljs-keyword">return</span> some_string;<br>    <span class="hljs-comment">// some_string 被当作返回值移动出函数</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <br>    <span class="hljs-comment">// a_string 被声明有效</span><br><br>    a_string  <span class="hljs-comment">// a_string 被当作返回值移出函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。</p>
<p><code>&amp;</code> 运算符可以取变量的”引用”。</p>
<p>当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值：<br>引用不会获得值的所有权。</p>
<p>引用只能租借（Borrow）值的所有权。</p>
<p>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;s1;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = s1;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s2</span> = &amp;s1;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = s1;<br>    s2 = &amp;s3; <span class="hljs-comment">// 重新从 s3 租借所有权</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s2);<br>&#125;<br></code></pre></td></tr></table></figure>


<p>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以：</p>
<p>实例<br>let mut s &#x3D; String::from(“hello”);</p>
<p>let r1 &#x3D; &amp;mut s;<br>let r2 &#x3D; &amp;mut s;</p>
<p>println!(“{}, {}”, r1, r2);<br>这段程序不正确，因为多重可变引用了 s。</p>
<p>Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。</p>
<p>由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</p>
<p>垂悬引用（Dangling References）<br>这是一个换了个名字的概念，如果放在有指针概念的编程语言里它就指的是那种没有实际指向一个真正能访问的数据的指针（注意，不一定是空指针，还有可能是已经释放的资源）。它们就像失去悬挂物体的绳子，所以叫”垂悬引用”。</p>
<p>“垂悬引用”在 Rust 语言里不允许出现，如果有，编译器会发现它。</p>
<p>下面是一个垂悬的典型案例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很显然，伴随着 dangle 函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回，这个引用所指向的值已经不能确定的存在，故不允许其出现。</p>
<p>Rust Slice（切片）类型<br>切片（Slice）是对数据值的部分引用。</p>
<p>字符串切片<br>最简单、最常用的数据切片类型是字符串切片（String Slice）。</p>
<p>使用 .. 表示范围的语法在循环章节中出现过。x..y 表示 [x, y) 的数学含义。.. 两边可以没有运算数：</p>
<p>..y 等价于 0..y<br>x.. 等价于位置 x 到数据结束<br>.. 等价于位置 0 到结束<br>注意：到目前为止，尽量不要在字符串中使用非英文字符，因为编码的问题。具体原因会在”字符串”章节叙述。</p>
<p>被切片引用的字符串禁止更改其值：</p>
<p>到目前为止你一定疑惑为什么每一次使用字符串都要这样写String::from(“runoob”) ，直接写 “runoob” 不行吗？</p>
<p>事已至此我们必须分辨这两者概念的区别了。在 Rust 中有两种常用的字符串类型：str 和 String。str 是 Rust 核心语言类型，就是本章一直在讲的字符串切片（String Slice），常常以引用的形式出现（&amp;str）。</p>
<p>凡是用双引号包括的字符串常量整体的类型性质都是 &amp;str：</p>
<p>let s &#x3D; “hello”;<br>这里的 s 就是一个 &amp;str 类型的变量。</p>
<p>String 类型是 Rust 标准公共库提供的一种数据类型，它的功能更完善——它支持字符串的追加、清空等实用的操作。String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性。</p>
<p>String 和 str 都支持切片，切片的结果是 &amp;str 类型的数据。</p>
<p>注意：切片结果必须是引用类型，但开发者必须自己明示这一点:</p>
<p>let slice &#x3D; &amp;s[0..3];<br>有一个快速的办法可以将 String 转换成 &amp;str：</p>
<p>let s1 &#x3D; String::from(“hello”);<br>let s2 &#x3D; &amp;s1[..];</p>
<p>非字符串切片<br>除了字符串以外，其他一些线性数据结构也支持切片操作，例如数组：</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/09/10/Golang/go-context/">← Next Go context</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/09/05/Golang/pkg-http/">Go-HTTP Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>