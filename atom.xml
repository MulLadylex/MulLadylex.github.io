<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="https://mulladylex.github.io/project/atom.xml" rel="self"/>
  
  <link href="https://mulladylex.github.io/project/"/>
  <updated>2025-09-27T04:31:09.322Z</updated>
  <id>https://mulladylex.github.io/project/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCC</title>
    <link href="https://mulladylex.github.io/project/2025/09/27/c-tool/"/>
    <id>https://mulladylex.github.io/project/2025/09/27/c-tool/</id>
    <published>2025-09-27T04:27:13.000Z</published>
    <updated>2025-09-27T04:31:09.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Windows-上安装和配置-GCC（MinGW-w64）"><a href="#在-Windows-上安装和配置-GCC（MinGW-w64）" class="headerlink" title="在 Windows 上安装和配置 GCC（MinGW-w64）"></a>在 Windows 上安装和配置 GCC（MinGW-w64）</h1><h2 id="1️⃣-安装-MinGW-w64（推荐）"><a href="#1️⃣-安装-MinGW-w64（推荐）" class="headerlink" title="1️⃣ 安装 MinGW-w64（推荐）"></a>1️⃣ 安装 MinGW-w64（推荐）</h2><ol><li><p>下载 MSYS2：<br><a href="https://www.msys2.org/">https://www.msys2.org/</a></p></li><li><p>安装 MSYS2 后，打开 <strong>MSYS2 MinGW 64-bit 终端</strong></p></li><li><p>安装 GCC：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syu                  <span class="hljs-comment"># 更新系统</span><br>pacman -S mingw-w64-x86_64-gcc<br></code></pre></td></tr></table></figure><p>也可以单独安装 TDM-GCC，但 MSYS2 更容易管理依赖库。</p><h2 id="2️⃣-配置环境变量"><a href="#2️⃣-配置环境变量" class="headerlink" title="2️⃣ 配置环境变量"></a>2️⃣ 配置环境变量</h2><p>把 GCC 可执行文件路径加入 %PATH%，比如 MSYS2 默认路径：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">C:\msys64\mingw64\bin</span><br></code></pre></td></tr></table></figure><p>在 CMD 或 PowerShell 中测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br></code></pre></td></tr></table></figure><p>如果显示版本号，则表示安装成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在-Windows-上安装和配置-GCC（MinGW-w64）&quot;&gt;&lt;a href=&quot;#在-Windows-上安装和配置-GCC（MinGW-w64）&quot; class=&quot;headerlink&quot; title=&quot;在 Windows 上安装和配置 GCC（MinGW-w64</summary>
      
    
    
    
    
    <category term="tool" scheme="https://mulladylex.github.io/project/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>A-ER</title>
    <link href="https://mulladylex.github.io/project/2025/09/24/A-ER/"/>
    <id>https://mulladylex.github.io/project/2025/09/24/A-ER/</id>
    <published>2025-09-24T05:05:48.000Z</published>
    <updated>2025-09-24T05:06:38.814Z</updated>
    
    <content type="html"><![CDATA[<!-- TODO 数学公式的插入 --><h1 id="指数退避"><a href="#指数退避" class="headerlink" title="指数退避"></a>指数退避</h1><p>指数退避是一种通过反馈，成倍地降低某个过程的速率，以逐渐找到合适速率的算法。</p><p>最初用于以太网中，用于解决在共享媒介上进行的数据传输过程中可能出现的冲突和拥塞问题，该算法的核心思想是在发生通信错误时，通过等待一段时间后进行重试，以避免连续的冲突。重试的时间间隔随着重试次数的增加呈指数级增长，从而使得网络资源能够更加合理地分配。</p><p>在 c 次碰撞后（比如请求失败），会选择 0 和 2c - 1之间的随机值作为时隙的数量。</p><p>对于第 1 次碰撞来说，每个发送者将会等待 0 或 1 个时隙进行发送。<br>而在第 2 次碰撞后，发送者将会等待 0 到 3（ 由 计算得到）个时隙进行发送。<br>而在第 3 次碰撞后，发送者将会等待 0 到 7（ 由 计算得到）个时隙进行发送。<br>以此类推……<br>随着重传次数的增加，延迟的程度也会指数增长。</p><p>说的通俗点，每次重试的时间间隔都是上一次的两倍。</p><h2 id="指数退避的期望值"><a href="#指数退避的期望值" class="headerlink" title="指数退避的期望值"></a>指数退避的期望值</h2><p>考虑到退避时间的均匀分布，退避时间的数学期望是所有可能性的平均值。也就是说，在 c 次冲突之后，退避时隙数量在 [0,1，…，N] 中，其中 公式  ，则退避时间的数学期望（以时隙为单位）是</p><p>公式：</p><p>那么对于前面讲到的例子来说：</p><p>如果请求失败，请等待 1 +<code>random_number_milliseconds</code>秒后再重试请求。<br>如果请求失败，请等待 2 +<code>random_number_milliseconds</code>秒后再重试请求。<br>如果请求失败，请等待 4 +<code>random_number_milliseconds</code>秒后再重试请求。<br>依此类推，等待时间上限为<code>maximum_backoff</code>。</p><p><strong>等待时间</strong>达到上限后，您可以继续等待并重试，直到达到<strong>重试次数</strong>上限（但接下来的重试操作不会增加各次重试之间的等待时间）。</p><p>达到 maximum_backoff 时间后，您可以继续重试。 此后执行的重试不需要继续增加退避时间。例如，如果客户端使用的 maximum_backoff 时间为 64 秒，则在达到此值后，客户端可以每 64 秒重试一次。在某个时刻，应阻止客户端无限重试。</p><h2 id="指数退避的应用"><a href="#指数退避的应用" class="headerlink" title="指数退避的应用"></a>指数退避的应用</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TODO 数学公式的插入 --&gt;
&lt;h1 id=&quot;指数退避&quot;&gt;&lt;a href=&quot;#指数退避&quot; class=&quot;headerlink&quot; title=&quot;指数退避&quot;&gt;&lt;/a&gt;指数退避&lt;/h1&gt;&lt;p&gt;指数退避是一种通过反馈，成倍地降低某个过程的速率，以逐渐找到合适速率的算法。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cex-TA</title>
    <link href="https://mulladylex.github.io/project/2025/09/24/cex-TA/"/>
    <id>https://mulladylex.github.io/project/2025/09/24/cex-TA/</id>
    <published>2025-09-24T05:01:52.000Z</published>
    <updated>2025-09-24T05:02:23.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是技术分析？"><a href="#什么是技术分析？" class="headerlink" title="什么是技术分析？"></a>什么是技术分析？</h1><p>技术分析是通过研究市场数据（价格、成交量和交易情况等技术指标），绘制K线走势图来预测商品价格趋势的分析手法。</p><p>技术分析主要关注在价格走势和交易量的变化，不考虑公司财务数据和市场环境等因素。使用<strong>K线图、柱状图</strong>和趋势线、支撑线、压力线等图表来分析价格走势。</p><h2 id="技术分析原理"><a href="#技术分析原理" class="headerlink" title="技术分析原理"></a>技术分析原理</h2><p>技术分析的核心原理是市场行为反映一切。基于历史价格和成交量数据，技术分析师认为可以预测未来价格走势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是技术分析？&quot;&gt;&lt;a href=&quot;#什么是技术分析？&quot; class=&quot;headerlink&quot; title=&quot;什么是技术分析？&quot;&gt;&lt;/a&gt;什么是技术分析？&lt;/h1&gt;&lt;p&gt;技术分析是通过研究市场数据（价格、成交量和交易情况等技术指标），绘制K线走势图来预测商品价格</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Systemed Service</title>
    <link href="https://mulladylex.github.io/project/2025/09/16/systemed-Service/"/>
    <id>https://mulladylex.github.io/project/2025/09/16/systemed-Service/</id>
    <published>2025-09-15T16:52:40.000Z</published>
    <updated>2025-09-15T17:00:58.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-systemd-管理自定义服务"><a href="#使用-systemd-管理自定义服务" class="headerlink" title="使用 systemd 管理自定义服务"></a>使用 systemd 管理自定义服务</h1><p>本文介绍如何在 <strong>systemd</strong> 下创建并管理自定义服务（以 myapp 为例）。</p><h2 id="systemd-的优势"><a href="#systemd-的优势" class="headerlink" title="systemd 的优势"></a>systemd 的优势</h2><p>在 service 文件里只需写 <strong>前台运行</strong> 的命令，systemd 会自动完成：</p><ul><li>后台守护（无需自己写<code>&amp;</code>或<code>nohup</code>）；</li><li>管理标准输出&#x2F;错误输出（日志可通过<code>journalctl</code>查看）；</li><li>自动重启（通过<code>Restart=always</code>）；</li><li>创建 PID 并跟踪进程状态。</li></ul><h2 id="新建-Service-文件"><a href="#新建-Service-文件" class="headerlink" title="新建 Service 文件"></a>新建 Service 文件</h2><p>在<code>/etc/systemd/system/</code>目录下新建<code>myapp.service</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=MyApp Service<br>After=network.target<br><br>[Service]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行用户和用户组（可选）</span><br>User=myuser<br>Group=myuser<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">程序启动命令</span><br>ExecStart=/usr/bin/java -jar /opt/myapp/myapp.jar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是可执行文件（如 /opt/myapp/myapp），直接写完整路径即可</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果有多个环境变量，可集中写入文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">EnvironmentFile=/etc/myapp.env</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">工作目录（可选）</span><br>WorkingDirectory=/opt/myapp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进程退出后的重启策略</span><br>Restart=always<br>RestartSec=5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">单个环境变量（可选）</span><br>Environment=SPRING_PROFILES_ACTIVE=prod<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>保存退出后，执行以下步骤：</p><h3 id="重新加载-systemd-配置"><a href="#重新加载-systemd-配置" class="headerlink" title="重新加载 systemd 配置"></a>重新加载 systemd 配置</h3><p><code>sudo systemctl daemon-reload</code></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>sudo systemctl start myapp.service</code></p><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p><code>sudo systemctl enable myapp.service</code></p><h3 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h3><p><code>systemctl status myapp.service</code></p><h3 id="停止-重启服务"><a href="#停止-重启服务" class="headerlink" title="停止&#x2F;重启服务"></a>停止&#x2F;重启服务</h3><p><code>sudo systemctl stop myapp.service</code><br><code>sudo systemctl restart myapp.service</code></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>systemd 会自动收集日志，可用 journalctl 查看：</p><p><code>journalctl -u myapp.service -f</code></p><p>-f 参数表示实时跟随日志输出。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>权限问题：</li></ol><p>确保 User&#x2F;Group 存在，并有权限访问相关文件。</p><ol start="2"><li>环境变量问题：</li></ol><p>若环境变量过多，推荐放到 &#x2F;etc&#x2F;myapp.env 并通过 EnvironmentFile 引入。</p><ol start="3"><li>服务未启动成功：</li></ol><p>使用 journalctl -xe 或 journalctl -u myapp.service 排查详细错误。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li><p>Java 应用（Spring Boot &#x2F; JAR 包）；</p></li><li><p>Go &#x2F; Rust &#x2F; C++ 编译后的二进制文件；</p></li><li><p>Python 脚本（需指定解释器路径）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-systemd-管理自定义服务&quot;&gt;&lt;a href=&quot;#使用-systemd-管理自定义服务&quot; class=&quot;headerlink&quot; title=&quot;使用 systemd 管理自定义服务&quot;&gt;&lt;/a&gt;使用 systemd 管理自定义服务&lt;/h1&gt;&lt;p&gt;本文介绍如何</summary>
      
    
    
    
    <category term="Linux" scheme="https://mulladylex.github.io/project/categories/Linux/"/>
    
    
    <category term="Linux服务管理" scheme="https://mulladylex.github.io/project/tags/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
    <category term="开机自启" scheme="https://mulladylex.github.io/project/tags/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"/>
    
    <category term="日志管理" scheme="https://mulladylex.github.io/project/tags/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    
    <category term="后台守护" scheme="https://mulladylex.github.io/project/tags/%E5%90%8E%E5%8F%B0%E5%AE%88%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>windows文件共享</title>
    <link href="https://mulladylex.github.io/project/2025/09/11/windows-share/"/>
    <id>https://mulladylex.github.io/project/2025/09/11/windows-share/</id>
    <published>2025-09-11T14:53:02.000Z</published>
    <updated>2025-09-12T15:32:11.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局域网下的文件传输"><a href="#局域网下的文件传输" class="headerlink" title="局域网下的文件传输"></a>局域网下的文件传输</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>局域网内两台电脑传输文件使用windows自带的文件共享机制即可，不需要找专门的文件传输软件，下面来介绍使用方法。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>在 Windows 网络与Internet 设置中，开启网络发现。</p><blockquote><p>具体可能位于网络和共享中心的高级共享设置</p></blockquote></li><li><p>更改网络配置如下：<br>所有网络中的文件共享连接为：使用128位加密帮助保护文件共享链接</p><p>密码保护的共享：无密码保护的共享</p></li><li><p>设置共享文件夹<br>在文件夹属性中开启共享，并在网络访问中添加 Everyone 用户。</p><p>同时在高级共享中，勾选共享此文件夹并应用确定。</p></li><li><p>在其他电脑上访问自己的文件夹，通常通过<code>\\IP</code>来实现<br>如此就可以正常访问你设置的共享文件夹了。</p></li></ol><blockquote><p>常见问题：</p><blockquote><p>进行链接访问时，如果出现连接失败的情况，可以检查一下Microsoft网络客户端是否开启，如果未开启，则需开启它。</p><p>位于当前连接网络的网络属性中的网络选项下。</p><p>当然你可以为自己设计一个用户并且为分享的文件夹设置针对用户的读写权限。这样就会更安全。</p></blockquote><blockquote><p>如果出现权限不够的问题，首先排查文件夹对用户的读写权限，确认放开后，再检查高级共享设置中对共享文件夹的设置。</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;局域网下的文件传输&quot;&gt;&lt;a href=&quot;#局域网下的文件传输&quot; class=&quot;headerlink&quot; title=&quot;局域网下的文件传输&quot;&gt;&lt;/a&gt;局域网下的文件传输&lt;/h1&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ssh</title>
    <link href="https://mulladylex.github.io/project/2025/09/10/ssh/"/>
    <id>https://mulladylex.github.io/project/2025/09/10/ssh/</id>
    <published>2025-09-10T04:15:01.000Z</published>
    <updated>2025-09-10T06:02:14.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>ssh (Secure Shell) 是一种用于安全远程登录和其他网络服务的协议。它通过加密连接来保护数据传输，确保通信的机密性和完整性。SSH 广泛用于系统管理员和开发人员，以便安全地访问远程服务器和执行命令。</p><h2 id="1-SSH的基本概念"><a href="#1-SSH的基本概念" class="headerlink" title="1. SSH的基本概念"></a>1. SSH的基本概念</h2><h3 id="1-1-公钥和私钥"><a href="#1-1-公钥和私钥" class="headerlink" title="1.1 公钥和私钥"></a>1.1 公钥和私钥</h3><p>SSH 使用公钥加密技术来实现安全认证。每个用户都有一对密钥：公钥和私钥。公钥可以公开分享，而私钥必须保密。<br>当用户尝试连接到远程服务器时，服务器会使用用户的公钥来验证用户的身份。如果验证成功，用户就可以访问服务器。</p><h3 id="1-2-SSH协议"><a href="#1-2-SSH协议" class="headerlink" title="1.2 SSH协议"></a>1.2 SSH协议</h3><p>SSH 协议有两个主要版本：SSH-1 和 SSH-2。SSH-2 是当前的标准版本，提供了更强的安全性和功能。</p><h3 id="1-3-SSH客户端和服务器"><a href="#1-3-SSH客户端和服务器" class="headerlink" title="1.3 SSH客户端和服务器"></a>1.3 SSH客户端和服务器</h3><p>SSH 由两个主要组件组成：SSH 客户端和 SSH 服务器。SSH 客户端用于发起连接，而 SSH 服务器则在远程<br>服务器上运行，等待客户端的连接请求。</p><h2 id="2-SSH的安装与配置"><a href="#2-SSH的安装与配置" class="headerlink" title="2. SSH的安装与配置"></a>2. SSH的安装与配置</h2><p>在大多数 Linux 发行版中，SSH 客户端通常预装。当你尝试通过ssh命令连接到远程服务器时，如果出现<code>Connection refused</code>的情况，说明客户端能找到服务器，但服务器没有运行SSH服务。这时就需要检测服务器端的SSH服务是否安装并启动了。</p><blockquote><p>当然，第一步是要确认<strong>IP地址正确</strong>噢！！！</p></blockquote><p><code>sudo systemctl status ssh</code></p><p>如果显示 inactive(dead) 或者 not found ，说明服务未启动或未安装。</p><blockquote><p>解决方式：<br><code>sudo apt update</code><br><code>sudo apt install openssh-server -y</code><br><code>sudo systemctl enable ssh</code><br><code>sudo systemctl start ssh</code></p></blockquote><p>如果服务启用中，那么需要检测防火墙设置和ssh端口设置：</p><ol><li><p>防火墙是否拦截：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw status<br></code></pre></td></tr></table></figure><p>如果看到<code> 22/tcp DENY</code>，说明防火墙拦截了22端口，需要放行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw allow 22/tcp<br>sudo ufw reload<br></code></pre></td></tr></table></figure></li><li><p>ssh端口是否被修改：<br>如果服务器中的sshd配置修改过，需要查看<code>/etc/ssh/sshd_config</code>文件中的Port配置项，确认端口号。</p></li></ol><p>如果没有，可以使用包管理器安装。例如，在 Debian&#x2F;Ubuntu 上，可以使用以下命令安装 OpenSSH 客户端：</p><h3 id="2-1-安装SSH"><a href="#2-1-安装SSH" class="headerlink" title="2.1 安装SSH"></a>2.1 安装SSH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install openssh-client<br></code></pre></td></tr></table></figure><p>要安装 SSH 服务器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install openssh-server<br></code></pre></td></tr></table></figure><h3 id="2-2-配置SSH"><a href="#2-2-配置SSH" class="headerlink" title="2.2 配置SSH"></a>2.2 配置SSH</h3><p>SSH 服务器的配置文件通常位于 <code>/etc/ssh/sshd_config</code>。<br>可以使用文本编辑器（如 <code>nano</code> 或 <code>vim</code>）编辑该文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>常见的配置选项包括：</p><ul><li>Port：指定 SSH 服务器监听的端口，默认是 22。</li><li>PermitRootLogin：控制是否允许 root 用户通过 SSH 登录。</li><li>PasswordAuthentication：启用或禁用基于密码的认证。</li><li>PubkeyAuthentication：启用或禁用基于公钥的认证。</li><li>AllowUsers：指定允许通过 SSH 登录的用户列表。</li><li>MaxAuthTries：设置允许的最大认证尝试次数。</li><li>ClientAliveInterval 和 ClientAliveCountMax：配置客户端保持连接的心跳机制。</li><li>LogLevel：设置日志记录的详细程度。</li><li>Banner：指定登录时显示的欢迎信息文件路径。</li></ul><p>编辑完成后，保存文件并重启 SSH 服务以应用更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart ssh<br></code></pre></td></tr></table></figure><h2 id="3-使用SSH进行远程连接"><a href="#3-使用SSH进行远程连接" class="headerlink" title="3. 使用SSH进行远程连接"></a>3. 使用SSH进行远程连接</h2><h3 id="3-1-基本连接"><a href="#3-1-基本连接" class="headerlink" title="3.1 基本连接"></a>3.1 基本连接</h3><p>要使用 SSH 连接到远程服务器，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh username@hostname<br></code></pre></td></tr></table></figure><p>其中，<code>username</code> 是远程服务器上的用户名，<code>hostname</code> 是服务器的 IP 地址或域名。<br>如果需要指定端口，可以使用 <code>-p</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -p port_number username@hostname<br></code></pre></td></tr></table></figure><p>连接时，系统会提示输入密码。如果是第一次连接，系统会询问是否信任该主机，输入 <code>yes</code> 以继续。</p><h3 id="3-2-使用密钥认证"><a href="#3-2-使用密钥认证" class="headerlink" title="3.2 使用密钥认证"></a>3.2 使用密钥认证</h3><p>常见问题：</p><p>SSH 无法通过 22 端口连接到 GitHub</p><p>通常是由于网络环境限制：国内网络访问端口被阻断；所在网络环境屏蔽端口等</p><p>GitHub 提供了一个专门的 <strong>443</strong> 端口（一个HTTPS伪装的SSH），可以绕过网络屏蔽。</p><p>你可以通过执行<code>ssh -T -p 443 git@github.com</code>验证是否是网络问题导致。</p><p>如果成功，会提示：<br><code>Hi &lt;username&gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><p>因此最好的解决办法就是配置 <code>.ssh/config</code> 文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github.com<br>  HostName ssh.github.com<br>  Port 443<br>  User git<br></code></pre></td></tr></table></figure><p>这样的话每当你使用 ssh 命令时就会自动走指定的端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h1&gt;&lt;p&gt;ssh (Secure Shell) 是一种用于安全远程登录和其他网络服务的协议。它通过加密连接来保护数据传输，确保通信的机密性和完</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go context</title>
    <link href="https://mulladylex.github.io/project/2025/09/10/Golang/go-context/"/>
    <id>https://mulladylex.github.io/project/2025/09/10/Golang/go-context/</id>
    <published>2025-09-10T02:26:22.000Z</published>
    <updated>2025-09-10T06:53:54.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解Context"><a href="#了解Context" class="headerlink" title="了解Context"></a>了解Context</h1><p>控制并发的方法：<code>WaitGroup</code>、<code>context</code><br><code>WaitGroup</code>使用场景：将同一件事情拆成不同的工作执行，最后等待所有的工作完成才继续执行主程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>        fmt.Println(<span class="hljs-string">&quot;job 1 done.&quot;</span>)<br>        wg.Done()<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        fmt.Println(<span class="hljs-string">&quot;job 2 done.&quot;</span>)<br>        wg.Done()<br>    &#125;()<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;All Done.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序通过<code>wg.Wait()</code>等待所有job执行完成后才最后执行。</p><p>情景扩展：虽然将job拆成了多个后，并丢到后台进行运行，我该如何终止某个<code>goroutine</code>的工作呢？</p><p>：通过使用<code>channel+select</code>来主动通知并且停止正在运行的Job。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stop:<br>          fmt.Println(<span class="hljs-string">&quot;got stop signal&quot;</span>)<br>          <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>          fmt.Println(<span class="hljs-string">&quot;still running&quot;</span>)<br>          time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>      &#125;<br>    &#125;<br>  &#125; ()<br><br>  time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>  fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>  stop &lt;- <span class="hljs-literal">true</span><br>  time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 等待goroutine结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述场景中，可以在任何地方将bool值丢入stop channel中，就可以停止正在运行的<code>goroutine</code>，但如果后台跑了多个<code>goroutine</code>，或者是在<code>goroutine</code>中又跑了<code>goroutine</code>，就没有办法用channel进行处理了。而是采用context。</p><p>拿上面的例子进行改写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ctx, cancel := context.WithCancel(context.Background())<br><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>          <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>          <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>            time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        &#125;<br>      &#125;<br>    &#125; ()<br><br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;stop the gorutine&quot;</span>)<br>    cancel()<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>  Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>  Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>  Err() <span class="hljs-type">error</span><br>  Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Deadline —— 返回context.Context被取消的时间。</li><li>Done —— 返回一个channel，会在当前工作完成或上下文被取消时关闭。</li><li><blockquote><p>多次调用Done方法会返回同一个channel。</p></blockquote></li><li>Err —— 返回context.Context结束的原因。只会在Done方法对应的channel关闭时返回非空值；</li><li><blockquote><p>如果context.Context被取消，返回<code>context.Canceled</code>；</p></blockquote></li><li><blockquote><p>如果超时，返回<code>context.DeadlineExceeded</code>。</p></blockquote></li><li>Value —— 从context.Context中获取键对应的值，对于同一个context来说，多次调用Value并传入相同的Key会返回相同的结果。</li></ul><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解Context&quot;&gt;&lt;a href=&quot;#了解Context&quot; class=&quot;headerlink&quot; title=&quot;了解Context&quot;&gt;&lt;/a&gt;了解Context&lt;/h1&gt;&lt;p&gt;控制并发的方法：&lt;code&gt;WaitGroup&lt;/code&gt;、&lt;code&gt;conte</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>rust</title>
    <link href="https://mulladylex.github.io/project/2025/09/08/rust/"/>
    <id>https://mulladylex.github.io/project/2025/09/08/rust/</id>
    <published>2025-09-08T12:32:10.000Z</published>
    <updated>2025-09-08T12:32:10.418Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Go-HTTP</title>
    <link href="https://mulladylex.github.io/project/2025/09/05/Golang/pkg-http/"/>
    <id>https://mulladylex.github.io/project/2025/09/05/Golang/pkg-http/</id>
    <published>2025-09-05T02:26:22.000Z</published>
    <updated>2025-09-10T06:57:13.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言Http包学习"><a href="#Go语言Http包学习" class="headerlink" title="Go语言Http包学习"></a>Go语言Http包学习</h1><p>go中net&#x2F;http包中，提供了HTTP客户端和服务端的实现。提供了HTTP通信过程中各种对象的定义及实现。</p><p>对于客户端，可以使用<code>Get</code>、<code>Post</code>、<code>Head</code>和<code>PostForm</code>等方法发送对应的HTTP请求，也可以通过Client类型自定义客户端，从而调用其中方法发送HTTP请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接发送请求，并接受响应</span><br>resp, err := http.Get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br>resp, err := http.PostForm(<span class="hljs-string">&quot;http://example.com&quot;</span>,<br>    url.Values&#123;<span class="hljs-string">&quot;key&quot;</span>: &#123;<span class="hljs-string">&quot;Value&quot;</span>&#125;, <span class="hljs-string">&quot;id&quot;</span>: &#123;<span class="hljs-string">&quot;123&quot;</span>&#125;&#125;)<br><span class="hljs-comment">// 客户端必须显示关闭响应体</span><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 自定义客户端</span><br>client := &amp;http.Client&#123;<br>    Timeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// 设置超时时间</span><br>    CheckRedirect: redirectFunc,    <span class="hljs-comment">// 设置重定向处理函数</span><br>&#125;<br>resp, err := client.Get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br><br><span class="hljs-comment">// 也可以预生成请求，然后使用客户端发送</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://example.com&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// ...</span><br>req.Header.Add(<span class="hljs-string">&quot;If-None-Match&quot;</span>, <span class="hljs-string">&quot;abc123&quot;</span>)<br>resp, err := client.Do(req)<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>对于传输过程，它提供了支持代理，TLS配置，keep-alive，压缩等传输方式的<code>Transport</code>类型。</p><p>对于服务端，它提供了<code>ListenAndServe</code>方法使用给定的地址和处理程序启动HTTP服务器，同时提供了<code>Server</code>类型用于自定义服务端及处理请求的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">http.Handle(<span class="hljs-string">&quot;/foo&quot;</span>, fooHandler)<br>http.HandleFunc(<span class="hljs-string">&quot;/bar&quot;</span>, barHandler)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言Http包学习&quot;&gt;&lt;a href=&quot;#Go语言Http包学习&quot; class=&quot;headerlink&quot; title=&quot;Go语言Http包学习&quot;&gt;&lt;/a&gt;Go语言Http包学习&lt;/h1&gt;&lt;p&gt;go中net&amp;#x2F;http包中，提供了HTTP客户端和服务端的</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 代理配置</title>
    <link href="https://mulladylex.github.io/project/2025/09/03/docker/docker-proxy/"/>
    <id>https://mulladylex.github.io/project/2025/09/03/docker/docker-proxy/</id>
    <published>2025-09-03T03:14:26.000Z</published>
    <updated>2025-09-03T04:15:59.126Z</updated>
    
    <content type="html"><![CDATA[<p>首先，确保你处于代理环境中，这通常需要设置HTTP和HTTPS代理。请先检查你的代理配置是否能正常访问。</p><h2 id="1-配置-Docker-使用代理"><a href="#1-配置-Docker-使用代理" class="headerlink" title="1. 配置 Docker 使用代理"></a>1. 配置 Docker 使用代理</h2><p>需要在Docker的系统服务配置中进行编辑，在<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>中添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTP_PROXY=http://&lt;proxy_address&gt;:&lt;proxy_port&gt;&quot;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTPS_PROXY=http://&lt;proxy_address&gt;:&lt;proxy_port&gt;&quot;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1,.mycompany.com&quot;</span><br></code></pre></td></tr></table></figure><p>将<code>&lt;proxy_addreess&gt;</code>和<code>&lt;proxy_port&gt;</code>替换成你实际使用的代理地址和端口。</p><blockquote><p>一般情况下，如果你没有显式地为Docker配置代理或其他自定义设置，<code>docker.service.d</code>目录默认是不存在的。</p></blockquote><h2 id="2-重新加载并重启-Docker-服务："><a href="#2-重新加载并重启-Docker-服务：" class="headerlink" title="2. 重新加载并重启 Docker 服务："></a>2. 重新加载并重启 Docker 服务：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="3-验证配置是否生效："><a href="#3-验证配置是否生效：" class="headerlink" title="3. 验证配置是否生效："></a>3. 验证配置是否生效：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker info<br></code></pre></td></tr></table></figure><p>在输出的<code>System</code>部分，可以看到 Docker 是否使用了你配置的代理。</p><blockquote><p>如果代理或网络连接较慢，可以尝试增加Docker的超时时间：<br>在<code>/etc/docker/daemon.json</code>中添加以下内容：<br><code>&#123; &quot;default-timeout&quot;: 600 &#125;</code><br>然后重启Docker</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，确保你处于代理环境中，这通常需要设置HTTP和HTTPS代理。请先检查你的代理配置是否能正常访问。&lt;/p&gt;
&lt;h2 id=&quot;1-配置-Docker-使用代理&quot;&gt;&lt;a href=&quot;#1-配置-Docker-使用代理&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="Docker" scheme="https://mulladylex.github.io/project/categories/Docker/"/>
    
    
    <category term="docker" scheme="https://mulladylex.github.io/project/tags/docker/"/>
    
    <category term="http-proxy" scheme="https://mulladylex.github.io/project/tags/http-proxy/"/>
    
    <category term="https-proxy" scheme="https://mulladylex.github.io/project/tags/https-proxy/"/>
    
    <category term="代理配置" scheme="https://mulladylex.github.io/project/tags/%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
    
    <category term="linux" scheme="https://mulladylex.github.io/project/tags/linux/"/>
    
    <category term="docker配置" scheme="https://mulladylex.github.io/project/tags/docker%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://mulladylex.github.io/project/2025/09/02/linux/"/>
    <id>https://mulladylex.github.io/project/2025/09/02/linux/</id>
    <published>2025-09-02T02:14:08.000Z</published>
    <updated>2025-09-10T06:02:18.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux系统简介及安装"><a href="#1-Linux系统简介及安装" class="headerlink" title="1 Linux系统简介及安装"></a>1 Linux系统简介及安装</h1><p>Linux 是一个自由和开放源码的类 UNIX 操作系统内核。它是由林纳斯・托瓦兹（Linus Torvalds）于 1991 年首次发布的。Linux 系统以其稳定性、安全性和灵活性而闻名，广泛应用于服务器、桌面、移动设备和嵌入式系统。</p><h2 id="1-1-Linux系统的特点"><a href="#1-1-Linux系统的特点" class="headerlink" title="1.1 Linux系统的特点"></a>1.1 Linux系统的特点</h2><p>开源自由：Linux 的源代码可以被任何人查看、修改和分发。<br>稳定安全：Linux 系统经过严格的测试，具有很高的稳定性和安全性。<br>资源占用少：Linux 系统对硬件资源的要求较低，可以在老旧的硬件上高效运行。<br>强大的社区支持：全球有大量的开发者和技术爱好者支持 Linux 的发展。  </p><h2 id="1-2-Linux系统的安装"><a href="#1-2-Linux系统的安装" class="headerlink" title="1.2 Linux系统的安装"></a>1.2 Linux系统的安装</h2><h2 id="1-2-1-光盘安装"><a href="#1-2-1-光盘安装" class="headerlink" title="1.2.1 光盘安装"></a>1.2.1 光盘安装</h2><h2 id="1-2-2-USB闪存安装"><a href="#1-2-2-USB闪存安装" class="headerlink" title="1.2.2 USB闪存安装"></a>1.2.2 USB闪存安装</h2><h2 id="1-2-3-虚拟机安装"><a href="#1-2-3-虚拟机安装" class="headerlink" title="1.2.3 虚拟机安装"></a>1.2.3 虚拟机安装</h2><h2 id="2-Linux系统的基本操作"><a href="#2-Linux系统的基本操作" class="headerlink" title="2 Linux系统的基本操作"></a>2 Linux系统的基本操作</h2><p>Linux文件系统是Linux操作系统中用于组织和存储文件和目录的结构。它采用层次化的目录结构，所有文件和目录都从根目录（&#x2F;）开始。</p><p>每个文件都组织在一个分层的目录树中，这些文件和目录的位置被称为路径。有两种类型的路径：绝对路径和相对路径。</p><p>绝对路径：从根目录开始的完整路径。</p><p>相对路径：相对于当前工作目录的路径。</p><ul><li>. (当前目录)：当前所在的目录</li><li>.. (上级目录)：当前目录的父目录</li><li>~ (用户主目录)：当前用户的主目录</li><li><ul><li>(上一个目录)：上一次所在的目录</li></ul></li></ul><h3 id="2-1-文件系统的结构"><a href="#2-1-文件系统的结构" class="headerlink" title="2.1 文件系统的结构"></a>2.1 文件系统的结构</h3><ul><li>根目录（&#x2F;）：所有文件和目录的起点。</li><li>&#x2F;bin：存放二进制可执行文件。</li><li>&#x2F;etc：存放系统配置文件。</li><li>&#x2F;home：用户的主目录。</li><li>&#x2F;var：存放可变数据，如日志文件。</li><li>&#x2F;usr：存放用户程序和数据。</li><li>&#x2F;tmp：存放临时文件。</li><li>&#x2F;dev：存放设备文件。</li><li>&#x2F;root：超级用户的主目录。</li></ul><h3 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h3><ul><li>ls：列出目录内容。</li><li>cd：更改当前目录。</li><li>pwd：显示当前目录路径。</li><li>cp：复制文件或目录。</li><li>mv：移动或重命名文件或目录。</li><li>rm：删除文件或目录。</li><li>mkdir：创建新目录。</li><li>rmdir：删除空目录。</li><li>touch：创建空文件或更新文件的时间戳。</li><li>cat：显示文件内容。</li><li>more&#x2F;less：分页显示文件内容。</li><li>find：查找文件或目录。</li><li>grep：搜索文件内容。</li><li>chmod：更改文件或目录的权限。</li><li>ps：显示当前运行的进程。</li><li>kill：终止进程。</li><li>tar：打包和解包文件。</li><li>zip&#x2F;unzip：压缩和解压文件。</li><li>ssh：远程登录到另一台计算机。</li><li>scp：在本地和远程计算机之间复制文件。</li><li>wget：从网络下载文件。</li><li>curl：与服务器进行数据传输。</li></ul><h3 id="2-3-系统管理命令"><a href="#2-3-系统管理命令" class="headerlink" title="2.3 系统管理命令"></a>2.3 系统管理命令</h3><ul><li>systemctl：管理系统服务。</li><li>top：实时显示系统资源使用情况。</li><li>df：显示文件系统的磁盘空间使用情况。</li><li>du：显示文件或目录的磁盘使用情况。</li><li>ifconfig&#x2F;ip：显示或配置网络接口。</li><li>ping：测试网络连接。</li><li>netstat：显示网络连接、路由表和接口统计。</li></ul><h3 id="2-4-终端操作"><a href="#2-4-终端操作" class="headerlink" title="2.4 终端操作"></a>2.4 终端操作</h3><p>终端打开方式：<br>快捷键：Ctrl + Alt + T<br>菜单右键：Open Terminal<br>直接Ctrl + Alt + F2 进入纯命令行模式</p><p>sudo !!<br>以前执行的命令加上sudo权限重新执行</p><p>常用文本编辑器<br>vim：功能强大的文本编辑器，适合编写和编辑代码。<br>nano：简单易用的文本编辑器，适合快速编辑文件。<br>gedit：图形化文本编辑器，适合初学者使用。</p><p>脚本编写基础</p><h2 id="软件包管理与仓库使用"><a href="#软件包管理与仓库使用" class="headerlink" title="软件包管理与仓库使用"></a>软件包管理与仓库使用</h2><h3 id="3-1-软件包管理工具"><a href="#3-1-软件包管理工具" class="headerlink" title="3.1 软件包管理工具"></a>3.1 软件包管理工具</h3><p>APT（Advanced Package Tool）：用于Debian及其衍生版（如Ubuntu）的包管理工具。常用命令包括：</p><ul><li>sudo apt update：更新软件包列表。</li><li>sudo apt upgrade：升级已安装的软件包。</li><li>sudo apt install <package_name>：安装指定的软件包。</package_name></li><li>sudo apt remove <package_name>：卸载指定的软件包。</package_name></li><li>sudo apt search <package_name>：搜索软件包。</package_name></li></ul><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>根据发行版的不同，Linux 系统可能预装了不同的 Shell。常见的 Shell 包括 Bash（Bourne Again Shell）、Zsh（Z Shell）和 Fish（Friendly Interactive Shell）。其中，Bash 是最常用和广泛支持的 Shell。你的 Shell 提示符可能会有所不同，但多数情况下，它应该遵循以下格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">username@hostname:current_directory$<br></code></pre></td></tr></table></figure><p>不同的shell会有不同的提示符风格，例如：$</p><p>echo 命令，将文本参数打印到显示器上。</p><p>pwd 命令，显示当前工作目录的完整路径。</p><p>cd 命令，改变当前工作目录。</p><p>ls 命令，列出当前目录下的文件和子目录</p><p>ls 会默认列出当前目录中的目录和文件，但也可以指定要列出其目录的路径。</p><blockquote><p>并非目录中的所有文件都可见，某些文件可能是隐藏的。以点 (.) 开头的文件被视为隐藏文件。<br>但是可以使用 <code>-a</code> 选项来显示所有文件，包括隐藏文件。<br>还有一个有用的选项是 <code>-l</code>，它以长格式列出文件，显示有关每个文件的更多信息，从左到右依次为：<br>文件类型和权限、链接数、所有者、组、文件大小、最后修改时间和文件名。</p></blockquote><p>touch 命令，创建一个新的空文件，或者更新现有文件的访问和修改时间。</p><p>file 命令，确定文件类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Linux系统简介及安装&quot;&gt;&lt;a href=&quot;#1-Linux系统简介及安装&quot; class=&quot;headerlink&quot; title=&quot;1 Linux系统简介及安装&quot;&gt;&lt;/a&gt;1 Linux系统简介及安装&lt;/h1&gt;&lt;p&gt;Linux 是一个自由和开放源码的类 UNI</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Golang 项目布局</title>
    <link href="https://mulladylex.github.io/project/2025/08/25/Golang/go-layout/"/>
    <id>https://mulladylex.github.io/project/2025/08/25/Golang/go-layout/</id>
    <published>2025-08-25T06:45:56.000Z</published>
    <updated>2025-09-04T06:04:27.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-项目布局"><a href="#Golang-项目布局" class="headerlink" title="Golang 项目布局"></a>Golang 项目布局</h1><p>在 Go 语言中，项目布局（Project Layout）是指如何组织和结构化代码文件和目录，以便于开发、维护和协作。一个良好的项目布局可以提高代码的可读性、可维护性和可扩展性。</p><h2 id="常见的项目布局结构"><a href="#常见的项目布局结构" class="headerlink" title="常见的项目布局结构"></a>常见的项目布局结构</h2><p>以下是一个常见的 Go 项目布局结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">myproject/<br>├── cmd/                # 主应用程序目录<br>│   └── myapp/         # 每个子目录对应一个可执行文件<br>│       └── main.go    # 主程序入口<br>├── pkg/                # 可重用的库代码<br>│   └── mylib/        # 每个子目录对应一个库<br>│       └── mylib.go   # 库代码<br>├── internal/          # 私有库代码，不能被外部使用<br>│   └── myinternal/   # 每个子目录对应一个私有库<br>│       └── myinternal.go # 私有库代码<br>├── api/                # API 定义和协议文件<br>│   └── v1/           # 版本化的 API<br>│       └── api.proto  # API 协议文件<br>├── web/                # Web 相关文件（HTML、CSS、JS）<br>│   └── static/       # 静态资源<br>│       └── style.css  # 样式文件<br>├── configs/           # 配置文件<br>│   └── config.yaml   # 配置文件<br>├── scripts/           # 构建和部署脚本<br>│   └── build.sh      # 构建脚本<br>├── test/              # 测试代码<br>│   └── myapp_test.go # 测试文件<br>├── go.mod             # Go 模块文件<br>├── go.sum             # Go 模块校验文件<br>└── README.md         # 项目说明文件<br></code></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><code>cmd/</code> 目录包含主应用程序的代码，每个子目录对应一个可执行文件。</li><li><code>pkg/</code> 目录包含可重用的库代码，可以被其他项目导入使用。</li><li><code>internal/</code> 目录包含私有库代码，这些代码只能在当前项目中使用，不能被外部项目导入。</li><li><code>api/</code> 目录包含 API 定义和协议文件，通常用于定义服务的接口。</li><li><code>web/</code> 目录包含与 Web 相关的文件，如 HTML、CSS 和 JavaScript。</li><li><code>configs/</code> 目录包含配置文件，用于存储应用程序的配 置参数。</li><li><code>scripts/</code> 目录包含构建和部署脚本，帮助自动化项目的构建和部署过程。</li><li><code>test/</code> 目录包含测试代码，用于验证应用程序的功能和性能。</li><li><code>go.mod</code> 和 <code>go.sum</code> 文件用于管理 Go 模块和依赖。</li><li><code>README.md</code> 文件用于提供项目的说明和文档。</li></ul><p>&#x2F;cmd<br>项目的主干，每个应用程序的目录名应该与你想要的可执行文件的名称相匹配。专门放main func 以便go build</p><p>&#x2F;pkg<br>外部应用程序可以使用的库代码，其他项目会导入这些库。可以参考go 标准库的组织方式，按照功能分类。<br>&#x2F;internal&#x2F;pkg一般用于项目内的跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p><p>&#x2F;internal<br>专门放不允许外部import的pkg，代码不是可重用的。<br>私有的应用程序和代码库。并不局限于顶级目录，在项目树的任何级别上都可以有多个内部目录。</p><p>&#x2F;api<br>API协议定义目录，service.proto protobuf文件，以及生成的go文件。通常把api文档直接在proto文件中描述。</p><p>&#x2F;configs<br>配置文件模板或默认配置</p><p>&#x2F;test<br>额外的外部测试应用程序和测试数据。可以随机根据需求构造，对于较大项目，有个数据子目录是有意义的，</p><p>服务内部目录<br>&#x2F;data<br>业务数据访问，包含cache、db等封装，实现了 biz 的 repo 接口。<br>我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。</p><p>各类package的实现在顶层目录<br>package通常取目录名称一样且不要取像 util、model 这种在写Java时常用的pattern。需要更有具体功能的名称<br>如果是要設計本來就是 for library 的方式且是不會有過多的 package 的小型專案，可以採用只需要定義 package 在根目錄上就可以了<br>如果不需要可執行檔，那麼 cmd 目錄當然也不需要<br>docs 目錄也是根據專案的大小而定，我覺得見仁見智。  </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ul><li><a href="https://blog.kennycoder.io/2022/08/20/Golang-%E8%AB%87%E8%AB%87-project-layout/">https://blog.kennycoder.io/2022/08/20/Golang-%E8%AB%87%E8%AB%87-project-layout/</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-项目布局&quot;&gt;&lt;a href=&quot;#Golang-项目布局&quot; class=&quot;headerlink&quot; title=&quot;Golang 项目布局&quot;&gt;&lt;/a&gt;Golang 项目布局&lt;/h1&gt;&lt;p&gt;在 Go 语言中，项目布局（Project Layout）是指如何组</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="https://mulladylex.github.io/project/2025/08/24/shell/"/>
    <id>https://mulladylex.github.io/project/2025/08/24/shell/</id>
    <published>2025-08-24T02:30:22.000Z</published>
    <updated>2025-08-24T02:39:04.531Z</updated>
    
    <content type="html"><![CDATA[<p>shell 脚本的学习与记录</p><p><strong>脚本开头</strong>通常需要指定解释器路径，例如：</p><p>常见的写法还有<code>#!/usr/bin/env bash</code>，这种写法可以在不同系统中更灵活地找到bash解释器的位置。</p><p>函数里<code>$1 `` $2</code>… 获取参数，<code>$@</code>获取所有参数。</p><p>彩色输出常量：</p><p>\033 表示 ANSI 转义序列，用于在终端里控制颜色。</p><p>0;31m → 红色<br>0;32m → 绿色<br>0;33m → 黄色</p><p>NC&#x3D;’\033[0m’ 用来重置颜色，避免后续输出都带颜色。</p><p>常见扩展：蓝色 0;34m，紫色 0;35m，青色 0;36m。</p><p><code>&gt;&amp;2</code>表示输出到**标准错误流 (stderr)**，方便脚本中区分错误和正常输出。</p><p>脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--- 彩色输出常量 ---</span><br>RED=&#x27;\033[0;31m&#x27;<br>GREEN=&#x27;\033[0;32m&#x27;<br>YELLOW=&#x27;\033[0;33m&#x27;<br>NC=&#x27;\033[0m&#x27; # No Color<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--- 日志函数 ---</span><br>log_info() &#123;<br>    echo -e &quot;$&#123;GREEN&#125;[INFO] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;<br>&#125;<br><br>log_warn() &#123;<br>    echo -e &quot;$&#123;YELLOW&#125;[WARNING] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;<br>&#125;<br><br>log_error() &#123;<br>    echo -e &quot;$&#123;RED&#125;[ERROR] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot; &gt;&amp;2<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;shell 脚本的学习与记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本开头&lt;/strong&gt;通常需要指定解释器路径，例如：&lt;/p&gt;
&lt;p&gt;常见的写法还有&lt;code&gt;#!/usr/bin/env bash&lt;/code&gt;，这种写法可以在不同系统中更灵活地找到bash解释器的位置。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>标准库——flag</title>
    <link href="https://mulladylex.github.io/project/2025/08/22/Golang/go-flag/"/>
    <id>https://mulladylex.github.io/project/2025/08/22/Golang/go-flag/</id>
    <published>2025-08-22T02:51:22.000Z</published>
    <updated>2025-08-22T02:55:57.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Go 语言的 flag 包提供了一个简单的命令行参数解析器。它支持定义标志（flags），解析命令行参数，并生成帮助信息。</p><h1 id><a href="#" class="headerlink" title></a></h1><p>flag库的基本使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 定义命令行标志</span><br>    wordPtr := flag.String(<span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;a string&quot;</span>)<br>    numbPtr := flag.Int(<span class="hljs-string">&quot;numb&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;an int&quot;</span>)<br>    boolPtr := flag.Bool(<span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;a bool&quot;</span>)<br><br>    <span class="hljs-comment">// 自定义标志</span><br>    <span class="hljs-keyword">var</span> svar <span class="hljs-type">string</span><br>    flag.StringVar(&amp;svar, <span class="hljs-string">&quot;svar&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;a string var&quot;</span>)<br><br>    <span class="hljs-comment">// 解析命令行标志</span><br>    flag.Parse()<br><br>    <span class="hljs-comment">// 输出标志的值</span><br>    fmt.Println(<span class="hljs-string">&quot;word:&quot;</span>, *wordPtr)<br>    fmt.Println(<span class="hljs-string">&quot;numb:&quot;</span>, *numbPtr)<br>    fmt.Println(<span class="hljs-string">&quot;fork:&quot;</span>, *boolPtr)<br>    fmt.Println(<span class="hljs-string">&quot;svar:&quot;</span>, svar)<br>    fmt.Println(<span class="hljs-string">&quot;tail:&quot;</span>, flag.Args())<br>&#125;<br></code></pre></td></tr></table></figure><p>不设置某个选项，相应变量会取默认值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;Go 语言的 flag 包提供了一个简单的命令行参数解析器。它支持定义标志（flags），解</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>GO项目部署</title>
    <link href="https://mulladylex.github.io/project/2025/08/13/Golang/go-deploy/"/>
    <id>https://mulladylex.github.io/project/2025/08/13/Golang/go-deploy/</id>
    <published>2025-08-13T12:36:22.000Z</published>
    <updated>2025-08-13T12:52:48.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-项目打包部署"><a href="#Go-项目打包部署" class="headerlink" title="Go 项目打包部署"></a>Go 项目打包部署</h1><h2 id="Go-build"><a href="#Go-build" class="headerlink" title="Go build"></a>Go build</h2><p>go build 是Golang提供的命令，会将main.go涉及到的文件都编译打包好，放在当前目录下，可以通过参数 -o 指定生成的二进制文件名。</p><p>可以打包成exe后缀文件，在Windows上直接运行</p><p>go build main.go</p><p>可以打包成二进制文件，在linux平台运行</p><p>这里通常需要使用两个变量，GOOS 目标操作系统，支持以下操作系统：<br>darwin freebsd linux windows android dragonfly netbsd openbsd plans solaris</p><p>GOARCH 目标处理器，支持以下处理器架构 arm64 arm 386 amd64 ppc64 ppc64le mips64 mips64le s390x</p><p>设置好后，就能够通过go build在当前目录下生成对应的可执行二进制文件了</p><p>通常可能需要使用 chmod 773 赋予文件权限 再进行执行。</p><p>一些编译参数</p><p>-x<br>-n<br>-a<br>-o<br>-p<br>-work<br>-race<br>-installsuffix</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-项目打包部署&quot;&gt;&lt;a href=&quot;#Go-项目打包部署&quot; class=&quot;headerlink&quot; title=&quot;Go 项目打包部署&quot;&gt;&lt;/a&gt;Go 项目打包部署&lt;/h1&gt;&lt;h2 id=&quot;Go-build&quot;&gt;&lt;a href=&quot;#Go-build&quot; class=&quot;</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>GORM</title>
    <link href="https://mulladylex.github.io/project/2025/08/07/Golang/go-gorm/"/>
    <id>https://mulladylex.github.io/project/2025/08/07/Golang/go-gorm/</id>
    <published>2025-08-07T14:23:22.000Z</published>
    <updated>2025-08-07T14:52:46.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GORM是什么"><a href="#GORM是什么" class="headerlink" title="GORM是什么"></a>GORM是什么</h1><p>GORM是go中的ORM库，用于简化数据库操作。</p><p>快速上手GORM只需了解它的安装、连接、模型定义、创建表、CRUD操作</p><ol><li><p>安装GORM</p><p> 首先，使用<code>go get</code>命令安装GORM：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get -u gorm.io/gorm<br>go get -u gorm.io/driver/mysql<br></code></pre></td></tr></table></figure><pre><code>上述命令会安装GORM以及MySql数据库驱动（如需使用其他数据库可查阅相关</code></pre><ol start="2"><li><p>连接数据库</p><p> 连接数据库的常见形式主要有以下几种：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">dsn := <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>着重注意的就是<code>user</code>,<code>password</code>,<code>database</code>为自己的数据库用户名、登录密码、库名配置。<br>3. 定义模型<br>    模型是Go结构体，对应数据库表</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code <span class="hljs-type">string</span><br>    Price <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><pre><code>gorm.Model 包含了ID，CreateAt，UpdateAt，DelegateAt字段</code></pre><ol start="4"><li><p>自动迁移</p><p> Gorm 可以自动根据模型创建表</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.AutoMigrate(&amp;Product&#123;&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>CRUD操作</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GORM是什么&quot;&gt;&lt;a href=&quot;#GORM是什么&quot; class=&quot;headerlink&quot; title=&quot;GORM是什么&quot;&gt;&lt;/a&gt;GORM是什么&lt;/h1&gt;&lt;p&gt;GORM是go中的ORM库，用于简化数据库操作。&lt;/p&gt;
&lt;p&gt;快速上手GORM只需了解它的安装、连</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>vitePress</title>
    <link href="https://mulladylex.github.io/project/2025/07/29/vitePress/"/>
    <id>https://mulladylex.github.io/project/2025/07/29/vitePress/</id>
    <published>2025-07-29T04:03:50.000Z</published>
    <updated>2025-09-03T04:09:29.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VitePress-是什么？"><a href="#VitePress-是什么？" class="headerlink" title="VitePress 是什么？"></a>VitePress 是什么？</h1><p>VitePress 不只是一个静态站点生成器，它是一个使用 Vue.js 和 Vite 技术的现代网站构建工具。它结合了 Vite 的快速热重载和 Vue 的反应式特性，为开发者提供了一个非常高效的页面开发和构建流程。这意味着你可以享受到即时的页面更新和极快的构建速度，无论是在开发过程中还是在最终的站点部署时。</p><h2 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h2><p>Vite：作为现代前端开发和构建工具，Vite 提供了极快的服务器启动和热模块替换（HMR）。</p><p>Vue.js：用于创建互动式 UI 和前端动态内容。Vue 的组件系统允许你以模块化的方式构建页面。</p><p>Markdown：所有的内容都是用 Markdown 编写的，这使得内容创作变得简单而直观。Markdown 文件可以轻松转换成 HTML，同时支持 Vue 组件，让你可以在文档中嵌入动态内容。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>速度与效率：VitePress 的最大卖点之一是其出色的性能。使用 Vite 作为底层工具，它实现了极快的页面加载和热更新，大大提高了开发效率。</p><p>SEO 友好：虽然是一个单页面应用（SPA）生成器，但 VitePress 生成的页面是 SEO 友好的。它在构建时生成静态 HTML，确保了内容的可索引性。</p><p>静态资源处理：VitePress 提供了先进的静态资源处理能力，包括图片、样式表和 JavaScript 文件的优化。这意味着你可以轻松管理和部署资源，确保网站的快速加载。</p><p>易于定制和扩展：VitePress 的架构设计允许你轻松定制主题和扩展功能。你可以使用 Vue 组件和 Vite 插件来增强你的站点，无论是添加自定义功能还是改进用户界面。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>步骤 1：设置项目结构<br>首先，我们初始化 VitePress 项目。创建一个新的文件夹并运行 npm init vitepress 来安装 VitePress。项目的基本结构将包括：</p><p>docs 文件夹：存放所有文档内容。<br>.vitepress 文件夹：用于存放配置文件和主题组件。<br>index.md：网站的主页内容。</p><p>步骤 2：内容撰写与组织<br>接下来，我们在 docs 文件夹中创建 Markdown 文件来编写文档。为了保持组织性，我们可以按照不同的主题或部门将文档分门别类：</p><p>api 文件夹：存放 API 文档。<br>guides 文件夹：存放各类指南。<br>internal 文件夹：存放内部文档。</p><p>每个文件夹中的文档都会有自己的 README.md，作为该部分的入口点。</p><p>文件管理系统：<br>储存位置管理</p><p>存取安全与权限管理</p><p>版本控制</p><p>操作稽核记录</p><p>文件签入签出与锁定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VitePress-是什么？&quot;&gt;&lt;a href=&quot;#VitePress-是什么？&quot; class=&quot;headerlink&quot; title=&quot;VitePress 是什么？&quot;&gt;&lt;/a&gt;VitePress 是什么？&lt;/h1&gt;&lt;p&gt;VitePress 不只是一个静态站点生成器</summary>
      
    
    
    
    
    <category term="vite" scheme="https://mulladylex.github.io/project/tags/vite/"/>
    
    <category term="vue" scheme="https://mulladylex.github.io/project/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>internal-network-penetration</title>
    <link href="https://mulladylex.github.io/project/2025/07/27/internal-network-penetration/"/>
    <id>https://mulladylex.github.io/project/2025/07/27/internal-network-penetration/</id>
    <published>2025-07-27T02:14:16.000Z</published>
    <updated>2025-07-29T04:04:05.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="了解什么是内网穿透"><a href="#了解什么是内网穿透" class="headerlink" title="了解什么是内网穿透"></a>了解什么是内网穿透</h2><h2 id="安装-NPS-服务端"><a href="#安装-NPS-服务端" class="headerlink" title="安装 NPS 服务端"></a>安装 NPS 服务端</h2><p>NPS 默认的WEB端口为<code>80，443</code>, 如果端口被占用，请修改<code>nps.conf</code>中的<code>http_proxy_port，https_proxy_port</code>为其他端口。 web管理端口默认为8080，服务端启动后，输入：<code>ip:8080</code>即可访问。</p><h2 id="安装-NPS-客户端-NPC"><a href="#安装-NPS-客户端-NPC" class="headerlink" title="安装 NPS 客户端(NPC)"></a>安装 NPS 客户端(NPC)</h2><p>客户端配置有两种方式，无配置文件模式（推荐）<a href></a>，配置文件模式。</p><ul><li>无配置文件模式：点击安装后，输入服务地址、连接密钥，即可启动客户端。不建议修改连接方式和开启TLS参数。</li><li><blockquote><p>如果需要配置多个客户端，直接安装多个即可（注意名字不要重复）。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内网穿透&quot;&gt;&lt;a href=&quot;#内网穿透&quot; class=&quot;headerlink&quot; title=&quot;内网穿透&quot;&gt;&lt;/a&gt;内网穿透&lt;/h1&gt;&lt;h2 id=&quot;了解什么是内网穿透&quot;&gt;&lt;a href=&quot;#了解什么是内网穿透&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mulladylex.github.io/project/2025/07/15/WebSocket/"/>
    <id>https://mulladylex.github.io/project/2025/07/15/WebSocket/</id>
    <published>2025-07-15T05:15:12.685Z</published>
    <updated>2025-09-10T06:25:19.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h1><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交互变得更加简单，允许服务器主动向客户端推送数据。在浏览器和服务器完成一次握手后，两者就直接可以创建一个持久化的连接，并进行双向通信。</p><h1 id="Gorilla-WebSocket"><a href="#Gorilla-WebSocket" class="headerlink" title="Gorilla WebSocket"></a>Gorilla WebSocket</h1><p>Gorilla WebSocket 是 Go 语言中一个流行的 WebSocket 库，提供了对 WebSocket 协议的完整支持。它支持多种功能，包括：</p><ul><li>处理 WebSocket 握手</li><li>读写消息</li><li>支持多种消息类型（文本、二进制、ping&#x2F;pong）</li><li>连接管理</li><li>支持子协议和扩展</li><li>错误处理</li></ul><p>现在我们来看看如何使用 Gorilla WebSocket 库来实现一个简单的 WebSocket 服务器和客户端。</p><h2 id="安装Gorilla-WebSocket"><a href="#安装Gorilla-WebSocket" class="headerlink" title="安装Gorilla WebSocket"></a>安装Gorilla WebSocket</h2><p>只需要使用go get命令安装Gorilla WebSocket库即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/gorilla/websocket<br></code></pre></td></tr></table></figure><h2 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h2><p>任何使用WebSocket的场景通常都需要一个服务器端和一个客户端。</p><p>服务器程序绑定到某个端口，并侦听任何传入的WebSocket连接请求。与连接有关的详细信息由websocket协议定义，并通过原始HTTP请求进行协商。</p><p>客户端程序尝试使用websocket URL与服务器建立连接。</p><h3 id="WebSocket服务器示例"><a href="#WebSocket服务器示例" class="headerlink" title="WebSocket服务器示例"></a>WebSocket服务器示例</h3><p>该服务器将在常规的HTTP服务器上实现，并添加一个socketHandler来处理WebSocket连接请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// server.go</span><br><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br> <br>    <span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br>)<br> <br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;&#125; <span class="hljs-comment">// use default options</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">socketHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-comment">// Upgrade our raw HTTP connection to a websocket based one</span><br>    conn, err := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Print(<span class="hljs-string">&quot;Error during connection upgradation:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br> <br>    <span class="hljs-comment">// The event loop</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        messageType, message, err := conn.ReadMessage()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error during message reading:&quot;</span>, err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;Received: %s&quot;</span>, message)<br>        err = conn.WriteMessage(messageType, message)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error during message writing:&quot;</span>, err)<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">home</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Index Page&quot;</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/socket&quot;</span>, socketHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, home)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>Gorilla的工作是转换原始HTTP连接进入一个有状态的websocket连接。</p><p>这就是为什么使用<code>struct</code>调用<code>Upgrader</code>来帮助我们的原因。</p><p>我们通过使用全局升级程序变量<code>upgrader.Upgrade()</code>来帮助我们将任何传入的HTTP连接转换为websocket协议。这将返回给我们<code>*websocket.Connection</code>，现在可以使用它来处理websocket连接。</p><p>服务器使用<code>conn.ReadMessage()</code>读取消息，然后使用<code>conn.WriteMessage()</code>写入消息</p><p>该服务器只是将所有传入的Websocket消息回显到客户端，这说明了如何将Websocket用于全双工通信。</p><h3 id="WebSocket客户端示例"><a href="#WebSocket客户端示例" class="headerlink" title="WebSocket客户端示例"></a>WebSocket客户端示例</h3><p>这个简单的客户端将每隔1s不断发出消息。如果整个系统按预期工作，则服务器将接受间隔为1s的数据包，并回复相同的消息。</p><p>因此客户端还将具有接收传入的websocket数据包的功能。在我们的程序中，我们将有一个单独的goroutine处理程序<code>receiveHandler</code>，用于侦听这些数据包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client.go</span><br><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;os/signal&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br> <br>    <span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br>)<br> <br><span class="hljs-keyword">var</span> done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">var</span> interrupt <span class="hljs-keyword">chan</span> os.Signal<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveHandler</span><span class="hljs-params">(connection *websocket.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br>    <span class="hljs-keyword">for</span> &#123;<br>        _, msg, err := connection.ReadMessage()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error in receive:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, msg)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// Channel to indicate that the receiverHandler is done</span><br>    interrupt = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal) <span class="hljs-comment">// Channel to listen for interrupt signal to terminate gracefully</span><br> <br>    signal.Notify(interrupt, os.Interrupt) <span class="hljs-comment">// Notify the interrupt channel for SIGINT</span><br> <br>    socketUrl := <span class="hljs-string">&quot;ws://localhost:8080&quot;</span> + <span class="hljs-string">&quot;/socket&quot;</span><br>    conn, _, err := websocket.DefaultDialer.Dial(socketUrl, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Error connecting to Websocket Server:&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    <span class="hljs-keyword">go</span> receiveHandler(conn)<br> <br>    <span class="hljs-comment">// Our main loop for the client</span><br>    <span class="hljs-comment">// We send our relevant packets here</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(<span class="hljs-number">1</span>) * time.Millisecond * <span class="hljs-number">1000</span>):<br>            <span class="hljs-comment">// Send an echo packet every second</span><br>            err := conn.WriteMessage(websocket.TextMessage, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from GolangDocs!&quot;</span>))<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Println(<span class="hljs-string">&quot;Error during writing to websocket:&quot;</span>, err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br> <br>        <span class="hljs-keyword">case</span> &lt;-interrupt:<br>            <span class="hljs-comment">// We received a SIGINT (Ctrl + C). Terminate gracefully...</span><br>            log.Println(<span class="hljs-string">&quot;Received SIGINT interrupt signal. Closing all pending connections&quot;</span>)<br> <br>            <span class="hljs-comment">// Close our websocket connection</span><br>            err := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Println(<span class="hljs-string">&quot;Error during closing websocket:&quot;</span>, err)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br> <br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                log.Println(<span class="hljs-string">&quot;Receiver Channel Closed! Exiting....&quot;</span>)<br>            <span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(<span class="hljs-number">1</span>) * time.Second):<br>                log.Println(<span class="hljs-string">&quot;Timeout in closing receiving channel. Exiting....&quot;</span>)<br>            &#125;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您观察代码，您会发现创建了两个通道<code>done</code>，<code>interrupt</code>用于<code>receiveHandler()</code>和<code>main()</code>之间的通信。</p><p>我们使用无限循环 + select来监听通道事件。<code>conn.WriteMessage()</code>每秒钟写一条消息。如果激活了中断信号，则所有未决的连接都将关闭，并且正常退出！</p><p>嵌套select是为了确保两件事：</p><ul><li>如果<code>receiveHandler</code>通道退出，则通道<code>done</code>将关闭。这是第一个<code>case &lt;-done</code>条件</li><li>如果<code>done</code>通道未关闭，则在1秒钟后会有超时，因此程序将在1秒钟超时后退出</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是WebSocket&quot;&gt;&lt;a href=&quot;#什么是WebSocket&quot; class=&quot;headerlink&quot; title=&quot;什么是WebSocket&quot;&gt;&lt;/a&gt;什么是WebSocket&lt;/h1&gt;&lt;p&gt;WebSocket 是一种在单个 TCP 连接上进行全双工通</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HelloGit</title>
    <link href="https://mulladylex.github.io/project/2025/03/03/HelloGit/"/>
    <id>https://mulladylex.github.io/project/2025/03/03/HelloGit/</id>
    <published>2025-03-02T17:41:31.000Z</published>
    <updated>2025-07-29T12:50:14.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><blockquote><p>快查表<br><img src="/project/project/2025/03/03/HelloGit/HelloGit/gitcommand.png" alt="常用指令"></p></blockquote><ul><li>Workspace: 工作区</li><li>Index&#x2F;Stage: 暂存区</li><li>Repository: 本地仓库</li><li>Remote: 远程仓库</li></ul><h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下新建一个git仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建目录并创建仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下下载一个项目和他的代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h1 id="gitconfig"><a href="#gitconfig" class="headerlink" title="gitconfig"></a>gitconfig</h1><p>Git 的配置文件</p><h1 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h1><p>Git 仓库中的每一次提交都是一个快照，它记录了每次提交时的全部文件内容。但不同于将整个目录复制粘贴，它会将当前版本与仓库中上一个版本进行对比，并把所有差异打包到一起作为一个提交记录。与此同时，git 还保存了提交的历史记录，这也是为什么大多数提交记录上都有 parent 节点的原因。对于项目组成员而言，维护提交历史对大家都有好处。</p><h1 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h1><p>Git的分支也只是简单地指向某个提交记录，因此，<strong>早建分支！多用分支！</strong>。分支并不会造成存储或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><blockquote><p>在 git 2.23 版本中，引入了 git switch 的新命令，最终会取代 git checkout 。因为 checkout 作为单个命令承载了很多独立的功能。</p></blockquote><h1 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h1><p>Git的合并操作会把两个分支的提交记录合并到一起，形成一个新的提交记录。合并操作会把两个分支的冲突部分自动解决，但也有可能会出现合并失败的情况，这时就需要手动解决冲突。</p><p>先看第一种方法： git merge </p><p> git rebase<br>取出一系列的提交记录，“复制”后在另外一个地方逐个的放下去。</p><p> Rebase 的优势是可以创造更线性的提交历史。</p><p>HEAD<br> HEAD 总是指向当前分支名，也就是最新提交的快照。 大多数修改提交树的 git 命令都是从改变HEAD的指向开始的。</p><p>分离的 HEAD 就是让其指向具体的提交记录而非分支名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Git&quot;&gt;&lt;a href=&quot;#什么是Git&quot; class=&quot;headerlink&quot; title=&quot;什么是Git&quot;&gt;&lt;/a&gt;什么是Git&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;快查表&lt;br&gt;&lt;img src=&quot;/project/project/2025/03</summary>
      
    
    
    
    
  </entry>
  
</feed>
