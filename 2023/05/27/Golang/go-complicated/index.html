<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Golang并发 | LexLady</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LexLady" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Golang并发</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-05-27T07:26:22.000Z" id="date"> 2023-05-27</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-09-10T09:19:04.138Z" id="updated"> 2025-09-10</time></div></span></div></div><hr><div id="post-content"><!-- TODO：并发教程 -->
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发指的是程序同时执行多个任务的能力。即在重叠的时间段内执行而非顺序执行。</p>
<p>并发执行的关键是，计算可以在不等待所有其他计算完成的情况下推进。因此就需要确保程序之间</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p><code>Go</code>语言支持并发，只需要通过<code>go</code>关键字来开启<code>goroutine</code>即可。</p>
<p><code>goroutine</code>是轻量级线程，<code>goroutine</code>的调度是由<code>Golang</code>运行时进行管理的。</p>
<p>语法：<code>go 函数名()</code>开启一个新的<code>goroutine</code></p>
<p>同一个程序中的所有<code>goroutine</code>共享同一个地址空间。</p>
<p>Goroutine是非阻塞的，可以高效运行上万个Goroutine</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>通道（Channel）是用于 Goroutine 之间的数据传递，支持同步和数据共享，避免了显示的锁机制。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。</p>
<p>使用 make 函数，通过关键字<code>chan</code>创建一个 channel，使用 &lt;- 操作符发送和接收数据。如果未指定方向，则为双向通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- v    <span class="hljs-comment">// 把 v 发送到通道 ch</span><br>v := &lt;-ch  <span class="hljs-comment">// 从 ch 接收数据</span><br>           <span class="hljs-comment">// 并把值赋给 v</span><br></code></pre></td></tr></table></figure>
<p>通道在使用前必须先创建：</p>
<p><code>ch := make(chan int)</code></p>
<blockquote>
<p>注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</p>
</blockquote>
<h3 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h3><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>
<p><code>ch := make(chan int, 100)</code></p>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<blockquote>
<p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
</blockquote>
<h3 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h3><p>通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>
<p>v, ok :&#x3D; &lt;-ch</p>
<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<h4 id="实例（用go-并发实现斐波那契数列）"><a href="#实例（用go-并发实现斐波那契数列）" class="headerlink" title="实例（用go 并发实现斐波那契数列）"></a>实例（用go 并发实现斐波那契数列）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// fibonacci 生成前n项的斐波那契数列并写入通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        c &lt;- x<br>        x, y = y, x+y<br>    &#125;<br>    <span class="hljs-built_in">close</span>(c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">10</span><br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">go</span> fibonacci(n, c)<br>    <span class="hljs-comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span><br>    <span class="hljs-comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span><br>    <span class="hljs-comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span><br>    <span class="hljs-comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>        fmt.Println(i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h2><p>select 语句使得一个 goroutine 可以等待多个通信操作。select 会阻塞，直到其中的某个 case 可以继续执行。</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>Go 的Scheduler是基于 GMP 模型，调度器会将 Goroutine 分配到系统线程中执行，并通过 M 和 P 的配合高效管理并发。</p>
<p>G：Goroutine。<br>M：系统线程（Machine）。<br>P：逻辑处理器（Processor）。</p>
<h2 id="其他高级特性"><a href="#其他高级特性" class="headerlink" title="其他高级特性"></a>其他高级特性</h2><p><strong>Context</strong></p>
<p>用于控制 Goroutine 的生命周期。</p>
<p><code>context.WithCancel、context.WithTimeout</code></p>
<p><strong>Mutex 和 RWMutex</strong></p>
<p>sync.Mutex 提供互斥锁，用于保护共享资源。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br><span class="hljs-comment">// critical section</span><br>mu.Unlock()<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/07/18/docker/docker/">← Next docker</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/05/27/Golang/go-error/">错误处理 Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Lexlady</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine"><span class="toc-number">1.1.</span> <span class="toc-text">Goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">1.2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">通道缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93%E4%B8%8E%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">Go 遍历通道与关闭通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%88%E7%94%A8go-%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">实例（用go 并发实现斐波那契数列）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Select-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">Select 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">其他高级特性</span></a></li></ol></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>